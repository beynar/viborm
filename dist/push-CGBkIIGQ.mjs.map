{"version":3,"file":"push-CGBkIIGQ.mjs","names":["sortOperations","sql"],"sources":["../src/migrations/differ.ts","../src/migrations/resolver.ts","../src/migrations/serializer.ts","../src/migrations/types.ts","../src/migrations/push.ts"],"sourcesContent":["/**\n * Schema Differ\n *\n * Compares two SchemaSnapshots and produces a list of DiffOperations,\n * detecting ambiguous changes that require user input.\n */\n\nimport type {\n  AmbiguousChange,\n  ColumnDef,\n  DiffOperation,\n  DiffResult,\n  EnumDef,\n  ForeignKeyDef,\n  IndexDef,\n  SchemaSnapshot,\n  TableDef,\n  UniqueConstraintDef,\n} from \"./types\";\n\n// =============================================================================\n// HELPER FUNCTIONS\n// =============================================================================\n\nfunction columnsEqual(a: ColumnDef, b: ColumnDef): boolean {\n  return (\n    a.name === b.name &&\n    normalizeType(a.type) === normalizeType(b.type) &&\n    a.nullable === b.nullable &&\n    normalizeDefault(a.default) === normalizeDefault(b.default)\n  );\n}\n\nfunction normalizeType(type: string): string {\n  // Normalize type names for comparison\n  const normalized = type.toLowerCase().trim();\n\n  // Handle common aliases\n  const aliases: Record<string, string> = {\n    int4: \"integer\",\n    int8: \"bigint\",\n    int2: \"smallint\",\n    float4: \"real\",\n    float8: \"double precision\",\n    bool: \"boolean\",\n    timestamptz: \"timestamp with time zone\",\n    timetz: \"time with time zone\",\n  };\n\n  return aliases[normalized] || normalized;\n}\n\nfunction normalizeDefault(defaultVal: string | undefined): string | undefined {\n  if (defaultVal === undefined) return undefined;\n\n  // Normalize common default expressions\n  const normalized = defaultVal.trim().toLowerCase();\n\n  // Handle NULL\n  if (normalized === \"null\") return \"null\";\n\n  // Handle boolean values\n  if (normalized === \"true\" || normalized === \"'t'\" || normalized === \"1\")\n    return \"true\";\n  if (normalized === \"false\" || normalized === \"'f'\" || normalized === \"0\")\n    return \"false\";\n\n  return defaultVal;\n}\n\nfunction indexesEqual(a: IndexDef, b: IndexDef): boolean {\n  return (\n    a.name === b.name &&\n    a.unique === b.unique &&\n    arraysEqual(a.columns, b.columns) &&\n    a.type === b.type &&\n    a.where === b.where\n  );\n}\n\nfunction foreignKeysEqual(a: ForeignKeyDef, b: ForeignKeyDef): boolean {\n  return (\n    a.name === b.name &&\n    arraysEqual(a.columns, b.columns) &&\n    a.referencedTable === b.referencedTable &&\n    arraysEqual(a.referencedColumns, b.referencedColumns) &&\n    a.onDelete === b.onDelete &&\n    a.onUpdate === b.onUpdate\n  );\n}\n\nfunction uniqueConstraintsEqual(\n  a: UniqueConstraintDef,\n  b: UniqueConstraintDef\n): boolean {\n  return a.name === b.name && arraysEqual(a.columns, b.columns);\n}\n\nfunction arraysEqual<T>(a: T[], b: T[]): boolean {\n  if (a.length !== b.length) return false;\n  return a.every((val, idx) => val === b[idx]);\n}\n\nfunction enumsEqual(a: EnumDef, b: EnumDef): boolean {\n  return a.name === b.name && arraysEqual(a.values, b.values);\n}\n\n// =============================================================================\n// TABLE DIFFER\n// =============================================================================\n\ninterface TableDiffResult {\n  operations: DiffOperation[];\n  ambiguousChanges: AmbiguousChange[];\n}\n\nfunction diffTable(\n  tableName: string,\n  current: TableDef,\n  desired: TableDef\n): TableDiffResult {\n  const operations: DiffOperation[] = [];\n  const ambiguousChanges: AmbiguousChange[] = [];\n\n  // Build column maps\n  const currentColumns = new Map(current.columns.map((c) => [c.name, c]));\n  const desiredColumns = new Map(desired.columns.map((c) => [c.name, c]));\n\n  // Find dropped and added columns\n  const droppedColumns: ColumnDef[] = [];\n  const addedColumns: ColumnDef[] = [];\n\n  for (const [name, col] of currentColumns) {\n    if (!desiredColumns.has(name)) {\n      droppedColumns.push(col);\n    }\n  }\n\n  for (const [name, col] of desiredColumns) {\n    if (!currentColumns.has(name)) {\n      addedColumns.push(col);\n    }\n  }\n\n  // Detect potential column renames (ambiguous changes)\n  // A rename is suspected when a column is dropped and another is added\n  // with compatible types\n  const usedDropped = new Set<string>();\n  const usedAdded = new Set<string>();\n\n  for (const dropped of droppedColumns) {\n    for (const added of addedColumns) {\n      if (usedDropped.has(dropped.name) || usedAdded.has(added.name)) continue;\n\n      // Check if types are compatible (could be a rename)\n      const droppedType = normalizeType(dropped.type);\n      const addedType = normalizeType(added.type);\n\n      if (droppedType === addedType) {\n        // This could be a rename - mark as ambiguous\n        ambiguousChanges.push({\n          type: \"ambiguousColumn\",\n          tableName,\n          droppedColumn: dropped,\n          addedColumn: added,\n        });\n        usedDropped.add(dropped.name);\n        usedAdded.add(added.name);\n      }\n    }\n  }\n\n  // Add operations for non-ambiguous drops and adds\n  for (const dropped of droppedColumns) {\n    if (!usedDropped.has(dropped.name)) {\n      operations.push({\n        type: \"dropColumn\",\n        tableName,\n        columnName: dropped.name,\n      });\n    }\n  }\n\n  for (const added of addedColumns) {\n    if (!usedAdded.has(added.name)) {\n      operations.push({\n        type: \"addColumn\",\n        tableName,\n        column: added,\n      });\n    }\n  }\n\n  // Check for column modifications (same name, different properties)\n  for (const [name, desiredCol] of desiredColumns) {\n    const currentCol = currentColumns.get(name);\n    if (currentCol && !columnsEqual(currentCol, desiredCol)) {\n      operations.push({\n        type: \"alterColumn\",\n        tableName,\n        columnName: name,\n        from: currentCol,\n        to: desiredCol,\n      });\n    }\n  }\n\n  // Diff indexes\n  const currentIndexes = new Map(current.indexes.map((i) => [i.name, i]));\n  const desiredIndexes = new Map(desired.indexes.map((i) => [i.name, i]));\n\n  for (const [name, idx] of currentIndexes) {\n    const desiredIdx = desiredIndexes.get(name);\n    if (!desiredIdx) {\n      operations.push({ type: \"dropIndex\", indexName: name });\n    } else if (!indexesEqual(idx, desiredIdx)) {\n      // Index changed - drop and recreate\n      operations.push({ type: \"dropIndex\", indexName: name });\n      operations.push({ type: \"createIndex\", tableName, index: desiredIdx });\n    }\n  }\n\n  for (const [name, idx] of desiredIndexes) {\n    if (!currentIndexes.has(name)) {\n      operations.push({ type: \"createIndex\", tableName, index: idx });\n    }\n  }\n\n  // Diff foreign keys\n  const currentFks = new Map(current.foreignKeys.map((fk) => [fk.name, fk]));\n  const desiredFks = new Map(desired.foreignKeys.map((fk) => [fk.name, fk]));\n\n  for (const [name, fk] of currentFks) {\n    const desiredFk = desiredFks.get(name);\n    if (!desiredFk) {\n      operations.push({ type: \"dropForeignKey\", tableName, fkName: name });\n    } else if (!foreignKeysEqual(fk, desiredFk)) {\n      // FK changed - drop and recreate\n      operations.push({ type: \"dropForeignKey\", tableName, fkName: name });\n      operations.push({ type: \"addForeignKey\", tableName, fk: desiredFk });\n    }\n  }\n\n  for (const [name, fk] of desiredFks) {\n    if (!currentFks.has(name)) {\n      operations.push({ type: \"addForeignKey\", tableName, fk });\n    }\n  }\n\n  // Diff unique constraints\n  const currentUniques = new Map(\n    current.uniqueConstraints.map((u) => [u.name, u])\n  );\n  const desiredUniques = new Map(\n    desired.uniqueConstraints.map((u) => [u.name, u])\n  );\n\n  for (const [name, uq] of currentUniques) {\n    const desiredUq = desiredUniques.get(name);\n    if (!desiredUq) {\n      operations.push({\n        type: \"dropUniqueConstraint\",\n        tableName,\n        constraintName: name,\n      });\n    } else if (!uniqueConstraintsEqual(uq, desiredUq)) {\n      operations.push({\n        type: \"dropUniqueConstraint\",\n        tableName,\n        constraintName: name,\n      });\n      operations.push({\n        type: \"addUniqueConstraint\",\n        tableName,\n        constraint: desiredUq,\n      });\n    }\n  }\n\n  for (const [name, uq] of desiredUniques) {\n    if (!currentUniques.has(name)) {\n      operations.push({\n        type: \"addUniqueConstraint\",\n        tableName,\n        constraint: uq,\n      });\n    }\n  }\n\n  // Diff primary key\n  const currentPk = current.primaryKey;\n  const desiredPk = desired.primaryKey;\n\n  if (currentPk && !desiredPk) {\n    operations.push({\n      type: \"dropPrimaryKey\",\n      tableName,\n      constraintName: currentPk.name || `${tableName}_pkey`,\n    });\n  } else if (!currentPk && desiredPk) {\n    operations.push({\n      type: \"addPrimaryKey\",\n      tableName,\n      primaryKey: desiredPk,\n    });\n  } else if (\n    currentPk &&\n    desiredPk &&\n    !arraysEqual(currentPk.columns, desiredPk.columns)\n  ) {\n    operations.push({\n      type: \"dropPrimaryKey\",\n      tableName,\n      constraintName: currentPk.name || `${tableName}_pkey`,\n    });\n    operations.push({\n      type: \"addPrimaryKey\",\n      tableName,\n      primaryKey: desiredPk,\n    });\n  }\n\n  return { operations, ambiguousChanges };\n}\n\n// =============================================================================\n// MAIN DIFFER\n// =============================================================================\n\n/**\n * Compares two schema snapshots and returns the operations needed to\n * transform the current schema into the desired schema.\n */\nexport function diff(\n  current: SchemaSnapshot,\n  desired: SchemaSnapshot\n): DiffResult {\n  const operations: DiffOperation[] = [];\n  const ambiguousChanges: AmbiguousChange[] = [];\n\n  // Build table maps\n  const currentTables = new Map(current.tables.map((t) => [t.name, t]));\n  const desiredTables = new Map(desired.tables.map((t) => [t.name, t]));\n\n  // Find dropped and added tables\n  const droppedTables: string[] = [];\n  const addedTables: string[] = [];\n\n  for (const [name] of currentTables) {\n    if (!desiredTables.has(name)) {\n      droppedTables.push(name);\n    }\n  }\n\n  for (const [name] of desiredTables) {\n    if (!currentTables.has(name)) {\n      addedTables.push(name);\n    }\n  }\n\n  // Detect potential table renames (ambiguous changes)\n  const usedDropped = new Set<string>();\n  const usedAdded = new Set<string>();\n\n  // For table renames, we check if the structure is similar\n  for (const droppedName of droppedTables) {\n    const droppedTable = currentTables.get(droppedName)!;\n\n    for (const addedName of addedTables) {\n      if (usedDropped.has(droppedName) || usedAdded.has(addedName)) continue;\n\n      const addedTable = desiredTables.get(addedName)!;\n\n      // Check if tables have similar structure (same column names)\n      const droppedColNames = new Set(droppedTable.columns.map((c) => c.name));\n      const addedColNames = new Set(addedTable.columns.map((c) => c.name));\n\n      // Calculate similarity (Jaccard index)\n      const intersection = [...droppedColNames].filter((n) =>\n        addedColNames.has(n)\n      );\n      const union = new Set([...droppedColNames, ...addedColNames]);\n      const similarity = intersection.length / union.size;\n\n      // If tables are very similar (>= 70% column overlap), suggest rename\n      if (similarity >= 0.7) {\n        ambiguousChanges.push({\n          type: \"ambiguousTable\",\n          droppedTable: droppedName,\n          addedTable: addedName,\n        });\n        usedDropped.add(droppedName);\n        usedAdded.add(addedName);\n      }\n    }\n  }\n\n  // Add operations for non-ambiguous table drops and creates\n  for (const name of droppedTables) {\n    if (!usedDropped.has(name)) {\n      operations.push({ type: \"dropTable\", tableName: name });\n    }\n  }\n\n  for (const name of addedTables) {\n    if (!usedAdded.has(name)) {\n      const table = desiredTables.get(name)!;\n      operations.push({ type: \"createTable\", table });\n    }\n  }\n\n  // Diff existing tables\n  for (const [name, desiredTable] of desiredTables) {\n    const currentTable = currentTables.get(name);\n    if (currentTable) {\n      const tableDiff = diffTable(name, currentTable, desiredTable);\n      operations.push(...tableDiff.operations);\n      ambiguousChanges.push(...tableDiff.ambiguousChanges);\n    }\n  }\n\n  // Diff enums (PostgreSQL specific)\n  if (current.enums || desired.enums) {\n    const currentEnums = new Map((current.enums || []).map((e) => [e.name, e]));\n    const desiredEnums = new Map((desired.enums || []).map((e) => [e.name, e]));\n\n    // Dropped enums\n    for (const [name] of currentEnums) {\n      if (!desiredEnums.has(name)) {\n        operations.push({ type: \"dropEnum\", enumName: name });\n      }\n    }\n\n    // Added enums\n    for (const [name, enumDef] of desiredEnums) {\n      if (!currentEnums.has(name)) {\n        operations.push({ type: \"createEnum\", enumDef });\n      }\n    }\n\n    // Modified enums\n    for (const [name, desiredEnum] of desiredEnums) {\n      const currentEnum = currentEnums.get(name);\n      if (currentEnum && !enumsEqual(currentEnum, desiredEnum)) {\n        const addValues = desiredEnum.values.filter(\n          (v) => !currentEnum.values.includes(v)\n        );\n        const removeValues = currentEnum.values.filter(\n          (v) => !desiredEnum.values.includes(v)\n        );\n\n        if (addValues.length > 0 || removeValues.length > 0) {\n          operations.push({\n            type: \"alterEnum\",\n            enumName: name,\n            addValues: addValues.length > 0 ? addValues : undefined,\n            removeValues: removeValues.length > 0 ? removeValues : undefined,\n          });\n        }\n      }\n    }\n  }\n\n  // Sort operations for proper execution order\n  return {\n    operations: sortOperations(operations),\n    ambiguousChanges,\n  };\n}\n\n// =============================================================================\n// OPERATION ORDERING\n// =============================================================================\n\n/**\n * Sorts operations for proper execution order:\n * 1. Create enums (before tables that use them)\n * 2. Drop foreign keys (before dropping tables/columns)\n * 3. Drop indexes\n * 4. Drop unique constraints\n * 5. Drop primary keys\n * 6. Drop columns\n * 7. Drop tables\n * 8. Create tables\n * 9. Add columns\n * 10. Alter columns\n * 11. Rename tables/columns\n * 12. Add primary keys\n * 13. Add unique constraints\n * 14. Create indexes\n * 15. Add foreign keys (after tables/columns exist)\n * 16. Alter enums\n * 17. Drop enums (after tables that use them are dropped)\n */\nfunction sortOperations(operations: DiffOperation[]): DiffOperation[] {\n  const priority: Record<DiffOperation[\"type\"], number> = {\n    createEnum: 1,\n    dropForeignKey: 2,\n    dropIndex: 3,\n    dropUniqueConstraint: 4,\n    dropPrimaryKey: 5,\n    dropColumn: 6,\n    dropTable: 7,\n    createTable: 8,\n    addColumn: 9,\n    alterColumn: 10,\n    renameTable: 11,\n    renameColumn: 12,\n    addPrimaryKey: 13,\n    addUniqueConstraint: 14,\n    createIndex: 15,\n    addForeignKey: 16,\n    alterEnum: 17,\n    dropEnum: 18,\n  };\n\n  return [...operations].sort((a, b) => priority[a.type] - priority[b.type]);\n}\n\n/**\n * Checks if any operations are destructive (could cause data loss)\n */\nexport function hasDestructiveOperations(operations: DiffOperation[]): boolean {\n  return operations.some(\n    (op) =>\n      op.type === \"dropTable\" ||\n      op.type === \"dropColumn\" ||\n      (op.type === \"alterColumn\" &&\n        // Type changes or making non-nullable are potentially destructive\n        (normalizeType(op.from.type) !== normalizeType(op.to.type) ||\n          (op.from.nullable && !op.to.nullable)))\n  );\n}\n\n/**\n * Gets a human-readable description of destructive operations\n */\nexport function getDestructiveOperationDescriptions(\n  operations: DiffOperation[]\n): string[] {\n  const descriptions: string[] = [];\n\n  for (const op of operations) {\n    if (op.type === \"dropTable\") {\n      descriptions.push(`Drop table \"${op.tableName}\" (all data will be lost)`);\n    } else if (op.type === \"dropColumn\") {\n      descriptions.push(\n        `Drop column \"${op.columnName}\" from table \"${op.tableName}\" (data will be lost)`\n      );\n    } else if (op.type === \"alterColumn\") {\n      if (normalizeType(op.from.type) !== normalizeType(op.to.type)) {\n        descriptions.push(\n          `Change type of \"${op.tableName}\".\"${op.columnName}\" from ${op.from.type} to ${op.to.type} (may cause data loss)`\n        );\n      }\n      if (op.from.nullable && !op.to.nullable) {\n        descriptions.push(\n          `Make \"${op.tableName}\".\"${op.columnName}\" NOT NULL (may fail if column contains NULL values)`\n        );\n      }\n    }\n  }\n\n  return descriptions;\n}\n","/**\n * Resolver System\n *\n * Handles ambiguous changes that require user input to resolve.\n * Provides utilities for converting user resolutions into concrete operations.\n */\n\nimport type {\n  AmbiguousChange,\n  ChangeResolution,\n  DiffOperation,\n  Resolver,\n} from \"./types\";\n\n// =============================================================================\n// RESOLUTION APPLICATION\n// =============================================================================\n\n/**\n * Converts resolved ambiguous changes into concrete diff operations\n */\nexport function applyResolutions(\n  changes: AmbiguousChange[],\n  resolutions: Map<AmbiguousChange, ChangeResolution>\n): DiffOperation[] {\n  const operations: DiffOperation[] = [];\n\n  for (const change of changes) {\n    const resolution = resolutions.get(change);\n    if (!resolution) {\n      // If no resolution provided, default to add+drop (safer)\n      if (change.type === \"ambiguousColumn\") {\n        operations.push(\n          {\n            type: \"dropColumn\",\n            tableName: change.tableName,\n            columnName: change.droppedColumn.name,\n          },\n          {\n            type: \"addColumn\",\n            tableName: change.tableName,\n            column: change.addedColumn,\n          }\n        );\n      } else if (change.type === \"ambiguousTable\") {\n        operations.push(\n          { type: \"dropTable\", tableName: change.droppedTable },\n          {\n            type: \"createTable\",\n            table: {\n              name: change.addedTable,\n              columns: [],\n              indexes: [],\n              foreignKeys: [],\n              uniqueConstraints: [],\n            },\n          }\n        );\n      }\n      continue;\n    }\n\n    if (change.type === \"ambiguousColumn\") {\n      if (resolution.type === \"rename\") {\n        operations.push({\n          type: \"renameColumn\",\n          tableName: change.tableName,\n          from: change.droppedColumn.name,\n          to: change.addedColumn.name,\n        });\n\n        // If the column properties differ (other than name), also alter it\n        if (\n          change.droppedColumn.nullable !== change.addedColumn.nullable ||\n          change.droppedColumn.default !== change.addedColumn.default\n        ) {\n          operations.push({\n            type: \"alterColumn\",\n            tableName: change.tableName,\n            columnName: change.addedColumn.name,\n            from: { ...change.droppedColumn, name: change.addedColumn.name },\n            to: change.addedColumn,\n          });\n        }\n      } else {\n        // addAndDrop\n        operations.push(\n          {\n            type: \"dropColumn\",\n            tableName: change.tableName,\n            columnName: change.droppedColumn.name,\n          },\n          {\n            type: \"addColumn\",\n            tableName: change.tableName,\n            column: change.addedColumn,\n          }\n        );\n      }\n    } else if (change.type === \"ambiguousTable\") {\n      if (resolution.type === \"rename\") {\n        operations.push({\n          type: \"renameTable\",\n          from: change.droppedTable,\n          to: change.addedTable,\n        });\n      } else {\n        // addAndDrop - the actual table definition will need to come from the desired schema\n        operations.push({ type: \"dropTable\", tableName: change.droppedTable });\n        // Note: The createTable operation should be added by the caller with full table definition\n      }\n    }\n  }\n\n  return operations;\n}\n\n// =============================================================================\n// DEFAULT RESOLVERS\n// =============================================================================\n\n/**\n * Resolver that always chooses \"rename\" for all ambiguous changes.\n * Useful for preserving data when the intent is clear.\n */\nexport const alwaysRenameResolver: Resolver = async (changes) => {\n  const resolutions = new Map<AmbiguousChange, ChangeResolution>();\n  for (const change of changes) {\n    resolutions.set(change, { type: \"rename\" });\n  }\n  return resolutions;\n};\n\n/**\n * Resolver that always chooses \"addAndDrop\" for all ambiguous changes.\n * Useful for clean slate scenarios where data loss is acceptable.\n */\nexport const alwaysAddDropResolver: Resolver = async (changes) => {\n  const resolutions = new Map<AmbiguousChange, ChangeResolution>();\n  for (const change of changes) {\n    resolutions.set(change, { type: \"addAndDrop\" });\n  }\n  return resolutions;\n};\n\n/**\n * Resolver that throws an error if any ambiguous changes are detected.\n * Useful for CI/CD pipelines where human intervention is not possible.\n */\nexport const strictResolver: Resolver = async (changes) => {\n  if (changes.length > 0) {\n    const descriptions = changes.map((change) => {\n      if (change.type === \"ambiguousColumn\") {\n        return `Column \"${change.droppedColumn.name}\" was removed and \"${change.addedColumn.name}\" was added in table \"${change.tableName}\"`;\n      }\n      return `Table \"${change.droppedTable}\" was removed and \"${change.addedTable}\" was added`;\n    });\n\n    throw new Error(\n      `Ambiguous changes detected that require resolution:\\n${descriptions.join(\"\\n\")}\\n\\n` +\n        \"Use a custom resolver or the CLI interactive mode to resolve these changes.\"\n    );\n  }\n  return new Map();\n};\n\n// =============================================================================\n// RESOLVER HELPERS\n// =============================================================================\n\n/**\n * Creates a resolver from a simple decision function\n */\nexport function createResolver(\n  decide: (\n    change: AmbiguousChange\n  ) => \"rename\" | \"addAndDrop\" | Promise<\"rename\" | \"addAndDrop\">\n): Resolver {\n  return async (changes) => {\n    const resolutions = new Map<AmbiguousChange, ChangeResolution>();\n    for (const change of changes) {\n      const decision = await decide(change);\n      resolutions.set(change, { type: decision });\n    }\n    return resolutions;\n  };\n}\n\n/**\n * Creates a resolver that uses predefined resolutions\n */\nexport function createPredefinedResolver(\n  predefined: Array<{\n    type: \"column\" | \"table\";\n    from: string;\n    to: string;\n    tableName?: string;\n    resolution: \"rename\" | \"addAndDrop\";\n  }>\n): Resolver {\n  return async (changes) => {\n    const resolutions = new Map<AmbiguousChange, ChangeResolution>();\n\n    for (const change of changes) {\n      const match = predefined.find((p) => {\n        if (change.type === \"ambiguousColumn\" && p.type === \"column\") {\n          return (\n            p.from === change.droppedColumn.name &&\n            p.to === change.addedColumn.name &&\n            (!p.tableName || p.tableName === change.tableName)\n          );\n        }\n        if (change.type === \"ambiguousTable\" && p.type === \"table\") {\n          return p.from === change.droppedTable && p.to === change.addedTable;\n        }\n        return false;\n      });\n\n      if (match) {\n        resolutions.set(change, { type: match.resolution });\n      }\n      // If no match found, the change will be handled by the default (add+drop)\n    }\n\n    return resolutions;\n  };\n}\n\n/**\n * Formats ambiguous changes for display\n */\nexport function formatAmbiguousChange(change: AmbiguousChange): string {\n  if (change.type === \"ambiguousColumn\") {\n    return (\n      `Column rename detected in table \"${change.tableName}\":\\n` +\n      `  \"${change.droppedColumn.name}\" (${change.droppedColumn.type}) → \"${change.addedColumn.name}\" (${change.addedColumn.type})`\n    );\n  }\n  return (\n    \"Table rename detected:\\n\" +\n    `  \"${change.droppedTable}\" → \"${change.addedTable}\"`\n  );\n}\n\n/**\n * Formats all ambiguous changes for display\n */\nexport function formatAmbiguousChanges(changes: AmbiguousChange[]): string {\n  if (changes.length === 0) {\n    return \"No ambiguous changes detected.\";\n  }\n\n  return changes.map(formatAmbiguousChange).join(\"\\n\\n\");\n}\n","/**\n * Model-to-SchemaSnapshot Serializer\n *\n * Converts VibORM model definitions into a database-agnostic SchemaSnapshot\n * that can be compared with the current database state.\n */\n\nimport type { Dialect } from \"../drivers/types\";\nimport type { Field } from \"../schema/fields/base\";\nimport type { FieldState } from \"../schema/fields/common\";\nimport type { AnyModel } from \"../schema/model\";\nimport type { AnyRelation } from \"../schema/relation\";\nimport type {\n  ColumnDef,\n  EnumDef,\n  ForeignKeyDef,\n  IndexDef,\n  PrimaryKeyDef,\n  ReferentialAction,\n  SchemaSnapshot,\n  TableDef,\n  UniqueConstraintDef,\n} from \"./types\";\n\n// =============================================================================\n// TYPE MAPPING\n// =============================================================================\n\n/**\n * Maps VibORM field types to PostgreSQL column types\n */\nfunction mapFieldTypeToPostgres(field: Field, fieldState: FieldState): string {\n  const nativeType = field[\"~\"].nativeType;\n\n  // If a native type is specified and it's for PostgreSQL, use it\n  if (nativeType && nativeType.db === \"pg\") {\n    return fieldState.array ? `${nativeType.type}[]` : nativeType.type;\n  }\n\n  // Default mappings based on field type\n  let baseType: string;\n  switch (fieldState.type) {\n    case \"string\":\n      baseType = \"text\";\n      break;\n    case \"int\":\n      baseType = fieldState.autoGenerate === \"increment\" ? \"serial\" : \"integer\";\n      break;\n    case \"float\":\n      baseType = \"double precision\";\n      break;\n    case \"decimal\":\n      baseType = \"numeric\";\n      break;\n    case \"boolean\":\n      baseType = \"boolean\";\n      break;\n    case \"datetime\":\n      baseType = \"timestamptz\";\n      break;\n    case \"date\":\n      baseType = \"date\";\n      break;\n    case \"time\":\n      baseType = \"time\";\n      break;\n    case \"bigint\":\n      baseType =\n        fieldState.autoGenerate === \"increment\" ? \"bigserial\" : \"bigint\";\n      break;\n    case \"json\":\n      baseType = \"jsonb\";\n      break;\n    case \"blob\":\n      baseType = \"bytea\";\n      break;\n    case \"vector\":\n      baseType = \"vector\";\n      break;\n    case \"point\":\n      baseType = \"point\";\n      break;\n    case \"enum\":\n      // Enum fields need special handling - we'll use the enum name\n      baseType = \"text\"; // Will be overridden by enum handling\n      break;\n    default:\n      baseType = \"text\";\n  }\n\n  return fieldState.array ? `${baseType}[]` : baseType;\n}\n\n/**\n * Maps VibORM field types to MySQL column types\n */\nfunction mapFieldTypeToMySQL(field: Field, fieldState: FieldState): string {\n  const nativeType = field[\"~\"].nativeType;\n\n  if (nativeType && nativeType.db === \"mysql\") {\n    // MySQL doesn't have native array types\n    return nativeType.type;\n  }\n\n  switch (fieldState.type) {\n    case \"string\":\n      return \"TEXT\";\n    case \"int\":\n      return fieldState.autoGenerate === \"increment\"\n        ? \"INT AUTO_INCREMENT\"\n        : \"INT\";\n    case \"float\":\n      return \"DOUBLE\";\n    case \"decimal\":\n      return \"DECIMAL(65,30)\";\n    case \"boolean\":\n      return \"TINYINT(1)\";\n    case \"datetime\":\n      return \"DATETIME(3)\";\n    case \"date\":\n      return \"DATE\";\n    case \"time\":\n      return \"TIME\";\n    case \"bigint\":\n      return fieldState.autoGenerate === \"increment\"\n        ? \"BIGINT AUTO_INCREMENT\"\n        : \"BIGINT\";\n    case \"json\":\n      return \"JSON\";\n    case \"blob\":\n      return \"LONGBLOB\";\n    case \"enum\":\n      return \"VARCHAR(255)\";\n    default:\n      return \"TEXT\";\n  }\n}\n\n/**\n * Maps VibORM field types to SQLite column types\n */\nfunction mapFieldTypeToSQLite(field: Field, fieldState: FieldState): string {\n  const nativeType = field[\"~\"].nativeType;\n\n  if (nativeType && nativeType.db === \"sqlite\") {\n    return nativeType.type;\n  }\n\n  switch (fieldState.type) {\n    case \"string\":\n    case \"enum\":\n    case \"json\":\n      return \"TEXT\";\n    case \"int\":\n    case \"bigint\":\n    case \"boolean\":\n      return \"INTEGER\";\n    case \"float\":\n    case \"decimal\":\n      return \"REAL\";\n    case \"datetime\":\n    case \"date\":\n    case \"time\":\n      return \"TEXT\";\n    case \"blob\":\n      return \"BLOB\";\n    default:\n      return \"TEXT\";\n  }\n}\n\n/**\n * Maps VibORM field type to SQL type based on dialect\n */\nexport function mapFieldType(\n  field: Field,\n  fieldState: FieldState,\n  dialect: Dialect\n): string {\n  switch (dialect) {\n    case \"postgresql\":\n      return mapFieldTypeToPostgres(field, fieldState);\n    case \"mysql\":\n      return mapFieldTypeToMySQL(field, fieldState);\n    case \"sqlite\":\n      return mapFieldTypeToSQLite(field, fieldState);\n    default:\n      return mapFieldTypeToPostgres(field, fieldState);\n  }\n}\n\n// =============================================================================\n// DEFAULT VALUE HANDLING\n// =============================================================================\n\n/**\n * Converts a VibORM default value to a SQL default expression\n */\nfunction getDefaultExpression(\n  fieldState: FieldState,\n  dialect: Dialect\n): string | undefined {\n  // Handle auto-generate types\n  if (fieldState.autoGenerate) {\n    switch (fieldState.autoGenerate) {\n      case \"increment\":\n        // Handled by column type (serial/bigserial in PG, AUTO_INCREMENT in MySQL)\n        return undefined;\n      case \"uuid\":\n        if (dialect === \"postgresql\") return \"gen_random_uuid()\";\n        return undefined; // Generated in application\n      case \"now\":\n        if (dialect === \"postgresql\") return \"now()\";\n        if (dialect === \"mysql\") return \"CURRENT_TIMESTAMP\";\n        return \"CURRENT_TIMESTAMP\";\n      case \"updatedAt\":\n        // This is typically handled via triggers or application logic\n        return undefined;\n      case \"ulid\":\n      case \"nanoid\":\n      case \"cuid\":\n        // These are generated in the application\n        return undefined;\n    }\n  }\n\n  // Handle explicit default value\n  if (fieldState.hasDefault && fieldState.default !== undefined) {\n    const defaultVal = fieldState.default;\n\n    // Skip function defaults (generated at runtime)\n    if (typeof defaultVal === \"function\") {\n      return undefined;\n    }\n\n    // Handle null default\n    if (defaultVal === null) {\n      return \"NULL\";\n    }\n\n    // Handle primitive defaults\n    if (typeof defaultVal === \"string\") {\n      return `'${defaultVal.replace(/'/g, \"''\")}'`;\n    }\n    if (typeof defaultVal === \"number\") {\n      return String(defaultVal);\n    }\n    if (typeof defaultVal === \"boolean\") {\n      if (dialect === \"postgresql\") return defaultVal ? \"true\" : \"false\";\n      if (dialect === \"mysql\") return defaultVal ? \"1\" : \"0\";\n      return defaultVal ? \"1\" : \"0\";\n    }\n  }\n\n  return undefined;\n}\n\n// =============================================================================\n// REFERENTIAL ACTION MAPPING\n// =============================================================================\n\nfunction mapReferentialAction(\n  action: \"cascade\" | \"setNull\" | \"restrict\" | \"noAction\" | undefined\n): ReferentialAction {\n  switch (action) {\n    case \"cascade\":\n      return \"cascade\";\n    case \"setNull\":\n      return \"setNull\";\n    case \"restrict\":\n      return \"restrict\";\n    case \"noAction\":\n    default:\n      return \"noAction\";\n  }\n}\n\n// =============================================================================\n// SERIALIZER\n// =============================================================================\n\nexport interface SerializeOptions {\n  dialect: Dialect;\n}\n\n/**\n * Serializes a collection of VibORM models into a SchemaSnapshot\n */\nexport function serializeModels(\n  models: Record<string, AnyModel>,\n  options: SerializeOptions\n): SchemaSnapshot {\n  const { dialect } = options;\n  const tables: TableDef[] = [];\n  const enums: EnumDef[] = [];\n  const enumsSet = new Set<string>();\n\n  for (const [modelName, model] of Object.entries(models)) {\n    const modelState = model[\"~\"].state;\n    const tableName =\n      model[\"~\"].names.sql || modelState.tableName || modelName.toLowerCase();\n\n    const columns: ColumnDef[] = [];\n    const indexes: IndexDef[] = [];\n    const foreignKeys: ForeignKeyDef[] = [];\n    const uniqueConstraints: UniqueConstraintDef[] = [];\n    let primaryKey: PrimaryKeyDef | undefined;\n    const pkColumns: string[] = [];\n\n    // Process scalar fields\n    for (const [fieldName, field] of Object.entries(modelState.scalars)) {\n      const fieldState = (field as Field)[\"~\"].state;\n      // Use model's nameRegistry for column name resolution (supports field reuse)\n      const columnName = model[\"~\"].getFieldName(fieldName).sql;\n\n      // Handle enum types for PostgreSQL\n      if (fieldState.type === \"enum\" && dialect === \"postgresql\") {\n        const enumField = field as any;\n        if (enumField.values && Array.isArray(enumField.values)) {\n          const enumName = `${tableName}_${columnName}_enum`;\n          if (!enumsSet.has(enumName)) {\n            enums.push({\n              name: enumName,\n              values: enumField.values,\n            });\n            enumsSet.add(enumName);\n          }\n        }\n      }\n\n      const columnDef: ColumnDef = {\n        name: columnName,\n        type:\n          fieldState.type === \"enum\" && dialect === \"postgresql\"\n            ? `${tableName}_${columnName}_enum`\n            : mapFieldType(field as Field, fieldState, dialect),\n        nullable: fieldState.nullable,\n        default: getDefaultExpression(fieldState, dialect),\n        autoIncrement: fieldState.autoGenerate === \"increment\",\n      };\n\n      columns.push(columnDef);\n\n      // Track primary key columns\n      if (fieldState.isId) {\n        pkColumns.push(columnName);\n      }\n\n      // Handle unique constraints on individual fields\n      if (fieldState.isUnique && !fieldState.isId) {\n        uniqueConstraints.push({\n          name: `${tableName}_${columnName}_key`,\n          columns: [columnName],\n        });\n      }\n    }\n\n    // Handle compound primary key\n    if (modelState.compoundId) {\n      const compoundIdKeys = Object.keys(modelState.compoundId);\n      if (compoundIdKeys.length > 0) {\n        // The compound ID name contains the field names\n        const firstKey = compoundIdKeys[0]!;\n        // Extract field names from the compound ID schema\n        const compoundIdSchema = modelState.compoundId[firstKey];\n        if (compoundIdSchema && compoundIdSchema[\"~\"]) {\n          const schemaState = compoundIdSchema[\"~\"];\n          if (schemaState.def && typeof schemaState.def === \"object\") {\n            pkColumns.push(...Object.keys(schemaState.def));\n          }\n        }\n      }\n    }\n\n    // Set primary key\n    if (pkColumns.length > 0) {\n      primaryKey = {\n        columns: pkColumns,\n        name: `${tableName}_pkey`,\n      };\n    }\n\n    // Handle compound unique constraints\n    if (modelState.compoundUniques) {\n      for (const [constraintName, schema] of Object.entries(\n        modelState.compoundUniques\n      )) {\n        if (schema && schema[\"~\"]) {\n          const schemaState = schema[\"~\"];\n          if (schemaState.def && typeof schemaState.def === \"object\") {\n            uniqueConstraints.push({\n              name: `${tableName}_${constraintName}_key`,\n              columns: Object.keys(schemaState.def),\n            });\n          }\n        }\n      }\n    }\n\n    // Process indexes from model state\n    for (const indexDef of modelState.indexes) {\n      const indexName =\n        indexDef.options.name ||\n        `${tableName}_${indexDef.fields.join(\"_\")}_idx`;\n      indexes.push({\n        name: indexName,\n        columns: indexDef.fields,\n        unique: indexDef.options.unique,\n        type: indexDef.options.type,\n        where: indexDef.options.where,\n      });\n    }\n\n    // Process relations to generate foreign keys\n    for (const [relationName, relation] of Object.entries(\n      modelState.relations\n    )) {\n      const relationState = (relation as AnyRelation)[\"~\"].state;\n\n      // Only process manyToOne and oneToOne relations that define foreign keys\n      if (\n        (relationState.type === \"manyToOne\" ||\n          relationState.type === \"oneToOne\") &&\n        relationState.fields &&\n        relationState.references\n      ) {\n        // Get the target model\n        const targetModel = relationState.getter();\n        if (targetModel && targetModel[\"~\"]) {\n          const targetModelState = targetModel[\"~\"].state;\n          const targetTableName =\n            targetModel[\"~\"].names.sql ||\n            targetModelState.tableName ||\n            relationName.toLowerCase();\n\n          foreignKeys.push({\n            name: `${tableName}_${relationState.fields.join(\"_\")}_fkey`,\n            columns: relationState.fields,\n            referencedTable: targetTableName,\n            referencedColumns: relationState.references,\n            onDelete: mapReferentialAction(relationState.onDelete),\n            onUpdate: mapReferentialAction(relationState.onUpdate),\n          });\n        }\n      }\n    }\n\n    tables.push({\n      name: tableName,\n      columns,\n      primaryKey,\n      indexes,\n      foreignKeys,\n      uniqueConstraints,\n    });\n  }\n\n  return {\n    tables,\n    enums: enums.length > 0 ? enums : undefined,\n  };\n}\n\n/**\n * Gets the SQL column name for a field using the model's nameRegistry.\n * This supports field reuse across multiple models.\n *\n * @param model - The model containing the field\n * @param fieldName - The field key in the schema\n * @returns The SQL column name\n */\nexport function getColumnName(model: AnyModel, fieldName: string): string {\n  return model[\"~\"].getFieldName(fieldName).sql;\n}\n\n/**\n * Gets the SQL table name for a model\n */\nexport function getTableName(model: AnyModel, modelName: string): string {\n  return (\n    model[\"~\"].names.sql ||\n    model[\"~\"].state.tableName ||\n    modelName.toLowerCase()\n  );\n}\n","// =============================================================================\n// SCHEMA SNAPSHOT (database-agnostic representation)\n// =============================================================================\n\nexport interface SchemaSnapshot {\n  tables: TableDef[];\n  enums?: EnumDef[] | undefined;\n}\n\nexport interface TableDef {\n  name: string;\n  columns: ColumnDef[];\n  primaryKey?: PrimaryKeyDef | undefined;\n  indexes: IndexDef[];\n  foreignKeys: ForeignKeyDef[];\n  uniqueConstraints: UniqueConstraintDef[];\n}\n\nexport interface ColumnDef {\n  name: string;\n  type: string; // Normalized type (e.g., \"varchar(255)\", \"integer\", \"boolean\")\n  nullable: boolean;\n  default?: string | undefined; // SQL expression for default value\n  autoIncrement?: boolean | undefined;\n}\n\nexport interface PrimaryKeyDef {\n  columns: string[];\n  name?: string | undefined;\n}\n\nexport interface IndexDef {\n  name: string;\n  columns: string[];\n  unique: boolean;\n  type?: \"btree\" | \"hash\" | \"gin\" | \"gist\" | undefined;\n  where?: string | undefined; // For partial indexes\n}\n\nexport interface ForeignKeyDef {\n  name: string;\n  columns: string[];\n  referencedTable: string;\n  referencedColumns: string[];\n  onDelete?: ReferentialAction | undefined;\n  onUpdate?: ReferentialAction | undefined;\n}\n\nexport type ReferentialAction =\n  | \"cascade\"\n  | \"setNull\"\n  | \"restrict\"\n  | \"noAction\"\n  | \"setDefault\";\n\nexport interface UniqueConstraintDef {\n  name: string;\n  columns: string[];\n}\n\nexport interface EnumDef {\n  name: string;\n  values: string[];\n}\n\n// =============================================================================\n// DIFF OPERATIONS (resolved, ready to execute)\n// =============================================================================\n\nexport type DiffOperation =\n  | { type: \"createTable\"; table: TableDef }\n  | { type: \"dropTable\"; tableName: string }\n  | { type: \"renameTable\"; from: string; to: string }\n  | { type: \"addColumn\"; tableName: string; column: ColumnDef }\n  | { type: \"dropColumn\"; tableName: string; columnName: string }\n  | { type: \"renameColumn\"; tableName: string; from: string; to: string }\n  | {\n      type: \"alterColumn\";\n      tableName: string;\n      columnName: string;\n      from: ColumnDef;\n      to: ColumnDef;\n    }\n  | { type: \"createIndex\"; tableName: string; index: IndexDef }\n  | { type: \"dropIndex\"; indexName: string }\n  | { type: \"addForeignKey\"; tableName: string; fk: ForeignKeyDef }\n  | { type: \"dropForeignKey\"; tableName: string; fkName: string }\n  | {\n      type: \"addUniqueConstraint\";\n      tableName: string;\n      constraint: UniqueConstraintDef;\n    }\n  | { type: \"dropUniqueConstraint\"; tableName: string; constraintName: string }\n  | { type: \"addPrimaryKey\"; tableName: string; primaryKey: PrimaryKeyDef }\n  | { type: \"dropPrimaryKey\"; tableName: string; constraintName: string }\n  | { type: \"createEnum\"; enumDef: EnumDef }\n  | { type: \"dropEnum\"; enumName: string }\n  | {\n      type: \"alterEnum\";\n      enumName: string;\n      addValues?: string[] | undefined;\n      removeValues?: string[] | undefined;\n    };\n\n// =============================================================================\n// AMBIGUOUS CHANGES (require user input to resolve)\n// =============================================================================\n\n/** Detected when columns are added AND dropped in the same table */\nexport type AmbiguousColumnChange = {\n  type: \"ambiguousColumn\";\n  tableName: string;\n  droppedColumn: ColumnDef;\n  addedColumn: ColumnDef;\n};\n\n/** Detected when tables are added AND dropped */\nexport type AmbiguousTableChange = {\n  type: \"ambiguousTable\";\n  droppedTable: string;\n  addedTable: string;\n};\n\nexport type AmbiguousChange = AmbiguousColumnChange | AmbiguousTableChange;\n\n/** User's resolution for an ambiguous change */\nexport type ChangeResolution =\n  | { type: \"rename\" } // Treat as rename (preserve data)\n  | { type: \"addAndDrop\" }; // Treat as separate add + drop (data loss)\n\n// =============================================================================\n// DIFF RESULT (output of differ, before resolution)\n// =============================================================================\n\nexport interface DiffResult {\n  /** Operations that are unambiguous and ready to execute */\n  operations: DiffOperation[];\n  /** Changes that need user input to resolve */\n  ambiguousChanges: AmbiguousChange[];\n}\n\n// =============================================================================\n// RESOLVER (handles ambiguous changes)\n// =============================================================================\n\n/** Callback to resolve ambiguous changes (used by CLI or programmatic API) */\nexport type Resolver = (\n  changes: AmbiguousChange[]\n) => Promise<Map<AmbiguousChange, ChangeResolution>>;\n\n// =============================================================================\n// PUSH RESULT\n// =============================================================================\n\nexport interface PushResult {\n  /** All operations that were applied (or would be applied in dry-run) */\n  operations: DiffOperation[];\n  /** Whether the operations were actually applied to the database */\n  applied: boolean;\n  /** Generated SQL statements */\n  sql: string[];\n}\n\n// =============================================================================\n// MIGRATION ERROR\n// =============================================================================\n\nexport class MigrationError extends Error {\n  constructor(\n    message: string,\n    public readonly code?: string\n  ) {\n    super(message);\n    this.name = \"MigrationError\";\n  }\n}\n","/**\n * Push Workflow\n *\n * Orchestrates the database schema push operation:\n * 1. Serialize VibORM models to SchemaSnapshot\n * 2. Introspect current database state\n * 3. Calculate diff\n * 4. Resolve ambiguous changes\n * 5. Generate and execute DDL\n */\n\nimport type { DatabaseAdapter } from \"../adapters/database-adapter\";\nimport type { Driver } from \"../drivers/driver\";\nimport type { AnyModel } from \"../schema/model\";\nimport {\n  diff,\n  getDestructiveOperationDescriptions,\n  hasDestructiveOperations,\n} from \"./differ\";\nimport { applyResolutions, strictResolver } from \"./resolver\";\nimport { serializeModels } from \"./serializer\";\nimport {\n  type DiffOperation,\n  MigrationError,\n  type PushResult,\n  type Resolver,\n  type SchemaSnapshot,\n} from \"./types\";\n\n// =============================================================================\n// ADAPTER REGISTRY\n// =============================================================================\n\nimport { postgresAdapter } from \"../adapters/databases/postgres/postgres-adapter\";\n\nfunction getAdapterForDialect(dialect: string): DatabaseAdapter {\n  switch (dialect) {\n    case \"postgresql\":\n      return postgresAdapter;\n    // TODO: Add mysql and sqlite adapters when migrations are implemented\n    default:\n      throw new MigrationError(\n        `Migrations not yet supported for dialect: ${dialect}`,\n        \"UNSUPPORTED_DIALECT\"\n      );\n  }\n}\n\n// =============================================================================\n// PUSH OPTIONS\n// =============================================================================\n\nexport interface PushOptions {\n  /** Skip confirmations for destructive changes */\n  force?: boolean;\n  /** Preview SQL without executing */\n  dryRun?: boolean;\n  /** Custom resolver for ambiguous changes (defaults to strictResolver) */\n  resolver?: Resolver;\n  /** Called when destructive operations are detected (for CLI confirmation) */\n  onDestructive?: (descriptions: string[]) => Promise<boolean>;\n}\n\n// =============================================================================\n// PUSH FUNCTION\n// =============================================================================\n\n/**\n * Pushes schema changes directly to the database.\n *\n * @param driver - Database driver for executing queries\n * @param models - Record of model name to model definition\n * @param options - Push options\n * @returns Push result with operations and SQL statements\n */\nexport async function push(\n  driver: Driver,\n  models: Record<string, AnyModel>,\n  options: PushOptions = {}\n): Promise<PushResult> {\n  const { force = false, dryRun = false, resolver = strictResolver } = options;\n\n  // Get the adapter for this database dialect\n  const adapter = getAdapterForDialect(driver.dialect);\n\n  // 1. Serialize VibORM models to SchemaSnapshot\n  const desired = serializeModels(models, { dialect: driver.dialect });\n\n  // 2. Introspect current database state\n  const current = await adapter.migrations.introspect(async (sql, params) => {\n    const result = await driver.executeRaw<any>(sql, params);\n    return result;\n  });\n\n  // 3. Calculate diff\n  const diffResult = diff(current, desired);\n\n  // 4. Resolve ambiguous changes\n  let finalOperations = [...diffResult.operations];\n\n  if (diffResult.ambiguousChanges.length > 0) {\n    const resolutions = await resolver(diffResult.ambiguousChanges);\n    const resolvedOps = applyResolutions(\n      diffResult.ambiguousChanges,\n      resolutions\n    );\n    finalOperations.push(...resolvedOps);\n\n    // For table renames that were resolved as addAndDrop, we need to add the createTable\n    for (const change of diffResult.ambiguousChanges) {\n      if (change.type === \"ambiguousTable\") {\n        const resolution = resolutions.get(change);\n        if (resolution?.type === \"addAndDrop\") {\n          // Find the table definition from desired schema\n          const newTable = desired.tables.find(\n            (t) => t.name === change.addedTable\n          );\n          if (newTable) {\n            finalOperations.push({ type: \"createTable\", table: newTable });\n          }\n        }\n      }\n    }\n\n    // Re-sort operations after adding resolved ones\n    finalOperations = sortOperations(finalOperations);\n  }\n\n  // 5. Check for destructive operations\n  if (hasDestructiveOperations(finalOperations) && !force) {\n    const descriptions = getDestructiveOperationDescriptions(finalOperations);\n\n    if (options.onDestructive) {\n      const confirmed = await options.onDestructive(descriptions);\n      if (!confirmed) {\n        throw new MigrationError(\n          \"Destructive changes were not confirmed\",\n          \"DESTRUCTIVE_CHANGES_REJECTED\"\n        );\n      }\n    } else {\n      throw new MigrationError(\n        `Destructive changes detected:\\n${descriptions.join(\"\\n\")}\\n\\n` +\n          \"Use --force to proceed or provide an onDestructive callback.\",\n        \"DESTRUCTIVE_CHANGES\"\n      );\n    }\n  }\n\n  // 6. Generate DDL statements\n  const sql: string[] = [];\n  for (const op of finalOperations) {\n    const ddl = adapter.migrations.generateDDL(op);\n    // generateDDL may return multiple statements separated by ;\\n\n    const statements = ddl.split(\";\\n\").filter((s) => s.trim());\n    sql.push(...statements);\n  }\n\n  // 7. Execute DDL (unless dry run)\n  if (!dryRun && sql.length > 0) {\n    // Execute in a transaction for atomicity\n    await driver.transaction(async (tx) => {\n      for (const statement of sql) {\n        await tx.executeRaw(statement + \";\");\n      }\n    });\n  }\n\n  return {\n    operations: finalOperations,\n    applied: !dryRun && sql.length > 0,\n    sql,\n  };\n}\n\n// =============================================================================\n// HELPERS\n// =============================================================================\n\n/**\n * Sort operations for proper execution order\n */\nfunction sortOperations(operations: DiffOperation[]): DiffOperation[] {\n  const priority: Record<DiffOperation[\"type\"], number> = {\n    createEnum: 1,\n    dropForeignKey: 2,\n    dropIndex: 3,\n    dropUniqueConstraint: 4,\n    dropPrimaryKey: 5,\n    dropColumn: 6,\n    dropTable: 7,\n    createTable: 8,\n    addColumn: 9,\n    alterColumn: 10,\n    renameTable: 11,\n    renameColumn: 12,\n    addPrimaryKey: 13,\n    addUniqueConstraint: 14,\n    createIndex: 15,\n    addForeignKey: 16,\n    alterEnum: 17,\n    dropEnum: 18,\n  };\n\n  return [...operations].sort((a, b) => priority[a.type] - priority[b.type]);\n}\n\n/**\n * Introspects the current database schema without making any changes.\n * Useful for debugging or displaying current state.\n */\nexport async function introspect(driver: Driver): Promise<SchemaSnapshot> {\n  const adapter = getAdapterForDialect(driver.dialect);\n  return adapter.migrations.introspect(async (sql, params) => {\n    const result = await driver.executeRaw<any>(sql, params);\n    return result;\n  });\n}\n\n/**\n * Generates DDL statements for transforming current schema to desired schema\n * without executing them. Useful for generating migration files.\n */\nexport async function generateDDL(\n  driver: Driver,\n  models: Record<string, AnyModel>,\n  options: { resolver?: Resolver } = {}\n): Promise<{ operations: DiffOperation[]; sql: string[] }> {\n  const result = await push(driver, models, {\n    ...options,\n    dryRun: true,\n    force: true,\n  });\n\n  return {\n    operations: result.operations,\n    sql: result.sql,\n  };\n}\n\n/**\n * Formats an operation for human-readable display\n */\nexport function formatOperation(op: DiffOperation): string {\n  switch (op.type) {\n    case \"createTable\":\n      return `+ Create table \"${op.table.name}\" with ${op.table.columns.length} columns`;\n    case \"dropTable\":\n      return `- Drop table \"${op.tableName}\"`;\n    case \"renameTable\":\n      return `~ Rename table \"${op.from}\" → \"${op.to}\"`;\n    case \"addColumn\":\n      return `+ Add column \"${op.column.name}\" (${op.column.type}) to \"${op.tableName}\"`;\n    case \"dropColumn\":\n      return `- Drop column \"${op.columnName}\" from \"${op.tableName}\"`;\n    case \"renameColumn\":\n      return `~ Rename column \"${op.from}\" → \"${op.to}\" in \"${op.tableName}\"`;\n    case \"alterColumn\":\n      return `~ Alter column \"${op.columnName}\" in \"${op.tableName}\"`;\n    case \"createIndex\":\n      return `+ Create index \"${op.index.name}\" on \"${op.tableName}\"`;\n    case \"dropIndex\":\n      return `- Drop index \"${op.indexName}\"`;\n    case \"addForeignKey\":\n      return `+ Add foreign key \"${op.fk.name}\" to \"${op.tableName}\"`;\n    case \"dropForeignKey\":\n      return `- Drop foreign key \"${op.fkName}\" from \"${op.tableName}\"`;\n    case \"addUniqueConstraint\":\n      return `+ Add unique constraint \"${op.constraint.name}\" to \"${op.tableName}\"`;\n    case \"dropUniqueConstraint\":\n      return `- Drop unique constraint \"${op.constraintName}\" from \"${op.tableName}\"`;\n    case \"addPrimaryKey\":\n      return `+ Add primary key to \"${op.tableName}\"`;\n    case \"dropPrimaryKey\":\n      return `- Drop primary key \"${op.constraintName}\" from \"${op.tableName}\"`;\n    case \"createEnum\":\n      return `+ Create enum \"${op.enumDef.name}\" with values [${op.enumDef.values.join(\", \")}]`;\n    case \"dropEnum\":\n      return `- Drop enum \"${op.enumName}\"`;\n    case \"alterEnum\": {\n      const parts: string[] = [];\n      if (op.addValues?.length) parts.push(`add: ${op.addValues.join(\", \")}`);\n      if (op.removeValues?.length)\n        parts.push(`remove: ${op.removeValues.join(\", \")}`);\n      return `~ Alter enum \"${op.enumName}\" (${parts.join(\"; \")})`;\n    }\n    default:\n      return `Unknown operation: ${(op as any).type}`;\n  }\n}\n\n/**\n * Formats all operations for human-readable display\n */\nexport function formatOperations(operations: DiffOperation[]): string {\n  if (operations.length === 0) {\n    return \"No changes detected.\";\n  }\n\n  return operations.map(formatOperation).join(\"\\n\");\n}\n"],"mappings":"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"}