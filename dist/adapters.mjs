import{t as e}from"./sql-CFtZ-oR0.mjs";import{n as t,t as n}from"./postgres-adapter-CzPH7ypE.mjs";import{d as r,u as i}from"./errors-_kgrybP9.mjs";const a=()=>{throw Error(`MySQL migrations are not yet implemented. Please use PostgreSQL.`)},o={introspect:async()=>a(),generateDDL:e=>a(),mapFieldType:e=>a()};var s=class{constructor(){this.raw=t=>e.raw`${t}`,this.identifiers={escape:t=>e.raw`\`${t}\``,column:(t,n)=>t?e.raw`\`${t}\`.\`${n}\``:e.raw`\`${n}\``,table:(t,n)=>e.raw`\`${t}\` AS \`${n}\``,aliased:(t,n)=>e`${t} AS ${e.raw`\`${n}\``}`},this.literals={value:t=>e`${t}`,null:()=>e.raw`NULL`,true:()=>e.raw`TRUE`,false:()=>e.raw`FALSE`,list:t=>t.length===0?e.raw`()`:e`(${e.join(t,`, `)})`,json:t=>e`${JSON.stringify(t)}`},this.operators={eq:(t,n)=>e`${t} = ${n}`,neq:(t,n)=>e`${t} <> ${n}`,lt:(t,n)=>e`${t} < ${n}`,lte:(t,n)=>e`${t} <= ${n}`,gt:(t,n)=>e`${t} > ${n}`,gte:(t,n)=>e`${t} >= ${n}`,like:(t,n)=>e`${t} LIKE ${n}`,notLike:(t,n)=>e`${t} NOT LIKE ${n}`,ilike:(t,n)=>e`${t} LIKE ${n} COLLATE utf8mb4_unicode_ci`,notIlike:(t,n)=>e`${t} NOT LIKE ${n} COLLATE utf8mb4_unicode_ci`,in:(t,n)=>e`${t} IN ${n}`,notIn:(t,n)=>e`${t} NOT IN ${n}`,isNull:t=>e`${t} IS NULL`,isNotNull:t=>e`${t} IS NOT NULL`,between:(t,n,r)=>e`${t} BETWEEN ${n} AND ${r}`,notBetween:(t,n,r)=>e`${t} NOT BETWEEN ${n} AND ${r}`,and:(...t)=>t.length===0?e.raw`TRUE`:t.length===1?t[0]:e`(${e.join(t,` AND `)})`,or:(...t)=>t.length===0?e.raw`FALSE`:t.length===1?t[0]:e`(${e.join(t,` OR `)})`,not:t=>e`NOT (${t})`,exists:t=>e`EXISTS (${t})`,notExists:t=>e`NOT EXISTS (${t})`},this.expressions={add:(t,n)=>e`(${t} + ${n})`,subtract:(t,n)=>e`(${t} - ${n})`,multiply:(t,n)=>e`(${t} * ${n})`,divide:(t,n)=>e`(${t} / ${n})`,concat:(...t)=>t.length===0?e.raw`''`:t.length===1?t[0]:e`CONCAT(${e.join(t,`, `)})`,upper:t=>e`UPPER(${t})`,lower:t=>e`LOWER(${t})`,coalesce:(...t)=>e`COALESCE(${e.join(t,`, `)})`,greatest:(...t)=>e`GREATEST(${e.join(t,`, `)})`,least:(...t)=>e`LEAST(${e.join(t,`, `)})`,cast:(t,n)=>e`CAST(${t} AS ${e.raw`${n}`})`},this.aggregates={count:t=>t?e`COUNT(${t})`:e.raw`COUNT(*)`,countDistinct:t=>e`COUNT(DISTINCT ${t})`,sum:t=>e`SUM(${t})`,avg:t=>e`AVG(${t})`,min:t=>e`MIN(${t})`,max:t=>e`MAX(${t})`},this.json={object:t=>{if(t.length===0)return e.raw`JSON_OBJECT()`;let n=t.flatMap(([t,n])=>[e`${t}`,n]);return e`JSON_OBJECT(${e.join(n,`, `)})`},array:t=>t.length===0?e.raw`JSON_ARRAY()`:e`JSON_ARRAY(${e.join(t,`, `)})`,emptyArray:()=>e.raw`JSON_ARRAY()`,agg:t=>e`COALESCE(JSON_ARRAYAGG(${t}), JSON_ARRAY())`,rowToJson:t=>e`JSON_OBJECT(${e.raw`'*', \`${t}\`.*`})`,objectFromColumns:t=>{if(t.length===0)return e.raw`JSON_OBJECT()`;let n=t.flatMap(([t,n])=>[e`${t}`,n]);return e`JSON_OBJECT(${e.join(n,`, `)})`},extract:(t,n)=>n.length===0?t:e`JSON_EXTRACT(${t}, ${`$.`+n.join(`.`)})`,extractText:(t,n)=>n.length===0?t:e`JSON_UNQUOTE(JSON_EXTRACT(${t}, ${`$.`+n.join(`.`)}))`},this.arrays={literal:t=>t.length===0?e.raw`JSON_ARRAY()`:e`JSON_ARRAY(${e.join(t,`, `)})`,has:(t,n)=>e`JSON_CONTAINS(${t}, ${n})`,hasEvery:(t,n)=>e`JSON_CONTAINS(${t}, ${n})`,hasSome:(t,n)=>e`JSON_OVERLAPS(${t}, ${n})`,isEmpty:t=>e`(JSON_LENGTH(${t}) = 0 OR ${t} IS NULL)`,length:t=>e`JSON_LENGTH(${t})`,get:(t,n)=>e`JSON_EXTRACT(${t}, CONCAT('$[', ${n}, ']'))`,push:(t,n)=>e`JSON_ARRAY_APPEND(${t}, '$', ${n})`,set:(t,n,r)=>e`JSON_SET(${t}, CONCAT('$[', ${n}, ']'), ${r})`},this.orderBy={asc:t=>e`${t} ASC`,desc:t=>e`${t} DESC`,nullsFirst:e=>e,nullsLast:e=>e},this.clauses={select:t=>e`SELECT ${t}`,selectDistinct:t=>e`SELECT DISTINCT ${t}`,from:t=>e`FROM ${t}`,where:t=>e`WHERE ${t}`,orderBy:t=>e`ORDER BY ${t}`,limit:t=>e`LIMIT ${t}`,offset:t=>e`OFFSET ${t}`,groupBy:t=>e`GROUP BY ${t}`,having:t=>e`HAVING ${t}`},this.set={assign:(t,n)=>e`${t} = ${n}`,increment:(t,n)=>e`${t} = ${t} + ${n}`,decrement:(t,n)=>e`${t} = ${t} - ${n}`,multiply:(t,n)=>e`${t} = ${t} * ${n}`,divide:(t,n)=>e`${t} = ${t} / ${n}`,push:(t,n)=>e`${t} = JSON_ARRAY_APPEND(${t}, '$', ${n})`,unshift:(t,n)=>e`${t} = JSON_ARRAY_INSERT(${t}, '$[0]', ${n})`},this.filters={some:t=>e`EXISTS (${t})`,every:t=>e`NOT EXISTS (${t})`,none:t=>e`NOT EXISTS (${t})`,is:t=>e`EXISTS (${t})`,isNot:t=>e`NOT EXISTS (${t})`},this.subqueries={scalar:t=>e`(${t})`,correlate:(t,n)=>e`(${t}) AS ${e.raw`\`${n}\``}`,existsCheck:(t,n)=>e`SELECT 1 FROM ${t} WHERE ${n}`},this.assemble={select:t=>{if(t.distinct)return this.assembleDistinctOn(t);let n=[e`SELECT ${t.columns}`,e`FROM ${t.from}`];return t.joins&&t.joins.length>0&&n.push(...t.joins),t.where&&n.push(e`WHERE ${t.where}`),t.groupBy&&n.push(e`GROUP BY ${t.groupBy}`),t.having&&n.push(e`HAVING ${t.having}`),t.orderBy&&n.push(e`ORDER BY ${t.orderBy}`),t.limit&&n.push(e`LIMIT ${t.limit}`),t.offset&&n.push(e`OFFSET ${t.offset}`),e.join(n,` `)}},this.cte={with:t=>{let n=t.map(({name:t,query:n})=>e`${e.raw`\`${t}\``} AS (${n})`);return e`WITH ${e.join(n,`, `)}`},recursive:(t,n,r,i=`all`)=>{let a=i===`all`?e.raw`UNION ALL`:e.raw`UNION`;return e`WITH RECURSIVE ${e.raw`\`${t}\``} AS (
        ${n}
        ${a}
        ${r}
      )`}},this.mutations={insert:(t,n,r)=>{let i=n.map(t=>e.raw`\`${t}\``),a=r.map(t=>e`(${e.join(t,`, `)})`);return e`INSERT INTO ${t} (${e.join(i,`, `)}) VALUES ${e.join(a,`, `)}`},update:(t,n,r)=>r?e`UPDATE ${t} SET ${n} WHERE ${r}`:e`UPDATE ${t} SET ${n}`,delete:(t,n)=>n?e`DELETE FROM ${t} WHERE ${n}`:e`DELETE FROM ${t}`,returning:t=>e.empty,onConflict:(t,n)=>e`ON DUPLICATE KEY UPDATE ${n}`},this.joins={inner:(t,n)=>e`INNER JOIN ${t} ON ${n}`,left:(t,n)=>e`LEFT JOIN ${t} ON ${n}`,right:(t,n)=>e`RIGHT JOIN ${t} ON ${n}`,full:(t,n)=>e`LEFT JOIN ${t} ON ${n}`,cross:t=>e`CROSS JOIN ${t}`},this.setOperations={union:(...t)=>e.join(t,` UNION `),unionAll:(...t)=>e.join(t,` UNION ALL `),intersect:(...t)=>e.join(t,` INTERSECT `),except:(t,n)=>e`${t} EXCEPT ${n}`},this.capabilities={supportsReturning:!1,supportsCteWithMutations:!1,supportsFullOuterJoin:!1},this.lastInsertId=()=>e.raw`LAST_INSERT_ID()`,this.migrations=o,this.vector=r,this.geospatial=i}assembleDistinctOn(t){let n=t.orderBy||t.distinct,r=[e`SELECT ${t.columns}, ROW_NUMBER() OVER (PARTITION BY ${t.distinct} ORDER BY ${n}) AS \`_rn\``,e`FROM ${t.from}`];t.joins&&t.joins.length>0&&r.push(...t.joins),t.where&&r.push(e`WHERE ${t.where}`),t.groupBy&&r.push(e`GROUP BY ${t.groupBy}`),t.having&&r.push(e`HAVING ${t.having}`);let i=e.join(r,` `),a;if(t.distinctColumnAliases&&t.distinctColumnAliases.length>0){let n=t.distinctColumnAliases.map(t=>e.raw`\`${t}\``);a=e`SELECT ${e.join(n,`, `)} FROM (${i}) AS \`_distinct_subquery\``}else a=e`SELECT * FROM (${i}) AS \`_distinct_subquery\``;let o=[a,e.raw`WHERE \`_rn\` = 1`];return t.orderBy&&o.push(e`ORDER BY ${t.orderBy}`),t.limit&&o.push(e`LIMIT ${t.limit}`),t.offset&&o.push(e`OFFSET ${t.offset}`),e.join(o,` `)}};const c=new s,l=()=>{throw Error(`SQLite migrations are not yet implemented. Please use PostgreSQL.`)},u={introspect:async()=>l(),generateDDL:e=>l(),mapFieldType:e=>l()};var d=class{constructor(){this.raw=t=>e.raw`${t}`,this.identifiers={escape:t=>e.raw`"${t}"`,column:(t,n)=>t?e.raw`"${t}"."${n}"`:e.raw`"${n}"`,table:(t,n)=>e.raw`"${t}" AS "${n}"`,aliased:(t,n)=>e`${t} AS ${e.raw`"${n}"`}`},this.literals={value:t=>e`${t}`,null:()=>e.raw`NULL`,true:()=>e.raw`1`,false:()=>e.raw`0`,list:t=>t.length===0?e.raw`()`:e`(${e.join(t,`, `)})`,json:t=>e`${JSON.stringify(t)}`},this.operators={eq:(t,n)=>e`${t} = ${n}`,neq:(t,n)=>e`${t} <> ${n}`,lt:(t,n)=>e`${t} < ${n}`,lte:(t,n)=>e`${t} <= ${n}`,gt:(t,n)=>e`${t} > ${n}`,gte:(t,n)=>e`${t} >= ${n}`,like:(t,n)=>e`${t} LIKE ${n}`,notLike:(t,n)=>e`${t} NOT LIKE ${n}`,ilike:(t,n)=>e`${t} LIKE ${n} COLLATE NOCASE`,notIlike:(t,n)=>e`${t} NOT LIKE ${n} COLLATE NOCASE`,in:(t,n)=>e`${t} IN ${n}`,notIn:(t,n)=>e`${t} NOT IN ${n}`,isNull:t=>e`${t} IS NULL`,isNotNull:t=>e`${t} IS NOT NULL`,between:(t,n,r)=>e`${t} BETWEEN ${n} AND ${r}`,notBetween:(t,n,r)=>e`${t} NOT BETWEEN ${n} AND ${r}`,and:(...t)=>t.length===0?e.raw`1`:t.length===1?t[0]:e`(${e.join(t,` AND `)})`,or:(...t)=>t.length===0?e.raw`0`:t.length===1?t[0]:e`(${e.join(t,` OR `)})`,not:t=>e`NOT (${t})`,exists:t=>e`EXISTS (${t})`,notExists:t=>e`NOT EXISTS (${t})`},this.expressions={add:(t,n)=>e`(${t} + ${n})`,subtract:(t,n)=>e`(${t} - ${n})`,multiply:(t,n)=>e`(${t} * ${n})`,divide:(t,n)=>e`(${t} / ${n})`,concat:(...t)=>t.length===0?e.raw`''`:t.length===1?t[0]:e`(${e.join(t,` || `)})`,upper:t=>e`UPPER(${t})`,lower:t=>e`LOWER(${t})`,coalesce:(...t)=>e`COALESCE(${e.join(t,`, `)})`,greatest:(...t)=>e`MAX(${e.join(t,`, `)})`,least:(...t)=>e`MIN(${e.join(t,`, `)})`,cast:(t,n)=>e`CAST(${t} AS ${e.raw`${n}`})`},this.aggregates={count:t=>t?e`COUNT(${t})`:e.raw`COUNT(*)`,countDistinct:t=>e`COUNT(DISTINCT ${t})`,sum:t=>e`SUM(${t})`,avg:t=>e`AVG(${t})`,min:t=>e`MIN(${t})`,max:t=>e`MAX(${t})`},this.json={object:t=>{if(t.length===0)return e.raw`json_object()`;let n=t.flatMap(([t,n])=>[e`${t}`,n]);return e`json_object(${e.join(n,`, `)})`},array:t=>t.length===0?e.raw`json_array()`:e`json_array(${e.join(t,`, `)})`,emptyArray:()=>e.raw`json_array()`,agg:t=>e`COALESCE(json_group_array(${t}), json_array())`,rowToJson:t=>e`json_object(${e.raw`'row', "${t}".*`})`,objectFromColumns:t=>{if(t.length===0)return e.raw`json_object()`;let n=t.flatMap(([t,n])=>[e`${t}`,n]);return e`json_object(${e.join(n,`, `)})`},extract:(t,n)=>n.length===0?t:e`json_extract(${t}, ${`$.${n.join(`.`)}`})`,extractText:(t,n)=>n.length===0?t:e`json_extract(${t}, ${`$.${n.join(`.`)}`})`},this.arrays={literal:t=>t.length===0?e.raw`json_array()`:e`json_array(${e.join(t,`, `)})`,has:(t,n)=>e`EXISTS (SELECT 1 FROM json_each(${t}) WHERE value = ${n})`,hasEvery:(t,n)=>e`(SELECT COUNT(*) FROM json_each(${n}) WHERE value IN (SELECT value FROM json_each(${t}))) = json_array_length(${n})`,hasSome:(t,n)=>e`EXISTS (SELECT 1 FROM json_each(${t}) AS a, json_each(${n}) AS b WHERE a.value = b.value)`,isEmpty:t=>e`(json_array_length(${t}) = 0 OR ${t} IS NULL)`,length:t=>e`json_array_length(${t})`,get:(t,n)=>e`json_extract(${t}, '$[' || ${n} || ']')`,push:(t,n)=>e`json_insert(${t}, '$[#]', ${n})`,set:(t,n,r)=>e`json_set(${t}, '$[' || ${n} || ']', ${r})`},this.orderBy={asc:t=>e`${t} ASC`,desc:t=>e`${t} DESC`,nullsFirst:e=>e,nullsLast:e=>e},this.clauses={select:t=>e`SELECT ${t}`,selectDistinct:t=>e`SELECT DISTINCT ${t}`,from:t=>e`FROM ${t}`,where:t=>e`WHERE ${t}`,orderBy:t=>e`ORDER BY ${t}`,limit:t=>e`LIMIT ${t}`,offset:t=>e`OFFSET ${t}`,groupBy:t=>e`GROUP BY ${t}`,having:t=>e`HAVING ${t}`},this.set={assign:(t,n)=>e`${t} = ${n}`,increment:(t,n)=>e`${t} = ${t} + ${n}`,decrement:(t,n)=>e`${t} = ${t} - ${n}`,multiply:(t,n)=>e`${t} = ${t} * ${n}`,divide:(t,n)=>e`${t} = ${t} / ${n}`,push:(t,n)=>e`${t} = json_insert(${t}, '$[#]', ${n})`,unshift:(t,n)=>e`${t} = json('[' || json(${n}) || CASE WHEN COALESCE(${t}, '[]') = '[]' THEN ']' ELSE ',' || substr(${t}, 2) END)`},this.filters={some:t=>e`EXISTS (${t})`,every:t=>e`NOT EXISTS (${t})`,none:t=>e`NOT EXISTS (${t})`,is:t=>e`EXISTS (${t})`,isNot:t=>e`NOT EXISTS (${t})`},this.subqueries={scalar:t=>e`(${t})`,correlate:(t,n)=>e`(${t}) AS ${e.raw`"${n}"`}`,existsCheck:(t,n)=>e`SELECT 1 FROM ${t} WHERE ${n}`},this.assemble={select:t=>{if(t.distinct)return this.assembleDistinctOn(t);let n=[e`SELECT ${t.columns}`,e`FROM ${t.from}`];return t.joins&&t.joins.length>0&&n.push(...t.joins),t.where&&n.push(e`WHERE ${t.where}`),t.groupBy&&n.push(e`GROUP BY ${t.groupBy}`),t.having&&n.push(e`HAVING ${t.having}`),t.orderBy&&n.push(e`ORDER BY ${t.orderBy}`),t.limit&&n.push(e`LIMIT ${t.limit}`),t.offset&&n.push(e`OFFSET ${t.offset}`),e.join(n,` `)}},this.cte={with:t=>{let n=t.map(({name:t,query:n})=>e`${e.raw`"${t}"`} AS (${n})`);return e`WITH ${e.join(n,`, `)}`},recursive:(t,n,r,i=`all`)=>{let a=i===`all`?e.raw`UNION ALL`:e.raw`UNION`;return e`WITH RECURSIVE ${e.raw`"${t}"`} AS (
        ${n}
        ${a}
        ${r}
      )`}},this.mutations={insert:(t,n,r)=>{let i=n.map(t=>e.raw`"${t}"`),a=r.map(t=>e`(${e.join(t,`, `)})`);return e`INSERT INTO ${t} (${e.join(i,`, `)}) VALUES ${e.join(a,`, `)}`},update:(t,n,r)=>r?e`UPDATE ${t} SET ${n} WHERE ${r}`:e`UPDATE ${t} SET ${n}`,delete:(t,n)=>n?e`DELETE FROM ${t} WHERE ${n}`:e`DELETE FROM ${t}`,returning:t=>e`RETURNING ${t}`,onConflict:(t,n)=>t?e`ON CONFLICT (${t}) DO ${n}`:e`ON CONFLICT DO ${n}`},this.joins={inner:(t,n)=>e`INNER JOIN ${t} ON ${n}`,left:(t,n)=>e`LEFT JOIN ${t} ON ${n}`,right:(t,n)=>e`LEFT JOIN ${t} ON ${n}`,full:(t,n)=>e`LEFT JOIN ${t} ON ${n}`,cross:t=>e`CROSS JOIN ${t}`},this.setOperations={union:(...t)=>e.join(t,` UNION `),unionAll:(...t)=>e.join(t,` UNION ALL `),intersect:(...t)=>e.join(t,` INTERSECT `),except:(t,n)=>e`${t} EXCEPT ${n}`},this.capabilities={supportsReturning:!0,supportsCteWithMutations:!0,supportsFullOuterJoin:!1},this.lastInsertId=()=>e.raw`last_insert_rowid()`,this.migrations=u,this.vector=r,this.geospatial=i}assembleDistinctOn(t){let n=t.orderBy||t.distinct,r=[e`SELECT ${t.columns}, ROW_NUMBER() OVER (PARTITION BY ${t.distinct} ORDER BY ${n}) AS "_rn"`,e`FROM ${t.from}`];t.joins&&t.joins.length>0&&r.push(...t.joins),t.where&&r.push(e`WHERE ${t.where}`),t.groupBy&&r.push(e`GROUP BY ${t.groupBy}`),t.having&&r.push(e`HAVING ${t.having}`);let i=e.join(r,` `),a;if(t.distinctColumnAliases&&t.distinctColumnAliases.length>0){let n=t.distinctColumnAliases.map(t=>e.raw`"${t}"`);a=e`SELECT ${e.join(n,`, `)} FROM (${i}) AS "_distinct_subquery"`}else a=e`SELECT * FROM (${i}) AS "_distinct_subquery"`;let o=[a,e.raw`WHERE "_rn" = 1`];return t.orderBy&&o.push(e`ORDER BY ${t.orderBy}`),t.limit&&o.push(e`LIMIT ${t.limit}`),t.offset&&o.push(e`OFFSET ${t.offset}`),e.join(o,` `)}};const f=new d;export{s as MySQLAdapter,n as PostgresAdapter,d as SQLiteAdapter,c as mysqlAdapter,t as postgresAdapter,f as sqliteAdapter};
//# sourceMappingURL=adapters.mjs.map