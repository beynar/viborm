{"version":3,"file":"postgres-adapter-CzPH7ypE.mjs","names":["sql"],"sources":["../src/adapters/databases/postgres/migrations.ts","../src/adapters/databases/postgres/postgres-adapter.ts"],"sourcesContent":["/**\n * PostgreSQL Migration Adapter\n *\n * Implements database introspection and DDL generation for PostgreSQL.\n */\n\nimport type {\n  ColumnDef,\n  DiffOperation,\n  EnumDef,\n  ForeignKeyDef,\n  IndexDef,\n  PrimaryKeyDef,\n  ReferentialAction,\n  SchemaSnapshot,\n  TableDef,\n  UniqueConstraintDef,\n} from \"../../../migrations/types\";\nimport type { MigrationAdapter } from \"../../database-adapter\";\n\n// =============================================================================\n// INTROSPECTION QUERY TYPES\n// =============================================================================\n\ninterface PgTable {\n  table_name: string;\n}\n\ninterface PgColumn {\n  table_name: string;\n  column_name: string;\n  data_type: string;\n  udt_name: string;\n  is_nullable: string;\n  column_default: string | null;\n  character_maximum_length: number | null;\n  numeric_precision: number | null;\n  numeric_scale: number | null;\n}\n\ninterface PgPrimaryKey {\n  table_name: string;\n  constraint_name: string;\n  column_name: string;\n  ordinal_position: number;\n}\n\ninterface PgIndex {\n  table_name: string;\n  index_name: string;\n  column_name: string;\n  is_unique: boolean;\n  index_type: string;\n  filter_condition: string | null;\n  ordinal_position: number;\n}\n\ninterface PgForeignKey {\n  table_name: string;\n  constraint_name: string;\n  column_name: string;\n  foreign_table_name: string;\n  foreign_column_name: string;\n  delete_rule: string;\n  update_rule: string;\n  ordinal_position: number;\n}\n\ninterface PgUniqueConstraint {\n  table_name: string;\n  constraint_name: string;\n  column_name: string;\n  ordinal_position: number;\n}\n\ninterface PgEnum {\n  enum_name: string;\n  enum_value: string;\n  sort_order: number;\n}\n\n// =============================================================================\n// INTROSPECTION QUERIES\n// =============================================================================\n\nconst TABLES_QUERY = `\nSELECT table_name\nFROM information_schema.tables\nWHERE table_schema = 'public'\n  AND table_type = 'BASE TABLE'\nORDER BY table_name;\n`;\n\nconst COLUMNS_QUERY = `\nSELECT\n  c.table_name,\n  c.column_name,\n  c.data_type,\n  c.udt_name,\n  c.is_nullable,\n  c.column_default,\n  c.character_maximum_length,\n  c.numeric_precision,\n  c.numeric_scale\nFROM information_schema.columns c\nJOIN information_schema.tables t\n  ON c.table_name = t.table_name\n  AND c.table_schema = t.table_schema\nWHERE c.table_schema = 'public'\n  AND t.table_type = 'BASE TABLE'\nORDER BY c.table_name, c.ordinal_position;\n`;\n\nconst PRIMARY_KEYS_QUERY = `\nSELECT\n  tc.table_name,\n  tc.constraint_name,\n  kcu.column_name,\n  kcu.ordinal_position\nFROM information_schema.table_constraints tc\nJOIN information_schema.key_column_usage kcu\n  ON tc.constraint_name = kcu.constraint_name\n  AND tc.table_schema = kcu.table_schema\nWHERE tc.table_schema = 'public'\n  AND tc.constraint_type = 'PRIMARY KEY'\nORDER BY tc.table_name, kcu.ordinal_position;\n`;\n\nconst INDEXES_QUERY = `\nSELECT\n  t.relname AS table_name,\n  i.relname AS index_name,\n  a.attname AS column_name,\n  ix.indisunique AS is_unique,\n  am.amname AS index_type,\n  pg_get_expr(ix.indpred, ix.indrelid) AS filter_condition,\n  array_position(ix.indkey, a.attnum) AS ordinal_position\nFROM pg_index ix\nJOIN pg_class t ON t.oid = ix.indrelid\nJOIN pg_class i ON i.oid = ix.indexrelid\nJOIN pg_am am ON am.oid = i.relam\nJOIN pg_namespace n ON n.oid = t.relnamespace\nJOIN pg_attribute a ON a.attrelid = t.oid AND a.attnum = ANY(ix.indkey)\nWHERE n.nspname = 'public'\n  AND NOT ix.indisprimary\n  AND t.relkind = 'r'\nORDER BY t.relname, i.relname, array_position(ix.indkey, a.attnum);\n`;\n\nconst FOREIGN_KEYS_QUERY = `\nSELECT\n  tc.table_name,\n  tc.constraint_name,\n  kcu.column_name,\n  ccu.table_name AS foreign_table_name,\n  ccu.column_name AS foreign_column_name,\n  rc.delete_rule,\n  rc.update_rule,\n  kcu.ordinal_position\nFROM information_schema.table_constraints tc\nJOIN information_schema.key_column_usage kcu\n  ON tc.constraint_name = kcu.constraint_name\n  AND tc.table_schema = kcu.table_schema\nJOIN information_schema.constraint_column_usage ccu\n  ON ccu.constraint_name = tc.constraint_name\n  AND ccu.table_schema = tc.table_schema\nJOIN information_schema.referential_constraints rc\n  ON rc.constraint_name = tc.constraint_name\n  AND rc.constraint_schema = tc.table_schema\nWHERE tc.table_schema = 'public'\n  AND tc.constraint_type = 'FOREIGN KEY'\nORDER BY tc.table_name, tc.constraint_name, kcu.ordinal_position;\n`;\n\nconst UNIQUE_CONSTRAINTS_QUERY = `\nSELECT\n  tc.table_name,\n  tc.constraint_name,\n  kcu.column_name,\n  kcu.ordinal_position\nFROM information_schema.table_constraints tc\nJOIN information_schema.key_column_usage kcu\n  ON tc.constraint_name = kcu.constraint_name\n  AND tc.table_schema = kcu.table_schema\nWHERE tc.table_schema = 'public'\n  AND tc.constraint_type = 'UNIQUE'\nORDER BY tc.table_name, tc.constraint_name, kcu.ordinal_position;\n`;\n\nconst ENUMS_QUERY = `\nSELECT\n  t.typname AS enum_name,\n  e.enumlabel AS enum_value,\n  e.enumsortorder AS sort_order\nFROM pg_type t\nJOIN pg_enum e ON t.oid = e.enumtypid\nJOIN pg_namespace n ON n.oid = t.typnamespace\nWHERE n.nspname = 'public'\nORDER BY t.typname, e.enumsortorder;\n`;\n\n// =============================================================================\n// HELPER FUNCTIONS\n// =============================================================================\n\nfunction mapReferentialAction(rule: string): ReferentialAction {\n  switch (rule) {\n    case \"CASCADE\":\n      return \"cascade\";\n    case \"SET NULL\":\n      return \"setNull\";\n    case \"RESTRICT\":\n      return \"restrict\";\n    case \"SET DEFAULT\":\n      return \"setDefault\";\n    case \"NO ACTION\":\n    default:\n      return \"noAction\";\n  }\n}\n\nfunction formatColumnType(col: PgColumn): string {\n  const baseType = col.udt_name.startsWith(\"_\")\n    ? col.udt_name.slice(1) + \"[]\"\n    : col.udt_name;\n\n  // Handle special types with precision\n  if (col.data_type === \"character varying\" && col.character_maximum_length) {\n    return `varchar(${col.character_maximum_length})`;\n  }\n  if (col.data_type === \"character\" && col.character_maximum_length) {\n    return `char(${col.character_maximum_length})`;\n  }\n  if (col.data_type === \"numeric\" && col.numeric_precision) {\n    if (col.numeric_scale) {\n      return `numeric(${col.numeric_precision},${col.numeric_scale})`;\n    }\n    return `numeric(${col.numeric_precision})`;\n  }\n\n  return baseType;\n}\n\nfunction isAutoIncrement(columnDefault: string | null): boolean {\n  if (!columnDefault) return false;\n  return (\n    columnDefault.includes(\"nextval(\") ||\n    columnDefault.includes(\"_seq'::regclass)\")\n  );\n}\n\nfunction cleanDefault(columnDefault: string | null): string | undefined {\n  if (!columnDefault) return undefined;\n\n  // Skip auto-increment defaults\n  if (isAutoIncrement(columnDefault)) return undefined;\n\n  // Clean up type casting (e.g., 'value'::text -> 'value')\n  const cleaned = columnDefault.replace(/::\\w+(\\[\\])?$/, \"\").trim();\n  return cleaned;\n}\n\n// =============================================================================\n// INTROSPECTION\n// =============================================================================\n\nasync function introspect(\n  executeRaw: <T>(sql: string, params?: unknown[]) => Promise<{ rows: T[] }>\n): Promise<SchemaSnapshot> {\n  // Execute all queries in parallel\n  const [\n    tablesResult,\n    columnsResult,\n    primaryKeysResult,\n    indexesResult,\n    foreignKeysResult,\n    uniqueConstraintsResult,\n    enumsResult,\n  ] = await Promise.all([\n    executeRaw<PgTable>(TABLES_QUERY),\n    executeRaw<PgColumn>(COLUMNS_QUERY),\n    executeRaw<PgPrimaryKey>(PRIMARY_KEYS_QUERY),\n    executeRaw<PgIndex>(INDEXES_QUERY),\n    executeRaw<PgForeignKey>(FOREIGN_KEYS_QUERY),\n    executeRaw<PgUniqueConstraint>(UNIQUE_CONSTRAINTS_QUERY),\n    executeRaw<PgEnum>(ENUMS_QUERY),\n  ]);\n\n  // Group columns by table\n  const columnsByTable = new Map<string, PgColumn[]>();\n  for (const col of columnsResult.rows) {\n    const cols = columnsByTable.get(col.table_name) || [];\n    cols.push(col);\n    columnsByTable.set(col.table_name, cols);\n  }\n\n  // Group primary keys by table\n  const pkByTable = new Map<string, PgPrimaryKey[]>();\n  for (const pk of primaryKeysResult.rows) {\n    const pks = pkByTable.get(pk.table_name) || [];\n    pks.push(pk);\n    pkByTable.set(pk.table_name, pks);\n  }\n\n  // Group indexes by table and index name\n  const indexesByTable = new Map<string, Map<string, PgIndex[]>>();\n  for (const idx of indexesResult.rows) {\n    if (!indexesByTable.has(idx.table_name)) {\n      indexesByTable.set(idx.table_name, new Map());\n    }\n    const tableIndexes = indexesByTable.get(idx.table_name)!;\n    const indexCols = tableIndexes.get(idx.index_name) || [];\n    indexCols.push(idx);\n    tableIndexes.set(idx.index_name, indexCols);\n  }\n\n  // Group foreign keys by table and constraint name\n  const fkByTable = new Map<string, Map<string, PgForeignKey[]>>();\n  for (const fk of foreignKeysResult.rows) {\n    if (!fkByTable.has(fk.table_name)) {\n      fkByTable.set(fk.table_name, new Map());\n    }\n    const tableFks = fkByTable.get(fk.table_name)!;\n    const fkCols = tableFks.get(fk.constraint_name) || [];\n    fkCols.push(fk);\n    tableFks.set(fk.constraint_name, fkCols);\n  }\n\n  // Group unique constraints by table and constraint name\n  const uniqueByTable = new Map<string, Map<string, PgUniqueConstraint[]>>();\n  for (const uq of uniqueConstraintsResult.rows) {\n    if (!uniqueByTable.has(uq.table_name)) {\n      uniqueByTable.set(uq.table_name, new Map());\n    }\n    const tableUniques = uniqueByTable.get(uq.table_name)!;\n    const uqCols = tableUniques.get(uq.constraint_name) || [];\n    uqCols.push(uq);\n    tableUniques.set(uq.constraint_name, uqCols);\n  }\n\n  // Group enum values by enum name\n  const enumsByName = new Map<string, PgEnum[]>();\n  for (const e of enumsResult.rows) {\n    const vals = enumsByName.get(e.enum_name) || [];\n    vals.push(e);\n    enumsByName.set(e.enum_name, vals);\n  }\n\n  // Build tables\n  const tables: TableDef[] = [];\n\n  for (const table of tablesResult.rows) {\n    const tableName = table.table_name;\n\n    // Build columns\n    const columns: ColumnDef[] = (columnsByTable.get(tableName) || []).map(\n      (col) => ({\n        name: col.column_name,\n        type: formatColumnType(col),\n        nullable: col.is_nullable === \"YES\",\n        default: cleanDefault(col.column_default),\n        autoIncrement: isAutoIncrement(col.column_default),\n      })\n    );\n\n    // Build primary key\n    let primaryKey: PrimaryKeyDef | undefined;\n    const pkCols = pkByTable.get(tableName);\n    if (pkCols && pkCols.length > 0) {\n      pkCols.sort((a, b) => a.ordinal_position - b.ordinal_position);\n      primaryKey = {\n        columns: pkCols.map((pk) => pk.column_name),\n        name: pkCols[0]!.constraint_name,\n      };\n    }\n\n    // Build indexes\n    const indexes: IndexDef[] = [];\n    const tableIndexes = indexesByTable.get(tableName);\n    if (tableIndexes) {\n      for (const [indexName, indexCols] of tableIndexes) {\n        indexCols.sort((a, b) => a.ordinal_position - b.ordinal_position);\n        const firstCol = indexCols[0]!;\n        indexes.push({\n          name: indexName,\n          columns: indexCols.map((idx) => idx.column_name),\n          unique: firstCol.is_unique,\n          type: firstCol.index_type as \"btree\" | \"hash\" | \"gin\" | \"gist\",\n          where: firstCol.filter_condition || undefined,\n        });\n      }\n    }\n\n    // Build foreign keys\n    const foreignKeys: ForeignKeyDef[] = [];\n    const tableFks = fkByTable.get(tableName);\n    if (tableFks) {\n      for (const [constraintName, fkCols] of tableFks) {\n        fkCols.sort((a, b) => a.ordinal_position - b.ordinal_position);\n        const firstFk = fkCols[0]!;\n        foreignKeys.push({\n          name: constraintName,\n          columns: fkCols.map((fk) => fk.column_name),\n          referencedTable: firstFk.foreign_table_name,\n          referencedColumns: fkCols.map((fk) => fk.foreign_column_name),\n          onDelete: mapReferentialAction(firstFk.delete_rule),\n          onUpdate: mapReferentialAction(firstFk.update_rule),\n        });\n      }\n    }\n\n    // Build unique constraints\n    const uniqueConstraints: UniqueConstraintDef[] = [];\n    const tableUniques = uniqueByTable.get(tableName);\n    if (tableUniques) {\n      for (const [constraintName, uqCols] of tableUniques) {\n        uqCols.sort((a, b) => a.ordinal_position - b.ordinal_position);\n        uniqueConstraints.push({\n          name: constraintName,\n          columns: uqCols.map((uq) => uq.column_name),\n        });\n      }\n    }\n\n    tables.push({\n      name: tableName,\n      columns,\n      primaryKey,\n      indexes,\n      foreignKeys,\n      uniqueConstraints,\n    });\n  }\n\n  // Build enums\n  const enums: EnumDef[] = [];\n  for (const [enumName, enumVals] of enumsByName) {\n    enumVals.sort((a, b) => a.sort_order - b.sort_order);\n    enums.push({\n      name: enumName,\n      values: enumVals.map((e) => e.enum_value),\n    });\n  }\n\n  return {\n    tables,\n    enums: enums.length > 0 ? enums : undefined,\n  };\n}\n\n// =============================================================================\n// DDL GENERATION\n// =============================================================================\n\nfunction escapeIdentifier(name: string): string {\n  return `\"${name.replace(/\"/g, '\"\"')}\"`;\n}\n\nfunction escapeValue(value: string): string {\n  return `'${value.replace(/'/g, \"''\")}'`;\n}\n\nfunction formatReferentialAction(action: ReferentialAction): string {\n  switch (action) {\n    case \"cascade\":\n      return \"CASCADE\";\n    case \"setNull\":\n      return \"SET NULL\";\n    case \"restrict\":\n      return \"RESTRICT\";\n    case \"setDefault\":\n      return \"SET DEFAULT\";\n    case \"noAction\":\n    default:\n      return \"NO ACTION\";\n  }\n}\n\nfunction generateColumnDef(column: ColumnDef): string {\n  const parts: string[] = [escapeIdentifier(column.name)];\n\n  // Handle serial types for auto-increment\n  if (column.autoIncrement) {\n    if (column.type === \"integer\" || column.type === \"int4\") {\n      parts.push(\"SERIAL\");\n    } else if (column.type === \"bigint\" || column.type === \"int8\") {\n      parts.push(\"BIGSERIAL\");\n    } else if (column.type === \"smallint\" || column.type === \"int2\") {\n      parts.push(\"SMALLSERIAL\");\n    } else {\n      parts.push(column.type);\n    }\n  } else {\n    parts.push(column.type);\n  }\n\n  if (!column.nullable) {\n    parts.push(\"NOT NULL\");\n  }\n\n  if (column.default !== undefined && !column.autoIncrement) {\n    parts.push(`DEFAULT ${column.default}`);\n  }\n\n  return parts.join(\" \");\n}\n\nfunction generateDDL(operation: DiffOperation): string {\n  switch (operation.type) {\n    case \"createTable\": {\n      const { table } = operation;\n      const columnDefs = table.columns.map(generateColumnDef);\n\n      // Add primary key constraint\n      if (table.primaryKey) {\n        const pkCols = table.primaryKey.columns\n          .map(escapeIdentifier)\n          .join(\", \");\n        const pkName = table.primaryKey.name\n          ? `CONSTRAINT ${escapeIdentifier(table.primaryKey.name)} `\n          : \"\";\n        columnDefs.push(`${pkName}PRIMARY KEY (${pkCols})`);\n      }\n\n      // Add unique constraints\n      for (const uq of table.uniqueConstraints) {\n        const uqCols = uq.columns.map(escapeIdentifier).join(\", \");\n        columnDefs.push(\n          `CONSTRAINT ${escapeIdentifier(uq.name)} UNIQUE (${uqCols})`\n        );\n      }\n\n      const sql = `CREATE TABLE ${escapeIdentifier(table.name)} (\\n  ${columnDefs.join(\",\\n  \")}\\n)`;\n\n      // Add indexes and foreign keys as separate statements\n      const statements = [sql];\n\n      for (const idx of table.indexes) {\n        statements.push(\n          generateDDL({\n            type: \"createIndex\",\n            tableName: table.name,\n            index: idx,\n          })\n        );\n      }\n\n      for (const fk of table.foreignKeys) {\n        statements.push(\n          generateDDL({ type: \"addForeignKey\", tableName: table.name, fk })\n        );\n      }\n\n      return statements.join(\";\\n\");\n    }\n\n    case \"dropTable\":\n      return `DROP TABLE ${escapeIdentifier(operation.tableName)} CASCADE`;\n\n    case \"renameTable\":\n      return `ALTER TABLE ${escapeIdentifier(operation.from)} RENAME TO ${escapeIdentifier(operation.to)}`;\n\n    case \"addColumn\": {\n      const colDef = generateColumnDef(operation.column);\n      return `ALTER TABLE ${escapeIdentifier(operation.tableName)} ADD COLUMN ${colDef}`;\n    }\n\n    case \"dropColumn\":\n      return `ALTER TABLE ${escapeIdentifier(operation.tableName)} DROP COLUMN ${escapeIdentifier(operation.columnName)}`;\n\n    case \"renameColumn\":\n      return `ALTER TABLE ${escapeIdentifier(operation.tableName)} RENAME COLUMN ${escapeIdentifier(operation.from)} TO ${escapeIdentifier(operation.to)}`;\n\n    case \"alterColumn\": {\n      const { tableName, columnName, from, to } = operation;\n      const statements: string[] = [];\n      const table = escapeIdentifier(tableName);\n      const col = escapeIdentifier(columnName);\n\n      // Type change\n      if (from.type !== to.type) {\n        statements.push(\n          `ALTER TABLE ${table} ALTER COLUMN ${col} TYPE ${to.type} USING ${col}::${to.type}`\n        );\n      }\n\n      // Nullable change\n      if (from.nullable !== to.nullable) {\n        if (to.nullable) {\n          statements.push(\n            `ALTER TABLE ${table} ALTER COLUMN ${col} DROP NOT NULL`\n          );\n        } else {\n          statements.push(\n            `ALTER TABLE ${table} ALTER COLUMN ${col} SET NOT NULL`\n          );\n        }\n      }\n\n      // Default change\n      if (from.default !== to.default) {\n        if (to.default === undefined) {\n          statements.push(\n            `ALTER TABLE ${table} ALTER COLUMN ${col} DROP DEFAULT`\n          );\n        } else {\n          statements.push(\n            `ALTER TABLE ${table} ALTER COLUMN ${col} SET DEFAULT ${to.default}`\n          );\n        }\n      }\n\n      return statements.join(\";\\n\");\n    }\n\n    case \"createIndex\": {\n      const { tableName, index } = operation;\n      const unique = index.unique ? \"UNIQUE \" : \"\";\n      const indexType = index.type ? `USING ${index.type} ` : \"\";\n      const cols = index.columns.map(escapeIdentifier).join(\", \");\n      const where = index.where ? ` WHERE ${index.where}` : \"\";\n      return `CREATE ${unique}INDEX ${escapeIdentifier(index.name)} ON ${escapeIdentifier(tableName)} ${indexType}(${cols})${where}`;\n    }\n\n    case \"dropIndex\":\n      return `DROP INDEX ${escapeIdentifier(operation.indexName)}`;\n\n    case \"addForeignKey\": {\n      const { tableName, fk } = operation;\n      const cols = fk.columns.map(escapeIdentifier).join(\", \");\n      const refCols = fk.referencedColumns.map(escapeIdentifier).join(\", \");\n      const onDelete = fk.onDelete\n        ? ` ON DELETE ${formatReferentialAction(fk.onDelete)}`\n        : \"\";\n      const onUpdate = fk.onUpdate\n        ? ` ON UPDATE ${formatReferentialAction(fk.onUpdate)}`\n        : \"\";\n      return `ALTER TABLE ${escapeIdentifier(tableName)} ADD CONSTRAINT ${escapeIdentifier(fk.name)} FOREIGN KEY (${cols}) REFERENCES ${escapeIdentifier(fk.referencedTable)} (${refCols})${onDelete}${onUpdate}`;\n    }\n\n    case \"dropForeignKey\":\n      return `ALTER TABLE ${escapeIdentifier(operation.tableName)} DROP CONSTRAINT ${escapeIdentifier(operation.fkName)}`;\n\n    case \"addUniqueConstraint\": {\n      const { tableName, constraint } = operation;\n      const cols = constraint.columns.map(escapeIdentifier).join(\", \");\n      return `ALTER TABLE ${escapeIdentifier(tableName)} ADD CONSTRAINT ${escapeIdentifier(constraint.name)} UNIQUE (${cols})`;\n    }\n\n    case \"dropUniqueConstraint\":\n      return `ALTER TABLE ${escapeIdentifier(operation.tableName)} DROP CONSTRAINT ${escapeIdentifier(operation.constraintName)}`;\n\n    case \"addPrimaryKey\": {\n      const { tableName, primaryKey } = operation;\n      const cols = primaryKey.columns.map(escapeIdentifier).join(\", \");\n      const name = primaryKey.name\n        ? escapeIdentifier(primaryKey.name)\n        : escapeIdentifier(`${tableName}_pkey`);\n      return `ALTER TABLE ${escapeIdentifier(tableName)} ADD CONSTRAINT ${name} PRIMARY KEY (${cols})`;\n    }\n\n    case \"dropPrimaryKey\":\n      return `ALTER TABLE ${escapeIdentifier(operation.tableName)} DROP CONSTRAINT ${escapeIdentifier(operation.constraintName)}`;\n\n    case \"createEnum\": {\n      const { enumDef } = operation;\n      const values = enumDef.values.map(escapeValue).join(\", \");\n      return `CREATE TYPE ${escapeIdentifier(enumDef.name)} AS ENUM (${values})`;\n    }\n\n    case \"dropEnum\":\n      return `DROP TYPE ${escapeIdentifier(operation.enumName)}`;\n\n    case \"alterEnum\": {\n      const { enumName, addValues, removeValues } = operation;\n      const statements: string[] = [];\n\n      // PostgreSQL can add values but not remove them easily\n      if (addValues) {\n        for (const value of addValues) {\n          statements.push(\n            `ALTER TYPE ${escapeIdentifier(enumName)} ADD VALUE ${escapeValue(value)}`\n          );\n        }\n      }\n\n      // Note: Removing enum values in PostgreSQL requires recreating the type\n      if (removeValues && removeValues.length > 0) {\n        statements.push(\n          `-- WARNING: Removing enum values requires recreating the type. Values to remove: ${removeValues.join(\", \")}`\n        );\n      }\n\n      return statements.join(\";\\n\");\n    }\n\n    default:\n      throw new Error(`Unknown operation type: ${(operation as any).type}`);\n  }\n}\n\n// =============================================================================\n// TYPE MAPPING\n// =============================================================================\n\nfunction mapFieldType(\n  fieldType: string,\n  options?: { array?: boolean; autoIncrement?: boolean }\n): string {\n  let baseType: string;\n\n  switch (fieldType) {\n    case \"string\":\n      baseType = \"text\";\n      break;\n    case \"int\":\n      baseType = options?.autoIncrement ? \"serial\" : \"integer\";\n      break;\n    case \"float\":\n      baseType = \"double precision\";\n      break;\n    case \"decimal\":\n      baseType = \"numeric\";\n      break;\n    case \"boolean\":\n      baseType = \"boolean\";\n      break;\n    case \"datetime\":\n      baseType = \"timestamptz\";\n      break;\n    case \"date\":\n      baseType = \"date\";\n      break;\n    case \"time\":\n      baseType = \"time\";\n      break;\n    case \"bigint\":\n      baseType = options?.autoIncrement ? \"bigserial\" : \"bigint\";\n      break;\n    case \"json\":\n      baseType = \"jsonb\";\n      break;\n    case \"blob\":\n      baseType = \"bytea\";\n      break;\n    case \"vector\":\n      baseType = \"vector\";\n      break;\n    case \"point\":\n      baseType = \"point\";\n      break;\n    default:\n      baseType = fieldType;\n  }\n\n  return options?.array ? `${baseType}[]` : baseType;\n}\n\n// =============================================================================\n// EXPORT\n// =============================================================================\n\nexport const postgresMigrations: MigrationAdapter = {\n  introspect,\n  generateDDL,\n  mapFieldType,\n};\n","import { type Sql, sql } from \"@sql\";\nimport type { DatabaseAdapter, QueryParts } from \"../../database-adapter\";\nimport { postgresMigrations } from \"./migrations\";\n\n/**\n * PostgreSQL Database Adapter\n *\n * Implements the DatabaseAdapter interface for PostgreSQL-specific SQL generation.\n *\n * Key PostgreSQL features:\n * - Double-quote identifier escaping: \"table\".\"column\"\n * - Native ARRAY type with operators: @>, &&, ANY()\n * - ILIKE for case-insensitive matching\n * - json_build_object(), json_agg() for JSON operations\n * - RETURNING clause for mutations\n * - NULLS FIRST/LAST ordering\n * - ON CONFLICT DO UPDATE/NOTHING\n */\nexport class PostgresAdapter implements DatabaseAdapter {\n  // ============================================================\n  // RAW\n  // ============================================================\n\n  raw = (sqlString: string): Sql => sql.raw`${sqlString}`;\n\n  // ============================================================\n  // IDENTIFIERS\n  // ============================================================\n\n  identifiers = {\n    escape: (name: string): Sql => sql.raw`\"${name}\"`,\n\n    column: (alias: string, field: string): Sql =>\n      alias ? sql.raw`\"${alias}\".\"${field}\"` : sql.raw`\"${field}\"`,\n\n    table: (tableName: string, alias: string): Sql =>\n      sql.raw`\"${tableName}\" AS \"${alias}\"`,\n\n    aliased: (expression: Sql, alias: string): Sql =>\n      sql`${expression} AS ${sql.raw`\"${alias}\"`}`,\n  };\n\n  // ============================================================\n  // LITERALS\n  // ============================================================\n\n  literals = {\n    value: (v: unknown): Sql => sql`${v}`,\n\n    null: (): Sql => sql.raw`NULL`,\n\n    true: (): Sql => sql.raw`TRUE`,\n\n    false: (): Sql => sql.raw`FALSE`,\n\n    list: (values: Sql[]): Sql => {\n      if (values.length === 0) return sql.raw`()`;\n      return sql`(${sql.join(values, \", \")})`;\n    },\n\n    // PostgreSQL handles JSON natively\n    json: (v: unknown): Sql => sql`${v}`,\n  };\n\n  // ============================================================\n  // OPERATORS\n  // ============================================================\n\n  operators = {\n    // Comparison\n    eq: (left: Sql, right: Sql): Sql => sql`${left} = ${right}`,\n    neq: (left: Sql, right: Sql): Sql => sql`${left} <> ${right}`,\n    lt: (left: Sql, right: Sql): Sql => sql`${left} < ${right}`,\n    lte: (left: Sql, right: Sql): Sql => sql`${left} <= ${right}`,\n    gt: (left: Sql, right: Sql): Sql => sql`${left} > ${right}`,\n    gte: (left: Sql, right: Sql): Sql => sql`${left} >= ${right}`,\n\n    // Pattern matching\n    like: (column: Sql, pattern: Sql): Sql => sql`${column} LIKE ${pattern}`,\n    notLike: (column: Sql, pattern: Sql): Sql =>\n      sql`${column} NOT LIKE ${pattern}`,\n    ilike: (column: Sql, pattern: Sql): Sql => sql`${column} ILIKE ${pattern}`,\n    notIlike: (column: Sql, pattern: Sql): Sql =>\n      sql`${column} NOT ILIKE ${pattern}`,\n\n    // Set membership\n    in: (column: Sql, values: Sql): Sql => sql`${column} = ANY(${values})`,\n    notIn: (column: Sql, values: Sql): Sql => sql`${column} <> ALL(${values})`,\n\n    // Null checks\n    isNull: (expr: Sql): Sql => sql`${expr} IS NULL`,\n    isNotNull: (expr: Sql): Sql => sql`${expr} IS NOT NULL`,\n\n    // Range\n    between: (column: Sql, min: Sql, max: Sql): Sql =>\n      sql`${column} BETWEEN ${min} AND ${max}`,\n    notBetween: (column: Sql, min: Sql, max: Sql): Sql =>\n      sql`${column} NOT BETWEEN ${min} AND ${max}`,\n\n    // Logical\n    and: (...conditions: Sql[]): Sql => {\n      if (conditions.length === 0) return sql.raw`TRUE`;\n      if (conditions.length === 1) return conditions[0]!;\n      return sql`(${sql.join(conditions, \" AND \")})`;\n    },\n\n    or: (...conditions: Sql[]): Sql => {\n      if (conditions.length === 0) return sql.raw`FALSE`;\n      if (conditions.length === 1) return conditions[0]!;\n      return sql`(${sql.join(conditions, \" OR \")})`;\n    },\n\n    not: (condition: Sql): Sql => sql`NOT (${condition})`,\n\n    // Subquery existence\n    exists: (subquery: Sql): Sql => sql`EXISTS (${subquery})`,\n    notExists: (subquery: Sql): Sql => sql`NOT EXISTS (${subquery})`,\n  };\n\n  // ============================================================\n  // EXPRESSIONS\n  // ============================================================\n\n  expressions = {\n    // Arithmetic\n    add: (left: Sql, right: Sql): Sql => sql`(${left} + ${right})`,\n    subtract: (left: Sql, right: Sql): Sql => sql`(${left} - ${right})`,\n    multiply: (left: Sql, right: Sql): Sql => sql`(${left} * ${right})`,\n    divide: (left: Sql, right: Sql): Sql => sql`(${left} / ${right})`,\n\n    // String operations\n    concat: (...parts: Sql[]): Sql => {\n      if (parts.length === 0) return sql.raw`''`;\n      if (parts.length === 1) return parts[0]!;\n      return sql`(${sql.join(parts, \" || \")})`;\n    },\n    upper: (expr: Sql): Sql => sql`UPPER(${expr})`,\n    lower: (expr: Sql): Sql => sql`LOWER(${expr})`,\n\n    // Utility\n    coalesce: (...exprs: Sql[]): Sql => sql`COALESCE(${sql.join(exprs, \", \")})`,\n    greatest: (...exprs: Sql[]): Sql => sql`GREATEST(${sql.join(exprs, \", \")})`,\n    least: (...exprs: Sql[]): Sql => sql`LEAST(${sql.join(exprs, \", \")})`,\n    cast: (expr: Sql, type: string): Sql =>\n      sql`CAST(${expr} AS ${sql.raw`${type}`})`,\n  };\n\n  // ============================================================\n  // AGGREGATES\n  // ============================================================\n\n  aggregates = {\n    count: (expr?: Sql): Sql =>\n      expr ? sql`COUNT(${expr})` : sql.raw`COUNT(*)`,\n    countDistinct: (expr: Sql): Sql => sql`COUNT(DISTINCT ${expr})`,\n    sum: (expr: Sql): Sql => sql`SUM(${expr})`,\n    avg: (expr: Sql): Sql => sql`AVG(${expr})`,\n    min: (expr: Sql): Sql => sql`MIN(${expr})`,\n    max: (expr: Sql): Sql => sql`MAX(${expr})`,\n  };\n\n  // ============================================================\n  // JSON\n  // ============================================================\n\n  json = {\n    object: (pairs: [string, Sql][]): Sql => {\n      if (pairs.length === 0) return sql.raw`'{}'::json`;\n      const args = pairs.flatMap(([key, value]) => [sql.raw`'${key}'`, value]);\n      return sql`json_build_object(${sql.join(args, \", \")})`;\n    },\n\n    array: (items: Sql[]): Sql => {\n      if (items.length === 0) return sql.raw`'[]'::json`;\n      return sql`json_build_array(${sql.join(items, \", \")})`;\n    },\n\n    emptyArray: (): Sql => sql.raw`'[]'::json`,\n\n    agg: (expr: Sql): Sql => sql`COALESCE(json_agg(${expr}), '[]'::json)`,\n\n    rowToJson: (alias: string): Sql => sql`row_to_json(${sql.raw`\"${alias}\"`})`,\n\n    objectFromColumns: (columns: [string, Sql][]): Sql => {\n      if (columns.length === 0) return sql.raw`'{}'::json`;\n      const args = columns.flatMap(([key, value]) => [\n        sql.raw`'${key}'`,\n        value,\n      ]);\n      return sql`json_build_object(${sql.join(args, \", \")})`;\n    },\n\n    extract: (column: Sql, path: string[]): Sql => {\n      if (path.length === 0) return column;\n      if (path.length === 1) return sql`${column}->${path[0]}`;\n      const pathStr = path.join(\",\");\n      return sql`${column}#>'{${sql.raw`${pathStr}`}}'`;\n    },\n\n    extractText: (column: Sql, path: string[]): Sql => {\n      if (path.length === 0) return column;\n      if (path.length === 1) return sql`${column}->>${path[0]}`;\n      const pathStr = path.join(\",\");\n      return sql`${column}#>>'{${sql.raw`${pathStr}`}}'`;\n    },\n  };\n\n  // ============================================================\n  // ARRAYS (Native PostgreSQL arrays)\n  // ============================================================\n\n  arrays = {\n    literal: (items: Sql[]): Sql => {\n      if (items.length === 0) return sql.raw`'{}'`;\n      return sql`ARRAY[${sql.join(items, \", \")}]`;\n    },\n\n    has: (column: Sql, value: Sql): Sql => sql`${value} = ANY(${column})`,\n\n    hasEvery: (column: Sql, values: Sql): Sql => sql`${column} @> ${values}`,\n\n    hasSome: (column: Sql, values: Sql): Sql => sql`${column} && ${values}`,\n\n    isEmpty: (column: Sql): Sql =>\n      sql`(cardinality(${column}) = 0 OR ${column} IS NULL)`,\n\n    length: (column: Sql): Sql => sql`cardinality(${column})`,\n\n    get: (column: Sql, index: Sql): Sql => sql`${column}[${index}]`,\n\n    push: (column: Sql, value: Sql): Sql =>\n      sql`array_append(${column}, ${value})`,\n\n    set: (column: Sql, index: Sql, value: Sql): Sql =>\n      sql`${column}[:${index}-1] || ARRAY[${value}] || ${column}[${index}+1:]`,\n  };\n\n  // ============================================================\n  // ORDER BY\n  // ============================================================\n\n  orderBy = {\n    asc: (column: Sql): Sql => sql`${column} ASC`,\n    desc: (column: Sql): Sql => sql`${column} DESC`,\n    nullsFirst: (expr: Sql): Sql => sql`${expr} NULLS FIRST`,\n    nullsLast: (expr: Sql): Sql => sql`${expr} NULLS LAST`,\n  };\n\n  // ============================================================\n  // CLAUSES\n  // ============================================================\n\n  clauses = {\n    select: (columns: Sql): Sql => sql`SELECT ${columns}`,\n    selectDistinct: (columns: Sql): Sql => sql`SELECT DISTINCT ${columns}`,\n    from: (table: Sql): Sql => sql`FROM ${table}`,\n    where: (condition: Sql): Sql => sql`WHERE ${condition}`,\n    orderBy: (orders: Sql): Sql => sql`ORDER BY ${orders}`,\n    limit: (count: Sql): Sql => sql`LIMIT ${count}`,\n    offset: (count: Sql): Sql => sql`OFFSET ${count}`,\n    groupBy: (columns: Sql): Sql => sql`GROUP BY ${columns}`,\n    having: (condition: Sql): Sql => sql`HAVING ${condition}`,\n  };\n\n  // ============================================================\n  // SET (UPDATE operations)\n  // ============================================================\n\n  set = {\n    assign: (column: Sql, value: Sql): Sql => sql`${column} = ${value}`,\n\n    increment: (column: Sql, by: Sql): Sql =>\n      sql`${column} = ${column} + ${by}`,\n\n    decrement: (column: Sql, by: Sql): Sql =>\n      sql`${column} = ${column} - ${by}`,\n\n    multiply: (column: Sql, by: Sql): Sql => sql`${column} = ${column} * ${by}`,\n\n    divide: (column: Sql, by: Sql): Sql => sql`${column} = ${column} / ${by}`,\n\n    push: (column: Sql, value: Sql): Sql =>\n      sql`${column} = array_append(${column}, ${value})`,\n\n    unshift: (column: Sql, value: Sql): Sql =>\n      sql`${column} = array_prepend(${value}, ${column})`,\n  };\n\n  // ============================================================\n  // FILTERS (Relation subquery wrappers)\n  // ============================================================\n\n  filters = {\n    some: (subquery: Sql): Sql => sql`EXISTS (${subquery})`,\n    every: (subquery: Sql): Sql => sql`NOT EXISTS (${subquery})`,\n    none: (subquery: Sql): Sql => sql`NOT EXISTS (${subquery})`,\n    is: (subquery: Sql): Sql => sql`EXISTS (${subquery})`,\n    isNot: (subquery: Sql): Sql => sql`NOT EXISTS (${subquery})`,\n  };\n\n  // ============================================================\n  // SUBQUERIES\n  // ============================================================\n\n  subqueries = {\n    scalar: (query: Sql): Sql => sql`(${query})`,\n\n    correlate: (query: Sql, alias: string): Sql =>\n      sql`(${query}) AS ${sql.raw`\"${alias}\"`}`,\n\n    existsCheck: (from: Sql, where: Sql): Sql =>\n      sql`SELECT 1 FROM ${from} WHERE ${where}`,\n  };\n\n  // ============================================================\n  // ASSEMBLE (Build complete SQL statements)\n  // ============================================================\n\n  assemble = {\n    select: (parts: QueryParts): Sql => {\n      // PostgreSQL supports DISTINCT ON (columns)\n      const selectClause = parts.distinct\n        ? sql`SELECT DISTINCT ON (${parts.distinct}) ${parts.columns}`\n        : sql`SELECT ${parts.columns}`;\n\n      const fragments: Sql[] = [selectClause, sql`FROM ${parts.from}`];\n\n      if (parts.joins && parts.joins.length > 0) {\n        fragments.push(...parts.joins);\n      }\n\n      if (parts.where) {\n        fragments.push(sql`WHERE ${parts.where}`);\n      }\n\n      if (parts.groupBy) {\n        fragments.push(sql`GROUP BY ${parts.groupBy}`);\n      }\n\n      if (parts.having) {\n        fragments.push(sql`HAVING ${parts.having}`);\n      }\n\n      if (parts.orderBy) {\n        fragments.push(sql`ORDER BY ${parts.orderBy}`);\n      }\n\n      if (parts.limit) {\n        fragments.push(sql`LIMIT ${parts.limit}`);\n      }\n\n      if (parts.offset) {\n        fragments.push(sql`OFFSET ${parts.offset}`);\n      }\n\n      return sql.join(fragments, \" \");\n    },\n  };\n\n  // ============================================================\n  // CTE (Common Table Expressions)\n  // ============================================================\n\n  cte = {\n    with: (definitions: { name: string; query: Sql }[]): Sql => {\n      const defs = definitions.map(\n        ({ name, query }) => sql`${sql.raw`\"${name}\"`} AS (${query})`\n      );\n      return sql`WITH ${sql.join(defs, \", \")}`;\n    },\n\n    recursive: (\n      name: string,\n      anchor: Sql,\n      recursive: Sql,\n      union: \"all\" | \"distinct\" = \"all\"\n    ): Sql => {\n      const unionKeyword =\n        union === \"all\" ? sql.raw`UNION ALL` : sql.raw`UNION`;\n      return sql`WITH RECURSIVE ${sql.raw`\"${name}\"`} AS (\n        ${anchor}\n        ${unionKeyword}\n        ${recursive}\n      )`;\n    },\n  };\n\n  // ============================================================\n  // MUTATIONS\n  // ============================================================\n\n  mutations = {\n    insert: (table: Sql, columns: string[], values: Sql[][]): Sql => {\n      const cols = columns.map((c) => sql.raw`\"${c}\"`);\n      const rows = values.map((row) => sql`(${sql.join(row, \", \")})`);\n      return sql`INSERT INTO ${table} (${sql.join(\n        cols,\n        \", \"\n      )}) VALUES ${sql.join(rows, \", \")}`;\n    },\n\n    update: (table: Sql, sets: Sql, where?: Sql): Sql => {\n      if (where) {\n        return sql`UPDATE ${table} SET ${sets} WHERE ${where}`;\n      }\n      return sql`UPDATE ${table} SET ${sets}`;\n    },\n\n    delete: (table: Sql, where?: Sql): Sql => {\n      if (where) {\n        return sql`DELETE FROM ${table} WHERE ${where}`;\n      }\n      return sql`DELETE FROM ${table}`;\n    },\n\n    returning: (columns: Sql): Sql => sql`RETURNING ${columns}`,\n\n    onConflict: (target: Sql | null, action: Sql): Sql => {\n      if (target) {\n        return sql`ON CONFLICT (${target}) DO ${action}`;\n      }\n      return sql`ON CONFLICT DO ${action}`;\n    },\n  };\n\n  // ============================================================\n  // JOINS\n  // ============================================================\n\n  joins = {\n    inner: (table: Sql, condition: Sql): Sql =>\n      sql`INNER JOIN ${table} ON ${condition}`,\n\n    left: (table: Sql, condition: Sql): Sql =>\n      sql`LEFT JOIN ${table} ON ${condition}`,\n\n    right: (table: Sql, condition: Sql): Sql =>\n      sql`RIGHT JOIN ${table} ON ${condition}`,\n\n    full: (table: Sql, condition: Sql): Sql =>\n      sql`FULL OUTER JOIN ${table} ON ${condition}`,\n\n    cross: (table: Sql): Sql => sql`CROSS JOIN ${table}`,\n  };\n\n  // ============================================================\n  // SET OPERATIONS\n  // ============================================================\n\n  setOperations = {\n    union: (...queries: Sql[]): Sql => sql.join(queries, \" UNION \"),\n\n    unionAll: (...queries: Sql[]): Sql => sql.join(queries, \" UNION ALL \"),\n\n    intersect: (...queries: Sql[]): Sql => sql.join(queries, \" INTERSECT \"),\n\n    except: (left: Sql, right: Sql): Sql => sql`${left} EXCEPT ${right}`,\n  };\n\n  // ============================================================\n  // CAPABILITIES\n  // ============================================================\n\n  capabilities = {\n    supportsReturning: true,\n    supportsCteWithMutations: true,\n    supportsFullOuterJoin: true,\n  };\n\n  lastInsertId = (): Sql => sql.raw`lastval()`;\n\n  // ============================================================\n  // MIGRATIONS\n  // ============================================================\n\n  migrations = postgresMigrations;\n\n  // ============================================================\n  // VECTOR (pgvector)\n  // ============================================================\n\n  vector = {\n    literal: (values: number[]): Sql => sql`${`[${values.join(\",\")}]`}::vector`,\n\n    l2: (column: Sql, vector: Sql): Sql => sql`${column} <-> ${vector}`,\n\n    cosine: (column: Sql, vector: Sql): Sql => sql`${column} <=> ${vector}`,\n  };\n\n  // ============================================================\n  // GEOSPATIAL (PostGIS)\n  // ============================================================\n\n  geospatial = {\n    point: (lng: Sql, lat: Sql): Sql =>\n      sql`ST_SetSRID(ST_MakePoint(${lng}, ${lat}), 4326)`,\n\n    equals: (geom1: Sql, geom2: Sql): Sql => sql`ST_Equals(${geom1}, ${geom2})`,\n\n    intersects: (geom1: Sql, geom2: Sql): Sql =>\n      sql`ST_Intersects(${geom1}, ${geom2})`,\n\n    contains: (geom1: Sql, geom2: Sql): Sql =>\n      sql`ST_Contains(${geom1}, ${geom2})`,\n\n    within: (geom1: Sql, geom2: Sql): Sql => sql`ST_Within(${geom1}, ${geom2})`,\n\n    crosses: (geom1: Sql, geom2: Sql): Sql =>\n      sql`ST_Crosses(${geom1}, ${geom2})`,\n\n    overlaps: (geom1: Sql, geom2: Sql): Sql =>\n      sql`ST_Overlaps(${geom1}, ${geom2})`,\n\n    touches: (geom1: Sql, geom2: Sql): Sql =>\n      sql`ST_Touches(${geom1}, ${geom2})`,\n\n    covers: (geom1: Sql, geom2: Sql): Sql => sql`ST_Covers(${geom1}, ${geom2})`,\n\n    dWithin: (geom1: Sql, geom2: Sql, distance: Sql): Sql =>\n      sql`ST_DWithin(${geom1}::geography, ${geom2}::geography, ${distance})`,\n  };\n}\n\n// Export singleton instance\nexport const postgresAdapter = new PostgresAdapter();\n"],"mappings":"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"}