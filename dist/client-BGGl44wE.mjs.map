{"version":3,"file":"client-BGGl44wE.mjs","names":["sql","isSql","sql","sql","sql","sql","sql","sql","sql","sql","currentHoldsFK","sql","sql","sql","buildFindUniqueQuery","updateSql"],"sources":["../src/schema/hydration.ts","../src/query-engine/context/alias-generator.ts","../src/query-engine/context/query-context.ts","../src/query-engine/types.ts","../src/query-engine/builders/correlation-utils.ts","../src/schema/relation/helpers.ts","../src/query-engine/builders/many-to-many-utils.ts","../src/query-engine/builders/relation-filter-builder.ts","../src/query-engine/builders/where-builder.ts","../src/query-engine/builders/relation-data-builder.ts","../src/query-engine/builders/values-builder.ts","../src/query-engine/builders/nested-create-builder.ts","../src/query-engine/builders/aggregate-utils.ts","../src/query-engine/operations/aggregate.ts","../src/query-engine/operations/count.ts","../src/query-engine/builders/orderby-builder.ts","../src/query-engine/builders/include-builder.ts","../src/query-engine/builders/select-builder.ts","../src/query-engine/operations/create.ts","../src/query-engine/operations/delete.ts","../src/query-engine/operations/find-common.ts","../src/query-engine/operations/find-first.ts","../src/query-engine/operations/find-many.ts","../src/query-engine/operations/find-unique.ts","../src/query-engine/operations/groupby.ts","../src/query-engine/operations/nested-writes.ts","../src/query-engine/builders/set-builder.ts","../src/query-engine/operations/update.ts","../src/query-engine/operations/upsert.ts","../src/query-engine/result/result-parser.ts","../src/query-engine/validator.ts","../src/query-engine/query-engine.ts","../src/client/client.ts"],"sourcesContent":["/**\n * Schema Hydration\n *\n * Hydrates schema name slots (tsName, sqlName) for models, fields, and relations.\n * This is called once at client initialization when the full schema context is available.\n *\n * - tsName: The TypeScript key name in the schema (e.g., \"email\", \"User\")\n * - sqlName: The resolved database name (e.g., \"email_column\", \"users\")\n *\n * Names are stored in the model's nameRegistry, not on the field/relation instances.\n * This allows the same field to be reused across multiple models with different keys.\n */\n\nimport type { Field } from \"./fields/base\";\nimport type { SchemaNames } from \"./fields/common\";\nimport type { Model, NameRegistry } from \"./model\";\nimport type { AnyRelation } from \"./relation\";\n\n/**\n * Schema type - record of model names to Model instances\n */\nexport type Schema = Record<string, Model<any>>;\n\n/**\n * Hydrate name slots for all models, fields, and relations in a schema.\n *\n * This function populates the model's nameRegistry:\n * - model[\"~\"].names.ts = schema key (e.g., \"User\")\n * - model[\"~\"].names.sql = tableName ?? schema key (e.g., \"users\")\n * - model[\"~\"].nameRegistry.fields.get(fieldKey) = {ts, sql}\n * - model[\"~\"].nameRegistry.relations.get(relationKey) = {ts, sql}\n *\n * Note: Full schemas are built lazily when first accessed via model[\"~\"].schemas.\n * This allows circular references to work correctly - thunks are evaluated\n * at validation time when all models' schemas are available.\n *\n * @param schema - The schema object mapping model names to Model instances\n */\nexport function hydrateSchemaNames(schema: Schema): void {\n  for (const [modelKey, model] of Object.entries(schema)) {\n    hydrateModel(modelKey, model);\n  }\n}\n\n/**\n * Hydrate a single model and its fields/relations\n */\nfunction hydrateModel(modelKey: string, model: Model<any>): void {\n  const names = model[\"~\"].names as SchemaNames;\n  const state = model[\"~\"].state;\n  const registry = model[\"~\"].nameRegistry as NameRegistry;\n\n  // Set model names\n  names.ts = modelKey;\n  names.sql = state.tableName ?? modelKey;\n\n  // Hydrate scalar fields into model's nameRegistry\n  for (const [fieldKey, field] of Object.entries(\n    state.scalars as Record<string, Field>\n  )) {\n    const fieldNames: SchemaNames = {\n      ts: fieldKey,\n      sql: field[\"~\"].state.columnName ?? fieldKey,\n    };\n    registry.fields.set(fieldKey, fieldNames);\n  }\n\n  // Hydrate relations into model's nameRegistry\n  for (const [relationKey] of Object.entries(\n    state.relations as Record<string, AnyRelation>\n  )) {\n    const relationNames: SchemaNames = {\n      ts: relationKey,\n      // Relations don't have column mapping - sql name equals ts name\n      sql: relationKey,\n    };\n    registry.relations.set(relationKey, relationNames);\n  }\n\n  // Note: Schemas are built lazily on first access to model[\"~\"].schemas\n  // No explicit buildSchemas() call needed\n}\n\n/**\n * Check if a schema has been hydrated\n */\nexport function isSchemaHydrated(schema: Schema): boolean {\n  const firstModel = Object.values(schema)[0];\n  if (!firstModel) {\n    return true;\n  } // Empty schema is considered hydrated\n  return firstModel[\"~\"].names.ts !== undefined;\n}\n\n/**\n * Get the SQL name for a model (throws if not hydrated)\n */\nexport function getModelSqlName(model: Model<any>): string {\n  const sqlName = model[\"~\"].names.sql;\n  if (!sqlName) {\n    throw new Error(\n      \"Schema not hydrated. Call hydrateSchemaNames() or create a client first.\"\n    );\n  }\n  return sqlName;\n}\n\n/**\n * Get the SQL name for a field.\n * Delegates to model[\"~\"].getFieldName().\n */\nexport function getFieldSqlName(model: Model<any>, fieldKey: string): string {\n  return model[\"~\"].getFieldName(fieldKey).sql;\n}\n\n/**\n * Get the SQL name for a relation.\n * Delegates to model[\"~\"].getRelationName().\n */\nexport function getRelationSqlName(\n  model: Model<any>,\n  relationKey: string\n): string {\n  return model[\"~\"].getRelationName(relationKey).sql;\n}\n","/**\n * Alias Generator\n *\n * Generates sequential table aliases: t0, t1, t2...\n * Used to create unique aliases for tables and subqueries.\n */\n\nexport class AliasGenerator {\n  private counter = 0;\n\n  /**\n   * Get the next alias (t0, t1, t2, ...)\n   */\n  next(): string {\n    return `t${this.counter++}`;\n  }\n\n  /**\n   * Get the root alias (always t0)\n   */\n  root(): string {\n    return \"t0\";\n  }\n\n  /**\n   * Get the current alias without incrementing\n   */\n  current(): string {\n    return `t${Math.max(0, this.counter - 1)}`;\n  }\n\n  /**\n   * Reset the generator (useful for testing)\n   */\n  reset(): void {\n    this.counter = 0;\n  }\n\n  /**\n   * Create a child generator that continues from current state\n   * Useful for nested subqueries that need their own alias space\n   */\n  fork(): AliasGenerator {\n    const child = new AliasGenerator();\n    child.counter = this.counter;\n    return child;\n  }\n}\n\n/**\n * Create a new alias generator\n */\nexport const createAliasGenerator = (): AliasGenerator => new AliasGenerator();\n","/**\n * Query Context\n *\n * Holds shared state for query building: adapter, model, aliases, registry.\n */\n\nimport type { DatabaseAdapter } from \"@adapters\";\nimport type { Model } from \"@schema/model\";\nimport type { ModelRegistry, QueryContext, RelationInfo } from \"../types\";\nimport { createAliasGenerator } from \"./alias-generator\";\n\n/**\n * Create a query context for building queries\n */\nexport function createQueryContext(\n  adapter: DatabaseAdapter,\n  model: Model<any>,\n  registry: ModelRegistry\n): QueryContext {\n  const aliasGenerator = createAliasGenerator();\n  // Reserve t0 for root\n  const rootAlias = aliasGenerator.next();\n\n  return {\n    adapter,\n    model,\n    registry,\n    nextAlias: () => aliasGenerator.next(),\n    rootAlias,\n  };\n}\n\n/**\n * Create a child context for nested queries (relations)\n * Inherits adapter and registry, but uses a different model and alias space\n */\nexport function createChildContext(\n  parent: QueryContext,\n  model: Model<any>,\n  alias: string\n): QueryContext {\n  return {\n    adapter: parent.adapter,\n    model,\n    registry: parent.registry,\n    nextAlias: parent.nextAlias,\n    rootAlias: alias,\n  };\n}\n\n/**\n * Get relation info from a model\n */\nexport function getRelationInfo(\n  ctx: QueryContext,\n  relationName: string\n): RelationInfo | undefined {\n  const relations = ctx.model[\"~\"].state.relations;\n  const relation = relations[relationName];\n  if (!relation) return undefined;\n\n  const state = relation[\"~\"].state;\n  const targetModel = state.getter();\n\n  // Determine relation type\n  const isToMany = state.type === \"oneToMany\" || state.type === \"manyToMany\";\n  const isToOne = state.type === \"oneToOne\" || state.type === \"manyToOne\";\n\n  return {\n    name: relationName,\n    relation,\n    targetModel,\n    type: state.type,\n    isToMany,\n    isToOne,\n    isOptional: state.optional ?? false,\n    fields: state.fields,\n    references: state.references,\n  };\n}\n\n/**\n * Get table name for a model using hydrated names or tableName from state.\n */\nexport function getTableName(model: Model<any>): string {\n  // First check hydrated names, then tableName from state, then fall back to model name\n  return model[\"~\"].names.sql ?? model[\"~\"].state.tableName ?? \"unknown\";\n}\n\n/**\n * Get all scalar field names from a model\n */\nexport function getScalarFieldNames(model: Model<any>): string[] {\n  return Object.keys(model[\"~\"].state.scalars);\n}\n\n/**\n * Get all relation names from a model\n */\nexport function getRelationNames(model: Model<any>): string[] {\n  return Object.keys(model[\"~\"].state.relations);\n}\n\n/**\n * Check if a field name is a scalar field\n */\nexport function isScalarField(model: Model<any>, fieldName: string): boolean {\n  return fieldName in model[\"~\"].state.scalars;\n}\n\n/**\n * Check if a field name is a relation\n */\nexport function isRelation(model: Model<any>, fieldName: string): boolean {\n  return fieldName in model[\"~\"].state.relations;\n}\n\n/**\n * Get the actual database column name for a field\n * Uses the model's nameRegistry to resolve names (supports field reuse across models).\n * Falls back to field's .map() columnName or the field name itself.\n *\n * @param model - The model containing the field\n * @param fieldName - The field name in the schema\n * @returns The actual column name (from registry, .map(), or the field name itself)\n */\nexport function getColumnName(model: Model<any>, fieldName: string): string {\n  // Use model's getFieldName helper which checks nameRegistry first\n  return model[\"~\"].getFieldName(fieldName).sql;\n}\n","/**\n * Query Engine Types\n *\n * Shared types used across the query engine.\n */\n\nimport type { DatabaseAdapter } from \"@adapters\";\nimport type { Model } from \"@schema/model\";\nimport type { AnyRelation } from \"@schema/relation\";\n\n// Re-export Sql for convenience\nexport { Sql } from \"@sql\";\n\n/**\n * All supported operations\n */\nexport type Operation =\n  | \"findFirst\"\n  | \"findMany\"\n  | \"findUnique\"\n  | \"create\"\n  | \"createMany\"\n  | \"update\"\n  | \"updateMany\"\n  | \"delete\"\n  | \"deleteMany\"\n  | \"upsert\"\n  | \"count\"\n  | \"aggregate\"\n  | \"groupBy\"\n  | \"exist\";\n\n/** Operations that return BatchPayload { count: number } */\nexport const BATCH_OPERATIONS = [\n  \"createMany\",\n  \"updateMany\",\n  \"deleteMany\",\n] as const;\nexport type BatchOperation = (typeof BATCH_OPERATIONS)[number];\n\n/** Check if operation is a batch operation */\nexport function isBatchOperation(op: Operation): op is BatchOperation {\n  return (BATCH_OPERATIONS as readonly string[]).includes(op);\n}\n\n/**\n * Model registry for accessing related models\n */\nexport interface ModelRegistry {\n  get(name: string): Model<any> | undefined;\n  getByTableName(tableName: string): Model<any> | undefined;\n}\n\n/**\n * Query context passed to all builders\n */\nexport interface QueryContext {\n  /** Database adapter for SQL generation */\n  adapter: DatabaseAdapter;\n  /** Current model being queried */\n  model: Model<any>;\n  /** Model registry for relation lookups */\n  registry: ModelRegistry;\n  /** Alias generator for table aliases */\n  nextAlias: () => string;\n  /** Get root alias (t0) */\n  rootAlias: string;\n}\n\n/**\n * Relation info extracted from model for query building\n */\nexport interface RelationInfo {\n  name: string;\n  relation: AnyRelation;\n  targetModel: Model<any>;\n  /** Relation type: oneToOne, oneToMany, manyToOne, manyToMany */\n  type: \"oneToOne\" | \"oneToMany\" | \"manyToOne\" | \"manyToMany\";\n  isToMany: boolean;\n  isToOne: boolean;\n  isOptional: boolean;\n  /** Foreign key fields on current model */\n  fields: string[] | undefined;\n  /** Referenced fields on target model */\n  references: string[] | undefined;\n}\n\n/**\n * Validation error thrown when input doesn't match schema\n */\nexport class ValidationError extends Error {\n  constructor(\n    public readonly operation: Operation,\n    public readonly details: string\n  ) {\n    super(`Validation failed for ${operation}: ${details}`);\n    this.name = \"ValidationError\";\n  }\n}\n\n/**\n * Query engine error for runtime issues\n */\nexport class QueryEngineError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"QueryEngineError\";\n  }\n}\n\n/**\n * Error thrown during nested write operations\n * Provides context about which relation failed\n */\nexport class NestedWriteError extends QueryEngineError {\n  constructor(\n    message: string,\n    public readonly relation: string,\n    public readonly cause?: Error\n  ) {\n    super(message);\n    this.name = \"NestedWriteError\";\n    // Preserve the original stack trace if available\n    if (cause?.stack) {\n      this.stack = `${this.stack}\\nCaused by: ${cause.stack}`;\n    }\n  }\n}\n\n// ============================================================\n// NARROWER TYPE DEFINITIONS\n// These provide better autocomplete and error messages\n// ============================================================\n\n/**\n * Scalar filter operators for where clauses\n */\nexport interface ScalarFilter<T = unknown> {\n  equals?: T | null;\n  not?: T | ScalarFilter<T> | null;\n  in?: T[];\n  notIn?: T[];\n  lt?: T;\n  lte?: T;\n  gt?: T;\n  gte?: T;\n}\n\n/**\n * String-specific filter operators\n */\nexport interface StringFilter extends ScalarFilter<string> {\n  contains?: string;\n  startsWith?: string;\n  endsWith?: string;\n  mode?: \"default\" | \"insensitive\";\n}\n\n/**\n * Array/list filter operators\n */\nexport interface ArrayFilter<T = unknown> {\n  has?: T;\n  hasEvery?: T[];\n  hasSome?: T[];\n  isEmpty?: boolean;\n}\n\n/**\n * Relation filter for to-one relations\n */\nexport interface ToOneRelationFilter {\n  is?: WhereInput | null;\n  isNot?: WhereInput | null;\n}\n\n/**\n * Relation filter for to-many relations\n */\nexport interface ToManyRelationFilter {\n  some?: WhereInput;\n  every?: WhereInput;\n  none?: WhereInput;\n}\n\n/**\n * Where input for filtering records\n */\nexport interface WhereInput {\n  AND?: WhereInput | WhereInput[];\n  OR?: WhereInput[];\n  NOT?: WhereInput | WhereInput[];\n  [field: string]:\n    | unknown\n    | ScalarFilter\n    | StringFilter\n    | ArrayFilter\n    | ToOneRelationFilter\n    | ToManyRelationFilter\n    | WhereInput\n    | WhereInput[]\n    | undefined;\n}\n\n/**\n * Order by direction\n */\nexport type SortOrder = \"asc\" | \"desc\";\n\n/**\n * Order by input for sorting\n */\nexport interface OrderByInput {\n  [field: string]: SortOrder | OrderByInput;\n}\n\n/**\n * Select input for field selection\n */\nexport interface SelectInput {\n  [field: string]: boolean | SelectInput | IncludeInput;\n}\n\n/**\n * Include input for relation inclusion\n */\nexport interface IncludeInput {\n  [relation: string]:\n    | boolean\n    | {\n        select?: SelectInput;\n        include?: IncludeInput;\n        where?: WhereInput;\n        orderBy?: OrderByInput | OrderByInput[];\n        take?: number;\n        skip?: number;\n      };\n}\n\n/**\n * Numeric update operations\n */\nexport interface NumericUpdateOperations<T = number> {\n  set?: T;\n  increment?: T;\n  decrement?: T;\n  multiply?: T;\n  divide?: T;\n}\n\n/**\n * Array update operations\n */\nexport interface ArrayUpdateOperations<T = unknown> {\n  set?: T[];\n  push?: T | T[];\n}\n\n/**\n * Update data input\n */\nexport interface UpdateInput {\n  [field: string]: unknown | NumericUpdateOperations | ArrayUpdateOperations;\n}\n\n/**\n * Create data input\n */\nexport interface CreateInput {\n  [field: string]: unknown;\n}\n\n/**\n * Aggregate filter for HAVING clause\n */\nexport interface AggregateFilter {\n  equals?: number;\n  not?: number | null;\n  gt?: number;\n  gte?: number;\n  lt?: number;\n  lte?: number;\n  in?: number[];\n  notIn?: number[];\n}\n\n/**\n * Having input for groupBy\n */\nexport interface HavingInput {\n  _count?: Record<string, AggregateFilter>;\n  _avg?: Record<string, AggregateFilter>;\n  _sum?: Record<string, AggregateFilter>;\n  _min?: Record<string, AggregateFilter>;\n  _max?: Record<string, AggregateFilter>;\n  [field: string]:\n    | unknown\n    | AggregateFilter\n    | Record<string, AggregateFilter>\n    | undefined;\n}\n","/**\n * Correlation Utilities\n *\n * Shared utilities for building correlation conditions between\n * parent and related tables in relation queries.\n */\n\nimport type { Model } from \"@schema/model\";\nimport type { Sql } from \"@sql\";\nimport { getColumnName } from \"../context\";\nimport type { QueryContext, RelationInfo } from \"../types\";\nimport { QueryEngineError } from \"../types\";\n\n/**\n * Build correlation condition between parent and related table.\n *\n * For manyToOne relations: uses fields/references directly\n * For oneToMany/oneToOne: finds inverse relation on target model to get FK info\n * For manyToMany: will need junction table handling (not yet implemented)\n *\n * @param ctx - Query context\n * @param relationInfo - Relation metadata\n * @param parentAlias - Parent table alias\n * @param relatedAlias - Related table alias\n * @returns SQL condition for correlation\n * @throws QueryEngineError if unable to determine correlation\n */\nexport function buildCorrelation(\n  ctx: QueryContext,\n  relationInfo: RelationInfo,\n  parentAlias: string,\n  relatedAlias: string\n): Sql {\n  const { adapter } = ctx;\n  const state = relationInfo.relation[\"~\"].state;\n\n  // Get field names for correlation - either from this relation or inverse\n  let parentFields: string[];\n  let relatedFields: string[];\n\n  const fields = state.fields;\n  const references = state.references;\n\n  if (fields && references && fields.length > 0 && references.length > 0) {\n    // This relation has explicit fields/references (typically manyToOne)\n    parentFields = fields;\n    relatedFields = references;\n  } else if (state.type === \"oneToMany\" || state.type === \"oneToOne\") {\n    // For oneToMany/oneToOne without explicit fields, find the inverse manyToOne\n    const inverseInfo = findInverseRelation(ctx, relationInfo);\n    if (!inverseInfo) {\n      throw new QueryEngineError(\n        `Relation '${relationInfo.name}' on model '${getModelName(ctx.model)}' requires an inverse relation ` +\n          `on '${getModelName(relationInfo.targetModel)}' with explicit 'fields' and 'references'.`\n      );\n    }\n    // For oneToMany: parent.id = related.authorId\n    // The inverse relation has: fields = [authorId], references = [id]\n    // So we need: parent's references = related's fields\n    parentFields = inverseInfo.references;\n    relatedFields = inverseInfo.fields;\n  } else if (state.type === \"manyToMany\") {\n    // manyToMany requires junction table - not yet implemented\n    throw new QueryEngineError(\n      `Many-to-many relation '${relationInfo.name}' requires junction table handling (not yet implemented).`\n    );\n  } else {\n    throw new QueryEngineError(\n      `Relation '${relationInfo.name}' on model '${getModelName(ctx.model)}' must define 'fields' and 'references' explicitly.`\n    );\n  }\n\n  if (parentFields.length !== relatedFields.length) {\n    throw new QueryEngineError(\n      `Relation '${relationInfo.name}' has mismatched fields (${parentFields.length}) and references (${relatedFields.length}).`\n    );\n  }\n\n  // Build equality conditions for each field/reference pair\n  const conditions: Sql[] = [];\n  for (let i = 0; i < parentFields.length; i++) {\n    const parentColumnName = getColumnName(ctx.model, parentFields[i]!);\n    const relatedColumnName = getColumnName(\n      relationInfo.targetModel,\n      relatedFields[i]!\n    );\n    const parentCol = adapter.identifiers.column(parentAlias, parentColumnName);\n    const relatedCol = adapter.identifiers.column(\n      relatedAlias,\n      relatedColumnName\n    );\n    conditions.push(adapter.operators.eq(parentCol, relatedCol));\n  }\n\n  return conditions.length === 1\n    ? conditions[0]!\n    : adapter.operators.and(...conditions);\n}\n\n/**\n * Find the inverse relation on the target model that points back to the source model.\n * Returns the fields/references from the inverse relation.\n */\nfunction findInverseRelation(\n  ctx: QueryContext,\n  relationInfo: RelationInfo\n): { fields: string[]; references: string[] } | undefined {\n  const targetModel = relationInfo.targetModel;\n  const sourceModel = ctx.model;\n  const targetRelations = targetModel[\"~\"].state.relations;\n\n  // Look for a relation on target that points to source\n  for (const [, relation] of Object.entries(targetRelations)) {\n    const relState = (relation as any)[\"~\"].state;\n    const relTarget = relState.getter();\n\n    // Check if this relation points back to our source model\n    if (relTarget === sourceModel) {\n      const fields = relState.fields;\n      const references = relState.references;\n      if (fields && references && fields.length > 0 && references.length > 0) {\n        return { fields, references };\n      }\n    }\n  }\n\n  return undefined;\n}\n\n/**\n * Get model name for error messages\n */\nfunction getModelName(model: Model<any>): string {\n  return model[\"~\"].names.ts ?? model[\"~\"].state.tableName ?? \"unknown\";\n}\n\n/**\n * Get primary key field name from a model.\n *\n * Checks for:\n * 1. Field marked as id (isId: true)\n * 2. Compound ID (first field)\n * 3. Falls back to \"id\" as default\n *\n * @param model - Model to inspect\n * @returns Primary key field name\n */\nexport function getPrimaryKeyField(model: Model<any>): string {\n  const scalars = model[\"~\"].state.scalars;\n\n  // Check for field marked as id\n  for (const [name, field] of Object.entries(scalars)) {\n    if ((field as any)[\"~\"].state.isId) {\n      return name;\n    }\n  }\n\n  // Check for compound ID\n  const compoundId = model[\"~\"].state.compoundId;\n  if (compoundId) {\n    const keys = Object.keys(compoundId);\n    if (keys.length > 0) {\n      return keys[0]!;\n    }\n  }\n\n  // Default to \"id\"\n  return \"id\";\n}\n\n/**\n * Get all primary key fields from a model.\n *\n * Returns array of field names that make up the primary key.\n * For single-field PKs returns single element array.\n * For compound PKs returns all fields.\n *\n * @param model - Model to inspect\n * @returns Array of primary key field names\n */\nexport function getPrimaryKeyFields(model: Model<any>): string[] {\n  const scalars = model[\"~\"].state.scalars;\n\n  // Check for compound ID first\n  const compoundId = model[\"~\"].state.compoundId;\n  if (compoundId) {\n    const keys = Object.keys(compoundId);\n    if (keys.length > 0) {\n      return keys;\n    }\n  }\n\n  // Check for field marked as id\n  for (const [name, field] of Object.entries(scalars)) {\n    if ((field as any)[\"~\"].state.isId) {\n      return [name];\n    }\n  }\n\n  // Default to \"id\"\n  return [\"id\"];\n}\n","// Relation Helpers\n// Junction table utility functions for many-to-many relations\n\nimport type { ManyToManyRelationState, RelationState } from \"./types\";\n\n// =============================================================================\n// JUNCTION TABLE HELPERS\n// =============================================================================\n\n/** Any object with [\"~\"].state matching RelationState */\ntype RelationLike = { \"~\": { state: RelationState } };\n\n/**\n * Generate a junction table name from two model names\n * Names are sorted alphabetically and joined with underscore\n *\n * @example\n * generateJunctionTableName(\"post\", \"tag\") // \"post_tag\"\n * generateJunctionTableName(\"user\", \"role\") // \"role_user\"\n */\nexport function generateJunctionTableName(\n  model1: string,\n  model2: string\n): string {\n  const names = [model1.toLowerCase(), model2.toLowerCase()].sort();\n  return `${names[0]}_${names[1]}`;\n}\n\n/**\n * Generate a junction field name from a model name\n *\n * @example\n * generateJunctionFieldName(\"post\") // \"postId\"\n * generateJunctionFieldName(\"User\") // \"userId\"\n */\nexport function generateJunctionFieldName(modelName: string): string {\n  return `${modelName.toLowerCase()}Id`;\n}\n\n/**\n * Get the junction table name for a many-to-many relation\n * Uses explicit .through() value if set, otherwise generates from model names\n */\nexport function getJunctionTableName(\n  relation: RelationLike,\n  sourceModelName: string,\n  targetModelName: string\n): string {\n  const state = relation[\"~\"].state;\n  if (state.type === \"manyToMany\" && state.through) {\n    return state.through;\n  }\n  return generateJunctionTableName(sourceModelName, targetModelName);\n}\n\n/**\n * Get the junction field names for a many-to-many relation\n * Returns [sourceFieldName, targetFieldName]\n * Uses explicit .A()/.B() values if set, otherwise generates from model names\n */\nexport function getJunctionFieldNames(\n  relation: RelationLike,\n  sourceModelName: string,\n  targetModelName: string\n): [string, string] {\n  const state = relation[\"~\"].state as ManyToManyRelationState;\n  const sourceFieldName = state.A || generateJunctionFieldName(sourceModelName);\n  const targetFieldName = state.B || generateJunctionFieldName(targetModelName);\n  return [sourceFieldName, targetFieldName];\n}\n","/**\n * Many-to-Many Junction Utilities\n *\n * Shared logic for building M2M join conditions.\n * Used by: select-builder, relation-filter-builder, include-builder\n */\n\nimport {\n  getJunctionFieldNames,\n  getJunctionTableName,\n} from \"@schema/relation/helpers\";\nimport { type Sql, sql } from \"@sql\";\nimport { getTableName } from \"../context\";\nimport type { QueryContext, RelationInfo } from \"../types\";\nimport { getPrimaryKeyField } from \"./correlation-utils\";\n\n/**\n * Junction table metadata for a many-to-many relation\n */\nexport interface ManyToManyJoinInfo {\n  junctionTableName: string;\n  sourceFieldName: string;\n  targetFieldName: string;\n  sourcePkField: string;\n  targetPkField: string;\n  targetTableName: string;\n}\n\n/**\n * Get junction table metadata for a many-to-many relation\n */\nexport function getManyToManyJoinInfo(\n  ctx: QueryContext,\n  relationInfo: RelationInfo\n): ManyToManyJoinInfo {\n  const sourceModelName = ctx.model[\"~\"].names.ts ?? \"unknown\";\n  const targetModelName = relationInfo.targetModel[\"~\"].names.ts ?? \"unknown\";\n\n  const junctionTableName = getJunctionTableName(\n    relationInfo.relation,\n    sourceModelName,\n    targetModelName\n  );\n  const [sourceFieldName, targetFieldName] = getJunctionFieldNames(\n    relationInfo.relation,\n    sourceModelName,\n    targetModelName\n  );\n\n  const sourcePkField = getPrimaryKeyField(ctx.model);\n  const targetPkField = getPrimaryKeyField(relationInfo.targetModel);\n  const targetTableName = getTableName(relationInfo.targetModel);\n\n  return {\n    junctionTableName,\n    sourceFieldName,\n    targetFieldName,\n    sourcePkField,\n    targetPkField,\n    targetTableName,\n  };\n}\n\n/**\n * Build the standard M2M join conditions\n *\n * @returns correlationCondition: jt.sourceId = parent.id\n * @returns joinCondition: target.id = jt.targetId\n * @returns fromClause: junction_table jt, target_table t\n */\nexport function buildManyToManyJoinParts(\n  ctx: QueryContext,\n  joinInfo: ManyToManyJoinInfo,\n  parentAlias: string,\n  junctionAlias: string,\n  targetAlias: string\n): {\n  correlationCondition: Sql;\n  joinCondition: Sql;\n  fromClause: Sql;\n} {\n  const { adapter } = ctx;\n  const {\n    junctionTableName,\n    sourceFieldName,\n    targetFieldName,\n    sourcePkField,\n    targetPkField,\n    targetTableName,\n  } = joinInfo;\n\n  // 1. Correlation: jt.sourceId = parent.id\n  const junctionSourceCol = adapter.identifiers.column(\n    junctionAlias,\n    sourceFieldName\n  );\n  const parentPkCol = adapter.identifiers.column(parentAlias, sourcePkField);\n  const correlationCondition = adapter.operators.eq(\n    junctionSourceCol,\n    parentPkCol\n  );\n\n  // 2. Join: target.id = jt.targetId\n  const targetPkCol = adapter.identifiers.column(targetAlias, targetPkField);\n  const junctionTargetCol = adapter.identifiers.column(\n    junctionAlias,\n    targetFieldName\n  );\n  const joinCondition = adapter.operators.eq(targetPkCol, junctionTargetCol);\n\n  // 3. FROM clause\n  const fromClause = sql`${adapter.identifiers.table(junctionTableName, junctionAlias)}, ${adapter.identifiers.table(targetTableName, targetAlias)}`;\n\n  return { correlationCondition, joinCondition, fromClause };\n}\n","/**\n * Relation Filter Builder\n *\n * Builds EXISTS/NOT EXISTS subqueries for relation filters:\n * - some: EXISTS (any matching record)\n * - every: NOT EXISTS with negated condition (all must match)\n * - none: NOT EXISTS (no matching record)\n * - is: EXISTS for to-one (record matches)\n * - isNot: NOT EXISTS for to-one (record doesn't match)\n */\n\nimport { type Sql, sql } from \"@sql\";\nimport { createChildContext, getTableName } from \"../context\";\nimport type { QueryContext, RelationInfo } from \"../types\";\nimport { buildCorrelation } from \"./correlation-utils\";\nimport {\n  buildManyToManyJoinParts,\n  getManyToManyJoinInfo,\n} from \"./many-to-many-utils\";\nimport { buildWhere } from \"./where-builder\";\n\n/**\n * Build a relation filter (some, every, none, is, isNot)\n *\n * @param ctx - Query context\n * @param relationInfo - Relation metadata\n * @param filter - Filter object (may contain some/every/none or direct filter)\n * @param parentAlias - Parent table alias for correlation\n * @returns SQL condition or undefined\n */\nexport function buildRelationFilter(\n  ctx: QueryContext,\n  relationInfo: RelationInfo,\n  filter: Record<string, unknown>,\n  parentAlias: string\n): Sql | undefined {\n  // Schema validation normalizes { author: null } to { author: { is: null } }\n  // So we never receive null directly here\n\n  // Note: Schema validation may create objects with all keys present but undefined values.\n  // We must check for !== undefined, not just \"key in filter\".\n\n  // To-many relations use some/every/none (normalized by schema validation)\n  if (relationInfo.isToMany) {\n    if (filter.some !== undefined) {\n      return buildSomeFilter(\n        ctx,\n        relationInfo,\n        filter.some as Record<string, unknown>,\n        parentAlias\n      );\n    }\n    if (filter.every !== undefined) {\n      return buildEveryFilter(\n        ctx,\n        relationInfo,\n        filter.every as Record<string, unknown>,\n        parentAlias\n      );\n    }\n    if (filter.none !== undefined) {\n      return buildNoneFilter(\n        ctx,\n        relationInfo,\n        filter.none as Record<string, unknown>,\n        parentAlias\n      );\n    }\n    // No fallback - schema validation guarantees explicit form\n    return undefined;\n  }\n\n  // To-one relations use is/isNot (normalized by schema validation)\n  if (relationInfo.isToOne) {\n    if (filter.is !== undefined) {\n      const isValue = filter.is;\n      if (isValue === null) {\n        return buildIsNullFilter(ctx, relationInfo, parentAlias);\n      }\n      return buildIsFilter(\n        ctx,\n        relationInfo,\n        isValue as Record<string, unknown>,\n        parentAlias\n      );\n    }\n    if (filter.isNot !== undefined) {\n      const isNotValue = filter.isNot;\n      if (isNotValue === null) {\n        return buildIsNotNullFilter(ctx, relationInfo, parentAlias);\n      }\n      return buildIsNotFilter(\n        ctx,\n        relationInfo,\n        isNotValue as Record<string, unknown>,\n        parentAlias\n      );\n    }\n    // No fallback - schema validation guarantees explicit form\n  }\n\n  return undefined;\n}\n\n/**\n * Build \"some\" filter: EXISTS (SELECT 1 FROM related WHERE correlation AND inner_where)\n */\nfunction buildSomeFilter(\n  ctx: QueryContext,\n  relationInfo: RelationInfo,\n  innerWhere: Record<string, unknown> | undefined,\n  parentAlias: string\n): Sql {\n  const subquery = buildCorrelatedSubquery(\n    ctx,\n    relationInfo,\n    innerWhere,\n    parentAlias,\n    false\n  );\n  return ctx.adapter.filters.some(subquery);\n}\n\n/**\n * Build \"every\" filter: NOT EXISTS (SELECT 1 FROM related WHERE correlation AND NOT(inner_where))\n * This means: there's no related record that does NOT match the condition\n */\nfunction buildEveryFilter(\n  ctx: QueryContext,\n  relationInfo: RelationInfo,\n  innerWhere: Record<string, unknown> | undefined,\n  parentAlias: string\n): Sql {\n  const subquery = buildCorrelatedSubquery(\n    ctx,\n    relationInfo,\n    innerWhere,\n    parentAlias,\n    true\n  );\n  return ctx.adapter.filters.every(subquery);\n}\n\n/**\n * Build \"none\" filter: NOT EXISTS (SELECT 1 FROM related WHERE correlation AND inner_where)\n */\nfunction buildNoneFilter(\n  ctx: QueryContext,\n  relationInfo: RelationInfo,\n  innerWhere: Record<string, unknown> | undefined,\n  parentAlias: string\n): Sql {\n  const subquery = buildCorrelatedSubquery(\n    ctx,\n    relationInfo,\n    innerWhere,\n    parentAlias,\n    false\n  );\n  return ctx.adapter.filters.none(subquery);\n}\n\n/**\n * Build \"is\" filter (to-one): EXISTS (SELECT 1 FROM related WHERE correlation AND inner_where)\n */\nfunction buildIsFilter(\n  ctx: QueryContext,\n  relationInfo: RelationInfo,\n  innerWhere: Record<string, unknown>,\n  parentAlias: string\n): Sql {\n  const subquery = buildCorrelatedSubquery(\n    ctx,\n    relationInfo,\n    innerWhere,\n    parentAlias,\n    false\n  );\n  return ctx.adapter.filters.is(subquery);\n}\n\n/**\n * Build \"isNot\" filter (to-one): NOT EXISTS (SELECT 1 FROM related WHERE correlation AND inner_where)\n */\nfunction buildIsNotFilter(\n  ctx: QueryContext,\n  relationInfo: RelationInfo,\n  innerWhere: Record<string, unknown>,\n  parentAlias: string\n): Sql {\n  const subquery = buildCorrelatedSubquery(\n    ctx,\n    relationInfo,\n    innerWhere,\n    parentAlias,\n    false\n  );\n  return ctx.adapter.filters.isNot(subquery);\n}\n\n/**\n * Build \"is null\" filter for to-one: FK IS NULL\n */\nfunction buildIsNullFilter(\n  ctx: QueryContext,\n  relationInfo: RelationInfo,\n  parentAlias: string\n): Sql {\n  // For to-one relations, check if the FK field is null\n  const fkField = relationInfo.fields?.[0];\n  if (fkField) {\n    const column = ctx.adapter.identifiers.column(parentAlias, fkField);\n    return ctx.adapter.operators.isNull(column);\n  }\n\n  // Fallback: NOT EXISTS subquery\n  const subquery = buildCorrelatedSubquery(\n    ctx,\n    relationInfo,\n    undefined,\n    parentAlias,\n    false\n  );\n  return ctx.adapter.operators.notExists(subquery);\n}\n\n/**\n * Build \"is not null\" filter for to-one: FK IS NOT NULL\n */\nfunction buildIsNotNullFilter(\n  ctx: QueryContext,\n  relationInfo: RelationInfo,\n  parentAlias: string\n): Sql {\n  // For to-one relations, check if the FK field is not null\n  const fkField = relationInfo.fields?.[0];\n  if (fkField) {\n    const column = ctx.adapter.identifiers.column(parentAlias, fkField);\n    return ctx.adapter.operators.isNotNull(column);\n  }\n\n  // Fallback: EXISTS subquery\n  const subquery = buildCorrelatedSubquery(\n    ctx,\n    relationInfo,\n    undefined,\n    parentAlias,\n    false\n  );\n  return ctx.adapter.operators.exists(subquery);\n}\n\n/**\n * Build a correlated subquery for relation filters\n *\n * @param ctx - Query context\n * @param relationInfo - Relation metadata\n * @param innerWhere - Inner where conditions (optional)\n * @param parentAlias - Parent table alias\n * @param negateInner - Whether to negate the inner where (for \"every\")\n */\nfunction buildCorrelatedSubquery(\n  ctx: QueryContext,\n  relationInfo: RelationInfo,\n  innerWhere: Record<string, unknown> | undefined,\n  parentAlias: string,\n  negateInner: boolean\n): Sql {\n  const { adapter } = ctx;\n\n  // Handle manyToMany specially - requires junction table\n  if (relationInfo.type === \"manyToMany\") {\n    return buildManyToManySubquery(\n      ctx,\n      relationInfo,\n      innerWhere,\n      parentAlias,\n      negateInner\n    );\n  }\n\n  const relatedAlias = ctx.nextAlias();\n  const relatedTableName = getTableName(relationInfo.targetModel);\n\n  // Build correlation condition (throws if fields/references not defined)\n  const correlation = buildCorrelation(\n    ctx,\n    relationInfo,\n    parentAlias,\n    relatedAlias\n  );\n\n  // Build inner where condition\n  const childCtx = createChildContext(\n    ctx,\n    relationInfo.targetModel,\n    relatedAlias\n  );\n  let innerCondition = buildWhere(childCtx, innerWhere, relatedAlias);\n\n  // Negate inner condition for \"every\" filter\n  if (negateInner && innerCondition) {\n    innerCondition = adapter.operators.not(innerCondition);\n  }\n\n  // Combine correlation and inner condition\n  const conditions: Sql[] = [correlation];\n  if (innerCondition) {\n    conditions.push(innerCondition);\n  }\n\n  const whereClause = adapter.operators.and(...conditions);\n\n  // Build the subquery: SELECT 1 FROM related WHERE ...\n  return adapter.subqueries.existsCheck(\n    adapter.identifiers.table(relatedTableName, relatedAlias),\n    whereClause\n  );\n}\n\n/**\n * Build a correlated subquery for manyToMany relation filters.\n *\n * SQL pattern:\n * SELECT 1 FROM junction_table jt, target_table t\n * WHERE jt.sourceId = parent.id AND t.id = jt.targetId AND [inner conditions on t]\n */\nfunction buildManyToManySubquery(\n  ctx: QueryContext,\n  relationInfo: RelationInfo,\n  innerWhere: Record<string, unknown> | undefined,\n  parentAlias: string,\n  negateInner: boolean\n): Sql {\n  const { adapter } = ctx;\n\n  const junctionAlias = ctx.nextAlias();\n  const targetAlias = ctx.nextAlias();\n\n  const joinInfo = getManyToManyJoinInfo(ctx, relationInfo);\n  const { correlationCondition, joinCondition, fromClause } =\n    buildManyToManyJoinParts(\n      ctx,\n      joinInfo,\n      parentAlias,\n      junctionAlias,\n      targetAlias\n    );\n\n  // Build inner where on target\n  const childCtx = createChildContext(\n    ctx,\n    relationInfo.targetModel,\n    targetAlias\n  );\n  let innerCondition = buildWhere(childCtx, innerWhere, targetAlias);\n\n  // Negate inner condition for \"every\" filter\n  if (negateInner && innerCondition) {\n    innerCondition = adapter.operators.not(innerCondition);\n  }\n\n  const conditions: Sql[] = [correlationCondition, joinCondition];\n  if (innerCondition) {\n    conditions.push(innerCondition);\n  }\n\n  const whereClause = adapter.operators.and(...conditions);\n\n  return sql`SELECT 1 FROM ${fromClause} WHERE ${whereClause}`;\n}\n","/**\n * Where Builder\n *\n * Builds WHERE clauses from filter objects.\n * Handles scalar filters, logical operators (AND/OR/NOT),\n * and delegates relation filters to relation-filter-builder.\n */\n\nimport { type Sql, sql } from \"@sql\";\nimport {\n  getColumnName,\n  getRelationInfo,\n  isRelation,\n  isScalarField,\n} from \"../context\";\nimport type { QueryContext } from \"../types\";\nimport { buildRelationFilter } from \"./relation-filter-builder\";\n\n/**\n * Build a WHERE clause from a where input object\n *\n * @param ctx - Query context\n * @param where - Where input object\n * @param alias - Current table alias\n * @returns SQL for WHERE clause or undefined if no conditions\n */\nexport function buildWhere(\n  ctx: QueryContext,\n  where: Record<string, unknown> | undefined,\n  alias: string\n): Sql | undefined {\n  if (!where || Object.keys(where).length === 0) {\n    return undefined;\n  }\n\n  const conditions: Sql[] = [];\n\n  for (const [key, value] of Object.entries(where)) {\n    if (value === undefined) {\n      continue;\n    }\n\n    // Handle logical operators\n    if (key === \"AND\") {\n      const andCondition = buildLogicalAnd(ctx, value, alias);\n      if (andCondition) {\n        conditions.push(andCondition);\n      }\n      continue;\n    }\n\n    if (key === \"OR\") {\n      const orCondition = buildLogicalOr(ctx, value, alias);\n      if (orCondition) {\n        conditions.push(orCondition);\n      }\n      continue;\n    }\n\n    if (key === \"NOT\") {\n      const notCondition = buildLogicalNot(ctx, value, alias);\n      if (notCondition) {\n        conditions.push(notCondition);\n      }\n      continue;\n    }\n\n    // Handle scalar field filters\n    if (isScalarField(ctx.model, key)) {\n      const fieldCondition = buildScalarFilter(ctx, key, value, alias);\n      if (fieldCondition) {\n        conditions.push(fieldCondition);\n      }\n      continue;\n    }\n\n    // Handle relation filters\n    if (isRelation(ctx.model, key)) {\n      const relationInfo = getRelationInfo(ctx, key);\n      if (relationInfo) {\n        const relationCondition = buildRelationFilter(\n          ctx,\n          relationInfo,\n          value as Record<string, unknown>,\n          alias\n        );\n        if (relationCondition) {\n          conditions.push(relationCondition);\n        }\n      }\n    }\n  }\n\n  if (conditions.length === 0) {\n    return undefined;\n  }\n\n  return ctx.adapter.operators.and(...conditions);\n}\n\n/**\n * Build AND logical operator\n */\nfunction buildLogicalAnd(\n  ctx: QueryContext,\n  value: unknown,\n  alias: string\n): Sql | undefined {\n  const items = Array.isArray(value) ? value : [value];\n  const conditions: Sql[] = [];\n\n  for (const item of items) {\n    const condition = buildWhere(ctx, item as Record<string, unknown>, alias);\n    if (condition) {\n      conditions.push(condition);\n    }\n  }\n\n  if (conditions.length === 0) {\n    return undefined;\n  }\n  return ctx.adapter.operators.and(...conditions);\n}\n\n/**\n * Build OR logical operator\n */\nfunction buildLogicalOr(\n  ctx: QueryContext,\n  value: unknown,\n  alias: string\n): Sql | undefined {\n  if (!Array.isArray(value)) {\n    return undefined;\n  }\n\n  const conditions: Sql[] = [];\n\n  for (const item of value) {\n    const condition = buildWhere(ctx, item as Record<string, unknown>, alias);\n    if (condition) {\n      conditions.push(condition);\n    }\n  }\n\n  if (conditions.length === 0) {\n    return undefined;\n  }\n  return ctx.adapter.operators.or(...conditions);\n}\n\n/**\n * Build NOT logical operator\n */\nfunction buildLogicalNot(\n  ctx: QueryContext,\n  value: unknown,\n  alias: string\n): Sql | undefined {\n  const items = Array.isArray(value) ? value : [value];\n  const conditions: Sql[] = [];\n\n  for (const item of items) {\n    const condition = buildWhere(ctx, item as Record<string, unknown>, alias);\n    if (condition) {\n      conditions.push(condition);\n    }\n  }\n\n  if (conditions.length === 0) {\n    return undefined;\n  }\n\n  const combined = ctx.adapter.operators.and(...conditions);\n  return ctx.adapter.operators.not(combined);\n}\n\n/** Filter mode for case sensitivity */\ntype FilterMode = \"default\" | \"insensitive\";\n\n/**\n * Build a scalar field filter\n *\n * Schema validation normalizes all values to filter objects:\n * - Simple values become { equals: value }\n * - null becomes { equals: null }\n */\nfunction buildScalarFilter(\n  ctx: QueryContext,\n  fieldName: string,\n  value: unknown,\n  alias: string\n): Sql | undefined {\n  // Resolve field name to actual column name (handles .map() overrides)\n  const columnName = getColumnName(ctx.model, fieldName);\n  const column = ctx.adapter.identifiers.column(alias, columnName);\n\n  // Schema validation guarantees value is always a filter object\n  if (typeof value !== \"object\" || value === null) {\n    throw new Error(\n      `Filter for '${fieldName}' must be a filter object (schema validation should have normalized this)`\n    );\n  }\n\n  // Filter object with operations like equals, contains, gt, etc.\n  const filter = value as Record<string, unknown>;\n  const conditions: Sql[] = [];\n\n  // Extract mode for case-insensitive operations\n  const mode: FilterMode =\n    filter.mode === \"insensitive\" ? \"insensitive\" : \"default\";\n\n  for (const [op, opValue] of Object.entries(filter)) {\n    if (opValue === undefined) {\n      continue;\n    }\n    if (op === \"mode\") {\n      continue; // Skip mode itself, it's a modifier\n    }\n\n    const condition = buildFilterOperation(ctx, column, op, opValue, mode);\n    if (condition) {\n      conditions.push(condition);\n    }\n  }\n\n  if (conditions.length === 0) {\n    return undefined;\n  }\n  return ctx.adapter.operators.and(...conditions);\n}\n\n/**\n * Build a single filter operation\n *\n * @param ctx - Query context\n * @param column - Column SQL expression\n * @param operation - Filter operation name\n * @param value - Filter value\n * @param mode - Case sensitivity mode (default or insensitive)\n */\nfunction buildFilterOperation(\n  ctx: QueryContext,\n  column: Sql,\n  operation: string,\n  value: unknown,\n  mode: FilterMode = \"default\"\n): Sql | undefined {\n  const { adapter } = ctx;\n  const lit = (v: unknown) => adapter.literals.value(v);\n  const isInsensitive = mode === \"insensitive\";\n\n  switch (operation) {\n    // Equality\n    case \"equals\":\n      if (value === null) {\n        return adapter.operators.isNull(column);\n      }\n      return adapter.operators.eq(column, lit(value));\n\n    case \"not\":\n      if (value === null) {\n        return adapter.operators.isNotNull(column);\n      }\n      if (typeof value === \"object\" && value !== null) {\n        // Nested filter: { not: { contains: \"foo\" } }\n        const nested = buildScalarFilterObject(\n          ctx,\n          column,\n          value as Record<string, unknown>,\n          mode\n        );\n        return nested ? adapter.operators.not(nested) : undefined;\n      }\n      return adapter.operators.neq(column, lit(value));\n\n    // Comparison\n    case \"lt\":\n      return adapter.operators.lt(column, lit(value));\n\n    case \"lte\":\n      return adapter.operators.lte(column, lit(value));\n\n    case \"gt\":\n      return adapter.operators.gt(column, lit(value));\n\n    case \"gte\":\n      return adapter.operators.gte(column, lit(value));\n\n    // Set membership\n    case \"in\": {\n      if (!Array.isArray(value) || value.length === 0) {\n        return undefined;\n      }\n      const inValues = value.map((v) => lit(v));\n      return adapter.operators.in(column, adapter.literals.list(inValues));\n    }\n\n    case \"notIn\": {\n      if (!Array.isArray(value) || value.length === 0) {\n        return undefined;\n      }\n      const notInValues = value.map((v) => lit(v));\n      return adapter.operators.notIn(\n        column,\n        adapter.literals.list(notInValues)\n      );\n    }\n\n    // String operations (respect case sensitivity mode)\n    case \"contains\": {\n      const containsPattern = sql`${`%${String(value)}%`}`;\n      return isInsensitive\n        ? adapter.operators.ilike(column, containsPattern)\n        : adapter.operators.like(column, containsPattern);\n    }\n\n    case \"startsWith\": {\n      const startsPattern = sql`${`${String(value)}%`}`;\n      return isInsensitive\n        ? adapter.operators.ilike(column, startsPattern)\n        : adapter.operators.like(column, startsPattern);\n    }\n\n    case \"endsWith\": {\n      const endsPattern = sql`${`%${String(value)}`}`;\n      return isInsensitive\n        ? adapter.operators.ilike(column, endsPattern)\n        : adapter.operators.like(column, endsPattern);\n    }\n\n    // Array operations (for array/list fields)\n    case \"has\":\n      return adapter.arrays.has(column, lit(value));\n\n    case \"hasEvery\":\n      if (!Array.isArray(value)) {\n        return undefined;\n      }\n      return adapter.arrays.hasEvery(\n        column,\n        adapter.arrays.literal(value.map(lit))\n      );\n\n    case \"hasSome\":\n      if (!Array.isArray(value)) {\n        return undefined;\n      }\n      return adapter.arrays.hasSome(\n        column,\n        adapter.arrays.literal(value.map(lit))\n      );\n\n    case \"isEmpty\":\n      return value\n        ? adapter.arrays.isEmpty(column)\n        : adapter.operators.not(adapter.arrays.isEmpty(column));\n\n    default:\n      // Unknown operation, skip\n      return undefined;\n  }\n}\n\n/**\n * Build a filter from an object (for nested not operations)\n */\nfunction buildScalarFilterObject(\n  ctx: QueryContext,\n  column: Sql,\n  filter: Record<string, unknown>,\n  mode: FilterMode = \"default\"\n): Sql | undefined {\n  const conditions: Sql[] = [];\n\n  // Nested filter may also have mode\n  const nestedMode: FilterMode =\n    filter.mode === \"insensitive\" ? \"insensitive\" : mode;\n\n  for (const [op, value] of Object.entries(filter)) {\n    if (value === undefined) {\n      continue;\n    }\n    if (op === \"mode\") {\n      continue; // Skip mode itself\n    }\n    const condition = buildFilterOperation(ctx, column, op, value, nestedMode);\n    if (condition) {\n      conditions.push(condition);\n    }\n  }\n\n  if (conditions.length === 0) {\n    return undefined;\n  }\n  return ctx.adapter.operators.and(...conditions);\n}\n\n/**\n * Build WHERE from a unique input (for findUnique, update, delete)\n * Unique input can be a single field or compound key\n *\n * Handles:\n * - Single field: { id: \"123\" }\n * - Compound ID: { email_orgId: { email: \"a@b.com\", orgId: \"org1\" } }\n * - Named compound: { uq_name_org: { name: \"Alice\", orgId: \"org1\" } }\n */\nexport function buildWhereUnique(\n  ctx: QueryContext,\n  where: Record<string, unknown>,\n  alias: string\n): Sql | undefined {\n  const conditions: Sql[] = [];\n\n  for (const [key, value] of Object.entries(where)) {\n    if (value === undefined) {\n      continue;\n    }\n\n    // Check if this is a compound key (object value with multiple fields)\n    if (typeof value === \"object\" && value !== null && !Array.isArray(value)) {\n      // Compound key: { email_orgId: { email: \"a@b.com\", orgId: \"org1\" } }\n      const compound = value as Record<string, unknown>;\n      for (const [fieldName, fieldValue] of Object.entries(compound)) {\n        if (fieldValue === undefined) {\n          continue;\n        }\n        // Resolve field name to actual column name (handles .map() overrides)\n        const columnName = getColumnName(ctx.model, fieldName);\n        const column = ctx.adapter.identifiers.column(alias, columnName);\n        conditions.push(\n          ctx.adapter.operators.eq(\n            column,\n            ctx.adapter.literals.value(fieldValue)\n          )\n        );\n      }\n    } else {\n      // Single field: { id: \"123\" }\n      // Resolve field name to actual column name (handles .map() overrides)\n      const columnName = getColumnName(ctx.model, key);\n      const column = ctx.adapter.identifiers.column(alias, columnName);\n      conditions.push(\n        ctx.adapter.operators.eq(column, ctx.adapter.literals.value(value))\n      );\n    }\n  }\n\n  if (conditions.length === 0) {\n    return undefined;\n  }\n  return ctx.adapter.operators.and(...conditions);\n}\n","/**\n * Relation Data Builder\n *\n * Handles nested write operations: connect, disconnect, create, connectOrCreate, delete.\n * Separates scalar and relation data, builds connect subqueries, and manages FK direction.\n */\n\nimport type { Model } from \"@schema/model\";\nimport type { AnyRelation } from \"@schema/relation\";\nimport { type Sql, sql } from \"@sql\";\nimport {\n  createChildContext,\n  getColumnName,\n  getRelationInfo,\n  getTableName,\n  isRelation,\n} from \"../context\";\nimport type { QueryContext, RelationInfo } from \"../types\";\nimport { NestedWriteError, QueryEngineError } from \"../types\";\nimport { getPrimaryKeyFields } from \"./correlation-utils\";\nimport { buildWhereUnique } from \"./where-builder\";\n\n// ============================================================\n// TYPES\n// ============================================================\n\n/**\n * Separated scalar and relation data from input\n */\nexport interface SeparatedData {\n  /** Scalar fields to INSERT/UPDATE directly */\n  scalar: Record<string, unknown>;\n  /** Relation mutations to process */\n  relations: Record<string, RelationMutation>;\n}\n\n/**\n * A single relation mutation operation\n */\nexport interface RelationMutation {\n  /** Relation metadata */\n  relationInfo: RelationInfo;\n  /** Connect to existing record(s) */\n  connect?: Record<string, unknown> | Record<string, unknown>[];\n  /** Disconnect from related record(s) */\n  disconnect?: boolean | Record<string, unknown> | Record<string, unknown>[];\n  /** Create new related record(s) */\n  create?: Record<string, unknown> | Record<string, unknown>[];\n  /** Connect if exists, otherwise create */\n  connectOrCreate?: ConnectOrCreateInput | ConnectOrCreateInput[];\n  /** Delete related record(s) */\n  delete?: boolean | Record<string, unknown> | Record<string, unknown>[];\n  /** Set (replace) related records - only for to-many */\n  set?: Record<string, unknown>[];\n}\n\n/**\n * ConnectOrCreate input shape\n */\nexport interface ConnectOrCreateInput {\n  where: Record<string, unknown>;\n  create: Record<string, unknown>;\n}\n\n/**\n * Information about FK direction for a relation\n */\nexport interface FkDirection {\n  /** Does current model hold the FK? */\n  holdsFK: boolean;\n  /** FK field names on FK holder */\n  fkFields: string[];\n  /** PK field names on referenced model */\n  pkFields: string[];\n  /** Which model holds the FK */\n  fkHolder: Model<any>;\n  /** Which model is referenced */\n  referenced: Model<any>;\n}\n\n// ============================================================\n// SEPARATING DATA\n// ============================================================\n\n/**\n * Separate scalar data from relation mutations\n *\n * @param ctx - Query context\n * @param data - Input data with mixed scalar and relation fields\n * @returns Separated scalar and relation data\n */\nexport function separateData(\n  ctx: QueryContext,\n  data: Record<string, unknown>\n): SeparatedData {\n  const scalar: Record<string, unknown> = {};\n  const relations: Record<string, RelationMutation> = {};\n\n  for (const [key, value] of Object.entries(data)) {\n    if (value === undefined) {\n      continue;\n    }\n\n    if (isRelation(ctx.model, key)) {\n      const relationInfo = getRelationInfo(ctx, key);\n      if (!relationInfo) {\n        continue;\n      }\n\n      // Parse relation mutation\n      const mutation = parseRelationMutation(relationInfo, value);\n      if (mutation) {\n        relations[key] = mutation;\n      }\n    } else {\n      // Scalar field\n      scalar[key] = value;\n    }\n  }\n\n  return { scalar, relations };\n}\n\n/**\n * Parse a relation value into a RelationMutation\n */\nfunction parseRelationMutation(\n  relationInfo: RelationInfo,\n  value: unknown\n): RelationMutation | undefined {\n  if (value === null || typeof value !== \"object\") {\n    return undefined;\n  }\n\n  const input = value as Record<string, unknown>;\n  const mutation: RelationMutation = { relationInfo };\n\n  if (\"connect\" in input) {\n    mutation.connect = input.connect as\n      | Record<string, unknown>\n      | Record<string, unknown>[];\n  }\n\n  if (\"disconnect\" in input) {\n    mutation.disconnect = input.disconnect as\n      | boolean\n      | Record<string, unknown>\n      | Record<string, unknown>[];\n  }\n\n  if (\"create\" in input) {\n    mutation.create = input.create as\n      | Record<string, unknown>\n      | Record<string, unknown>[];\n  }\n\n  if (\"connectOrCreate\" in input) {\n    mutation.connectOrCreate = input.connectOrCreate as\n      | ConnectOrCreateInput\n      | ConnectOrCreateInput[];\n  }\n\n  if (\"delete\" in input) {\n    mutation.delete = input.delete as\n      | boolean\n      | Record<string, unknown>\n      | Record<string, unknown>[];\n  }\n\n  if (\"set\" in input) {\n    mutation.set = input.set as Record<string, unknown>[];\n  }\n\n  return mutation;\n}\n\n// ============================================================\n// FK DIRECTION\n// ============================================================\n\n/**\n * Find the FK fields on the target model by looking for the inverse relation\n *\n * Searches target model's relations for one pointing back to current model\n * and returns its fields (the actual FK columns).\n *\n * @param currentModel - Current model\n * @param targetModel - Target model to search in\n * @param relationName - Name of the relation (for error messages)\n * @returns FK field names on target model\n * @throws QueryEngineError if no inverse relation found\n */\nfunction findInverseFkFields(\n  currentModel: Model<any>,\n  targetModel: Model<any>,\n  relationName: string\n): string[] {\n  // Look through target model's relations for one pointing back to current\n  const targetRelations = targetModel[\"~\"].state.relations;\n  if (targetRelations) {\n    for (const [, rel] of Object.entries(targetRelations)) {\n      const relInternals = (rel as AnyRelation)[\"~\"];\n      // Check if this relation points back to current model\n      const relTarget = relInternals.state?.getter?.();\n      if (relTarget === currentModel && relInternals.state?.fields?.length) {\n        return relInternals.state.fields;\n      }\n    }\n  }\n\n  // No inverse found - this is a schema issue\n  throw new QueryEngineError(\n    `Cannot determine FK fields for relation '${relationName}'. ` +\n      \"Define the inverse relation with .fields([...]) or use explicit FK fields.\"\n  );\n}\n\n/**\n * Determine FK direction for a relation\n *\n * FK direction affects order of operations:\n * - If current model holds FK: create related first, then current\n * - If related model holds FK: create current first, then related\n *\n * @param ctx - Query context\n * @param relationInfo - Relation metadata\n * @returns FK direction info\n */\nexport function getFkDirection(\n  ctx: QueryContext,\n  relationInfo: RelationInfo\n): FkDirection {\n  const { fields, references, targetModel, name } = relationInfo;\n\n  // If fields defined on this relation, current model holds the FK\n  const holdsFK = !!(fields && fields.length > 0);\n\n  if (holdsFK) {\n    return {\n      holdsFK: true,\n      fkFields: fields!,\n      pkFields: references ?? getPrimaryKeyFields(targetModel),\n      fkHolder: ctx.model,\n      referenced: targetModel,\n    };\n  }\n\n  // Otherwise, the target model holds the FK (to-many from current's perspective)\n  // Look for the inverse relation to find the actual FK fields on target model\n  const inverseFkFields = findInverseFkFields(ctx.model, targetModel, name);\n\n  return {\n    holdsFK: false,\n    fkFields: inverseFkFields,\n    pkFields: getPrimaryKeyFields(ctx.model),\n    fkHolder: targetModel,\n    referenced: ctx.model,\n  };\n}\n\n// ============================================================\n// CONNECT SUBQUERY\n// ============================================================\n\n/**\n * Build a subquery to get FK value for a connect operation\n *\n * This allows connecting without a transaction:\n * INSERT INTO posts (title, author_id)\n * VALUES ('Hello', (SELECT id FROM users WHERE id = '123'))\n *\n * For compound FKs, this returns a subquery for a single field.\n * Use buildConnectFkValues() to get all FK field values.\n *\n * @param ctx - Query context\n * @param relationInfo - Relation metadata\n * @param connectInput - WhereUnique input for the record to connect\n * @param fieldIndex - Index of the FK field to get (default 0)\n * @returns Sql subquery that returns the FK value\n */\nexport function buildConnectSubquery(\n  ctx: QueryContext,\n  relationInfo: RelationInfo,\n  connectInput: Record<string, unknown>,\n  fieldIndex = 0\n): Sql {\n  const { adapter } = ctx;\n  const { targetModel, name } = relationInfo;\n  const fkDir = getFkDirection(ctx, relationInfo);\n\n  if (!fkDir.holdsFK) {\n    throw new NestedWriteError(\n      `Cannot use connect subquery for relation '${name}' - ` +\n        \"FK is on the related model. Use transaction-based connect instead.\",\n      name\n    );\n  }\n\n  // Build the subquery to select PK from target\n  const targetTable = getTableName(targetModel);\n  const subAlias = ctx.nextAlias();\n  const childCtx = createChildContext(ctx, targetModel, subAlias);\n\n  // Build WHERE clause from connect input\n  const whereClause = buildWhereUnique(childCtx, connectInput, subAlias);\n  if (!whereClause) {\n    throw new NestedWriteError(\n      `Invalid connect input for relation '${name}': no conditions`,\n      name\n    );\n  }\n\n  // Select the PK field at the specified index\n  const pkFields = fkDir.pkFields;\n  if (fieldIndex >= pkFields.length) {\n    throw new NestedWriteError(\n      `Invalid field index ${fieldIndex} for relation '${name}' with ${pkFields.length} PK fields`,\n      name\n    );\n  }\n\n  const pkColumn = getColumnName(targetModel, pkFields[fieldIndex]!);\n  const pkSql = adapter.identifiers.column(subAlias, pkColumn);\n  const tableSql = adapter.identifiers.escape(targetTable);\n\n  return sql`(SELECT ${pkSql} FROM ${tableSql} ${sql.raw([\n    subAlias,\n  ])} WHERE ${whereClause})`;\n}\n\n/**\n * Build FK assignments for a connect operation\n *\n * Returns a map of FK field -> subquery for each FK field.\n * Handles both single and compound FKs.\n *\n * @param ctx - Query context\n * @param relationInfo - Relation metadata\n * @param connectInput - WhereUnique input for the record to connect\n * @returns Map of FK field name to value/subquery\n */\nexport function buildConnectFkValues(\n  ctx: QueryContext,\n  relationInfo: RelationInfo,\n  connectInput: Record<string, unknown>\n): Record<string, Sql> {\n  const fkDir = getFkDirection(ctx, relationInfo);\n\n  if (!fkDir.holdsFK) {\n    // Can't assign FK - it's on the other side\n    return {};\n  }\n\n  const fkFields = fkDir.fkFields;\n  const pkFields = fkDir.pkFields;\n\n  if (fkFields.length !== pkFields.length) {\n    throw new NestedWriteError(\n      `FK/PK mismatch for relation '${relationInfo.name}': ` +\n        `${fkFields.length} FK fields, ${pkFields.length} PK fields`,\n      relationInfo.name\n    );\n  }\n\n  const result: Record<string, Sql> = {};\n\n  // Check if all PK values are directly provided in the connect input\n  const allPkValuesProvided = pkFields.every(\n    (pkField) => pkField in connectInput\n  );\n\n  if (allPkValuesProvided) {\n    // Simple case: all PK values provided directly - no subqueries needed\n    for (let i = 0; i < fkFields.length; i++) {\n      const fkField = fkFields[i]!;\n      const pkField = pkFields[i]!;\n      const value = connectInput[pkField];\n      result[fkField] = ctx.adapter.literals.value(value);\n    }\n  } else {\n    // Need subqueries to get the PK values\n    // For compound FKs, build a separate subquery for each FK field\n    for (let i = 0; i < fkFields.length; i++) {\n      const fkField = fkFields[i]!;\n      const pkField = pkFields[i]!;\n\n      // Check if this specific PK value is directly provided\n      if (pkField in connectInput) {\n        const value = connectInput[pkField];\n        result[fkField] = ctx.adapter.literals.value(value);\n      } else {\n        // Build subquery to select this specific PK field\n        result[fkField] = buildConnectSubqueryForField(\n          ctx,\n          relationInfo,\n          connectInput,\n          pkField\n        );\n      }\n    }\n  }\n\n  return result;\n}\n\n/**\n * Build subquery to select a specific field for connect\n */\nfunction buildConnectSubqueryForField(\n  ctx: QueryContext,\n  relationInfo: RelationInfo,\n  connectInput: Record<string, unknown>,\n  selectField: string\n): Sql {\n  const { adapter } = ctx;\n  const { targetModel } = relationInfo;\n\n  const targetTable = getTableName(targetModel);\n  const subAlias = ctx.nextAlias();\n  const childCtx = createChildContext(ctx, targetModel, subAlias);\n\n  const whereClause = buildWhereUnique(childCtx, connectInput, subAlias);\n  if (!whereClause) {\n    throw new NestedWriteError(\n      `Invalid connect input for relation '${relationInfo.name}'`,\n      relationInfo.name\n    );\n  }\n\n  const fieldColumn = getColumnName(targetModel, selectField);\n  const fieldSql = adapter.identifiers.column(subAlias, fieldColumn);\n  const tableSql = adapter.identifiers.escape(targetTable);\n\n  return sql`(SELECT ${fieldSql} FROM ${tableSql} ${sql.raw([\n    subAlias,\n  ])} WHERE ${whereClause})`;\n}\n\n// ============================================================\n// DISCONNECT\n// ============================================================\n\n/**\n * Build disconnect operation\n *\n * For to-one where current holds FK: SET FK to NULL\n * For to-many: handled via target model's FK\n *\n * @param ctx - Query context\n * @param relationInfo - Relation metadata\n * @param disconnectInput - true, or whereUnique for specific record\n * @returns FK field(s) to set to NULL, or undefined if FK is on other side\n */\nexport function buildDisconnectFkNulls(\n  ctx: QueryContext,\n  relationInfo: RelationInfo,\n  _disconnectInput: boolean | Record<string, unknown>\n): string[] | undefined {\n  const fkDir = getFkDirection(ctx, relationInfo);\n\n  if (!fkDir.holdsFK) {\n    // FK is on the other side - disconnect needs to UPDATE the related records\n    return undefined;\n  }\n\n  // Current model holds FK - return FK field names to set to NULL\n  return fkDir.fkFields;\n}\n\n// ============================================================\n// ANALYSIS HELPERS\n// ============================================================\n\n/**\n * Check if the current model holds the FK for a relation\n *\n * Simplified check that doesn't require full QueryContext.\n * For to-many relations (oneToMany), FK is always on the related model.\n * For to-one relations (manyToOne), FK is on current model if fields defined.\n *\n * @param relationInfo - Relation metadata\n * @returns true if current model holds FK, false if related model holds FK\n */\nfunction currentHoldsFK(relationInfo: RelationInfo): boolean {\n  // For to-many (oneToMany), FK is always on the related side\n  if (relationInfo.isToMany) {\n    return false;\n  }\n  // For to-one (manyToOne), check if fields are defined on current model\n  return !!(relationInfo.fields && relationInfo.fields.length > 0);\n}\n\n/**\n * Check if any relation mutations require a transaction\n *\n * Transactions needed for:\n * - create (need to get generated ID)\n * - connectOrCreate (check existence + create)\n * - disconnect/delete on to-many (update related records)\n * - set on to-many (delete existing + connect new)\n *\n * NOT needed for:\n * - connect when current model holds FK (use subquery)\n */\nexport function needsTransaction(\n  relations: Record<string, RelationMutation>\n): boolean {\n  for (const mutation of Object.values(relations)) {\n    // Create always needs transaction to get generated ID\n    if (mutation.create) {\n      return true;\n    }\n\n    // ConnectOrCreate needs transaction\n    if (mutation.connectOrCreate) {\n      return true;\n    }\n\n    // Delete on relations needs transaction\n    if (mutation.delete) {\n      return true;\n    }\n\n    // Set on to-many needs transaction\n    if (mutation.set) {\n      return true;\n    }\n\n    // Disconnect where FK is on other side needs transaction\n    if (mutation.disconnect && !currentHoldsFK(mutation.relationInfo)) {\n      return true;\n    }\n    // Connect where FK is on other side needs transaction\n    if (mutation.connect && !currentHoldsFK(mutation.relationInfo)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Check if relation mutations can be handled with subqueries only\n */\nexport function canUseSubqueryOnly(\n  relations: Record<string, RelationMutation>\n): boolean {\n  return !needsTransaction(relations);\n}\n\n/**\n * Get connect operations that can be done via subquery (FK on current model)\n */\nexport function getSubqueryConnects(\n  ctx: QueryContext,\n  relations: Record<string, RelationMutation>\n): Array<{ relationName: string; mutation: RelationMutation }> {\n  const result: Array<{ relationName: string; mutation: RelationMutation }> =\n    [];\n\n  for (const [relationName, mutation] of Object.entries(relations)) {\n    if (!mutation.connect) {\n      continue;\n    }\n\n    const fkDir = getFkDirection(ctx, mutation.relationInfo);\n    if (fkDir.holdsFK) {\n      result.push({ relationName, mutation });\n    }\n  }\n\n  return result;\n}\n","/**\n * Values Builder\n *\n * Builds VALUES clause for INSERT operations.\n * Handles scalar fields, defaults, and auto-generated values.\n */\n\nimport type { Sql } from \"@sql\";\nimport { getColumnName, getScalarFieldNames, isRelation } from \"../context\";\nimport type { QueryContext } from \"../types\";\nimport { QueryEngineError } from \"../types\";\n\ninterface ValuesResult {\n  columns: string[];\n  values: Sql[][];\n}\n\n/**\n * Build VALUES for INSERT from create data\n *\n * @param ctx - Query context\n * @param data - Create input data (single record or array)\n * @returns Object with columns (actual DB column names) and values arrays\n */\nexport function buildValues(\n  ctx: QueryContext,\n  data: Record<string, unknown> | Record<string, unknown>[]\n): ValuesResult {\n  const records = Array.isArray(data) ? data : [data];\n\n  if (records.length === 0) {\n    return { columns: [], values: [] };\n  }\n\n  // Get all scalar field names\n  const scalarFields = getScalarFieldNames(ctx.model);\n\n  // Determine which fields to include (all fields that have values in any record)\n  const fieldsSet = new Set<string>();\n\n  for (const record of records) {\n    for (const [key, value] of Object.entries(record)) {\n      if (value === undefined) {\n        continue;\n      }\n      if (isRelation(ctx.model, key)) {\n        continue; // Skip relations\n      }\n      if (scalarFields.includes(key)) {\n        fieldsSet.add(key);\n      }\n    }\n  }\n\n  // Check for auto-generated fields that weren't provided\n  for (const fieldName of scalarFields) {\n    const field = ctx.model[\"~\"].state.scalars[fieldName];\n    if (field) {\n      const state = field[\"~\"].state;\n      // Throw if field has auto-generate (uuid, ulid, cuid, etc.) but wasn't provided\n      // and doesn't have a database default\n      if (state?.autoGenerate && !fieldsSet.has(fieldName)) {\n        const genType = state.autoGenerate;\n        // Check if it's a supported database-level auto-generate\n        if (genType !== \"autoincrement\") {\n          throw new QueryEngineError(\n            `Auto-generated value '${genType}' for field '${fieldName}' must be provided explicitly or ` +\n              \"handled by the database. Application-level ID generation (uuid, ulid, cuid) is not yet implemented.\"\n          );\n        }\n      }\n    }\n  }\n\n  // Convert field names to arrays (keeping order for both)\n  const fieldNames = Array.from(fieldsSet);\n  // Map field names to actual column names (handles .map() overrides)\n  const columns = fieldNames.map((fieldName) =>\n    getColumnName(ctx.model, fieldName)\n  );\n\n  // Build values for each record\n  const values: Sql[][] = [];\n\n  for (const record of records) {\n    const row: Sql[] = [];\n\n    for (const fieldName of fieldNames) {\n      const value = record[fieldName];\n      row.push(buildFieldValue(ctx, fieldName, value));\n    }\n\n    values.push(row);\n  }\n\n  return { columns, values };\n}\n\n/**\n * Build value SQL for a single field, handling special types\n */\nfunction buildFieldValue(\n  ctx: QueryContext,\n  fieldName: string,\n  value: unknown\n): Sql {\n  if (value === undefined || value === null) {\n    return ctx.adapter.literals.null();\n  }\n\n  if (isSql(value)) {\n    // Pass through Sql values directly (e.g., subqueries from connect)\n    return value;\n  }\n\n  // Get field type if available\n  const field = ctx.model[\"~\"].state.scalars[fieldName];\n  const fieldType = field?.[\"~\"]?.state?.type;\n\n  // Handle JSON fields - adapter handles dialect-specific serialization\n  if (fieldType === \"json\" && typeof value === \"object\") {\n    return ctx.adapter.literals.json(value);\n  }\n\n  return ctx.adapter.literals.value(value);\n}\n\n/**\n * Check if a value is a Sql object\n */\nfunction isSql(value: unknown): value is Sql {\n  return (\n    value !== null &&\n    typeof value === \"object\" &&\n    \"strings\" in value &&\n    \"values\" in value &&\n    Array.isArray((value as Sql).strings) &&\n    Array.isArray((value as Sql).values)\n  );\n}\n\n/**\n * Build a single INSERT statement\n */\nexport function buildInsert(\n  ctx: QueryContext,\n  tableName: string,\n  data: Record<string, unknown>\n): Sql {\n  const { columns, values } = buildValues(ctx, data);\n\n  if (columns.length === 0) {\n    // No columns to insert - this shouldn't happen normally\n    throw new Error(\"No columns to insert\");\n  }\n\n  const table = ctx.adapter.identifiers.escape(tableName);\n  return ctx.adapter.mutations.insert(table, columns, values);\n}\n\n/**\n * Build INSERT for createMany\n */\nexport function buildInsertMany(\n  ctx: QueryContext,\n  tableName: string,\n  data: Record<string, unknown>[]\n): Sql {\n  const { columns, values } = buildValues(ctx, data);\n\n  if (columns.length === 0 || values.length === 0) {\n    throw new Error(\"No data to insert\");\n  }\n\n  const table = ctx.adapter.identifiers.escape(tableName);\n  return ctx.adapter.mutations.insert(table, columns, values);\n}\n","/**\n * Nested Create Builder\n *\n * Builds multi-statement SQL for nested create operations.\n * Uses a unified approach that works across all databases.\n *\n * ID Handling:\n * - App-generated IDs (UUID, ULID): literal value is used directly\n * - Auto-increment IDs: uses lastval() / last_insert_rowid() / LAST_INSERT_ID()\n *\n * Example output with app-generated ID:\n *   INSERT INTO \"Author\" (\"id\", \"name\") VALUES ($1, $2);\n *   INSERT INTO \"posts\" (\"id\", \"title\", \"authorId\") VALUES ($3, $4, $1);\n *   SELECT ... FROM \"Author\" WHERE \"id\" = $1;\n *\n * Example output with auto-increment (PostgreSQL):\n *   INSERT INTO \"Author\" (\"name\") VALUES ($1);\n *   INSERT INTO \"posts\" (\"id\", \"title\", \"authorId\") VALUES ($2, $3, lastval());\n *   SELECT ... FROM \"Author\" WHERE \"id\" = lastval();\n */\n\nimport type { Model } from \"@schema/model\";\nimport { type Sql, sql } from \"@sql\";\nimport {\n  createChildContext,\n  getColumnName,\n  getScalarFieldNames,\n  getTableName,\n} from \"../context\";\nimport type { QueryContext, RelationInfo } from \"../types\";\nimport { QueryEngineError } from \"../types\";\nimport { getPrimaryKeyField } from \"./correlation-utils\";\nimport {\n  getFkDirection,\n  type RelationMutation,\n  separateData,\n} from \"./relation-data-builder\";\nimport { buildValues } from \"./values-builder\";\n\n// ============================================================\n// TYPES\n// ============================================================\n\n/**\n * Result of building a nested create operation.\n * Always returns a single SQL with multiple statements joined by semicolons.\n */\nexport interface NestedCreateResult {\n  /** The generated SQL (multiple statements joined by ';') */\n  sql: Sql;\n  /** Whether nested creates were processed */\n  hasNestedCreates: boolean;\n  /** Number of statements (for result extraction in MySQL) */\n  statementCount: number;\n}\n\n/**\n * Info about a child create for aggregation in final SELECT\n */\ninterface ChildCreateInfo {\n  relationName: string;\n  relationInfo: RelationInfo;\n  model: Model<any>;\n  /** Number of child records created */\n  count: number;\n}\n\n// ============================================================\n// MAIN ENTRY POINT\n// ============================================================\n\n/**\n * Build a create operation that may include nested creates.\n *\n * Uses a unified multi-statement approach for all databases:\n * 1. INSERT parent record\n * 2. INSERT child records (using lastInsertId() or literal for FK)\n * 3. SELECT to return the created data\n *\n * @param ctx - Query context\n * @param data - Create data (may include nested creates)\n * @param select - Optional select\n * @param include - Optional include\n * @returns Result with SQL and metadata\n */\nexport function buildCreateWithNested(\n  ctx: QueryContext,\n  data: Record<string, unknown>,\n  select?: Record<string, unknown>,\n  include?: Record<string, unknown>\n): NestedCreateResult {\n  const { scalar, relations } = separateData(ctx, data);\n\n  // Find nested creates (relations where create is specified)\n  const nestedCreates = Object.entries(relations).filter(\n    ([, mutation]) => mutation.create !== undefined\n  );\n\n  if (nestedCreates.length === 0) {\n    // No nested creates - return simple INSERT with RETURNING\n    return {\n      sql: buildSimpleInsert(ctx, scalar, select, include),\n      hasNestedCreates: false,\n      statementCount: 1,\n    };\n  }\n\n  // Build multi-statement nested create\n  return buildMultiStatementCreate(ctx, scalar, nestedCreates, select, include);\n}\n\n// ============================================================\n// SIMPLE INSERT (no nested creates)\n// ============================================================\n\n/**\n * Build a simple INSERT statement (no nested creates)\n */\nfunction buildSimpleInsert(\n  ctx: QueryContext,\n  data: Record<string, unknown>,\n  select?: Record<string, unknown>,\n  include?: Record<string, unknown>\n): Sql {\n  const { adapter } = ctx;\n  const tableName = getTableName(ctx.model);\n\n  // Build VALUES\n  const { columns, values } = buildValues(ctx, data);\n\n  if (columns.length === 0) {\n    throw new QueryEngineError(\"No data to insert\");\n  }\n\n  // Build INSERT\n  const table = adapter.identifiers.escape(tableName);\n  const insertSql = adapter.mutations.insert(table, columns, values);\n\n  // Build RETURNING (if supported)\n  if (adapter.capabilities.supportsReturning) {\n    const returningCols = buildReturningColumns(ctx, select, \"\");\n    const returningSql = adapter.mutations.returning(returningCols);\n    if (returningSql.strings.join(\"\").trim() !== \"\") {\n      return sql`${insertSql} ${returningSql}`;\n    }\n  }\n\n  return insertSql;\n}\n\n/**\n * Build RETURNING columns for mutations\n */\nfunction buildReturningColumns(\n  ctx: QueryContext,\n  select: Record<string, unknown> | undefined,\n  alias: string\n): Sql {\n  const scalarFields = getScalarFieldNames(ctx.model);\n\n  if (select) {\n    // Select specific fields\n    const columns = scalarFields\n      .filter((field) => select[field] === true)\n      .map((field) => {\n        const columnName = getColumnName(ctx.model, field);\n        return ctx.adapter.identifiers.aliased(\n          alias\n            ? ctx.adapter.identifiers.column(alias, columnName)\n            : ctx.adapter.identifiers.escape(columnName),\n          field\n        );\n      });\n\n    if (columns.length === 0) {\n      return buildAllScalarColumns(ctx, alias);\n    }\n\n    return sql.join(columns, \", \");\n  }\n\n  return buildAllScalarColumns(ctx, alias);\n}\n\n/**\n * Build all scalar columns for RETURNING\n */\nfunction buildAllScalarColumns(ctx: QueryContext, alias: string): Sql {\n  const scalarFields = getScalarFieldNames(ctx.model);\n  const columns = scalarFields.map((field) => {\n    const columnName = getColumnName(ctx.model, field);\n    return ctx.adapter.identifiers.aliased(\n      alias\n        ? ctx.adapter.identifiers.column(alias, columnName)\n        : ctx.adapter.identifiers.escape(columnName),\n      field\n    );\n  });\n  return sql.join(columns, \", \");\n}\n\n// ============================================================\n// MULTI-STATEMENT NESTED CREATE\n// ============================================================\n\n/**\n * Build multi-statement nested create.\n *\n * Strategy:\n * 1. Determine creation order based on FK direction\n * 2. Build INSERT statements in dependency order\n * 3. Final SELECT to retrieve all data\n *\n * All statements are joined with ';' for multi-statement execution.\n */\nfunction buildMultiStatementCreate(\n  ctx: QueryContext,\n  parentScalar: Record<string, unknown>,\n  nestedCreates: [string, RelationMutation][],\n  select?: Record<string, unknown>,\n  include?: Record<string, unknown>\n): NestedCreateResult {\n  const { adapter } = ctx;\n  const statements: Sql[] = [];\n  const childCreateInfos: ChildCreateInfo[] = [];\n\n  // Get parent's PK field and check if it's provided\n  const parentPkField = getPrimaryKeyField(ctx.model);\n  const providedPkValue = parentScalar[parentPkField];\n\n  // Helper to get parent ID reference for child FKs\n  const getParentIdRef = (): Sql => {\n    if (providedPkValue !== undefined) {\n      // App-generated ID (UUID, ULID) - use literal\n      return adapter.literals.value(providedPkValue);\n    }\n    // Auto-increment - use lastInsertId()\n    return adapter.lastInsertId();\n  };\n\n  // Analyze FK directions to determine creation order\n  const childFirstCreates: [string, RelationMutation][] = [];\n  const parentFirstCreates: [string, RelationMutation][] = [];\n\n  for (const [relationName, mutation] of nestedCreates) {\n    const fkDir = getFkDirection(ctx, mutation.relationInfo);\n\n    if (fkDir.holdsFK) {\n      // Parent holds FK - need to create child first, then parent with FK\n      childFirstCreates.push([relationName, mutation]);\n    } else {\n      // Child holds FK - create parent first, then child with FK\n      parentFirstCreates.push([relationName, mutation]);\n    }\n  }\n\n  // ---- Handle child-first creates (parent holds FK) ----\n  // These are rare (e.g., to-one where parent references child)\n  // We need to INSERT child first, then reference its ID in parent\n  const parentDataWithFks = { ...parentScalar };\n\n  for (const [relationName, mutation] of childFirstCreates) {\n    const childDataArray = Array.isArray(mutation.create)\n      ? mutation.create\n      : [mutation.create];\n    const { targetModel } = mutation.relationInfo;\n    const childCtx = createChildContext(ctx, targetModel, \"\");\n    const childTableName = getTableName(targetModel);\n    const childTable = adapter.identifiers.escape(childTableName);\n    const fkDir = getFkDirection(ctx, mutation.relationInfo);\n\n    // Insert child first\n    for (let i = 0; i < childDataArray.length; i++) {\n      const childData = childDataArray[i];\n      if (!childData) continue;\n\n      const { columns, values } = buildValues(\n        childCtx,\n        childData as Record<string, unknown>\n      );\n      statements.push(adapter.mutations.insert(childTable, columns, values));\n    }\n\n    // Set FK on parent to reference child (using lastInsertId of child)\n    // This only works for single child creates; arrays would need special handling\n    if (childDataArray.length === 1) {\n      for (let i = 0; i < fkDir.fkFields.length; i++) {\n        const fkField = fkDir.fkFields[i]!;\n        // Check if child provided its own ID\n        const childData = childDataArray[0] as Record<string, unknown>;\n        const childPkField = getPrimaryKeyField(targetModel);\n        const childPkValue = childData?.[childPkField];\n\n        if (childPkValue !== undefined) {\n          parentDataWithFks[fkField] = childPkValue;\n        } else {\n          parentDataWithFks[fkField] = adapter.lastInsertId();\n        }\n      }\n    }\n\n    childCreateInfos.push({\n      relationName,\n      relationInfo: mutation.relationInfo,\n      model: targetModel,\n      count: childDataArray.filter(Boolean).length,\n    });\n  }\n\n  // ---- Insert parent ----\n  const parentTableName = getTableName(ctx.model);\n  const parentTable = adapter.identifiers.escape(parentTableName);\n  const { columns: parentColumns, values: parentValues } = buildValues(\n    ctx,\n    parentDataWithFks\n  );\n  statements.push(\n    adapter.mutations.insert(parentTable, parentColumns, parentValues)\n  );\n\n  // ---- Handle parent-first creates (child holds FK) ----\n  // Most common case: child has FK to parent\n  for (const [relationName, mutation] of parentFirstCreates) {\n    const childDataArray = Array.isArray(mutation.create)\n      ? mutation.create\n      : [mutation.create];\n    const { targetModel } = mutation.relationInfo;\n    const childCtx = createChildContext(ctx, targetModel, \"\");\n    const childTableName = getTableName(targetModel);\n    const childTable = adapter.identifiers.escape(childTableName);\n    const fkDir = getFkDirection(ctx, mutation.relationInfo);\n\n    // Group all children of this relation into a single multi-row INSERT\n    const allChildRows: Sql[][] = [];\n\n    for (const childData of childDataArray) {\n      if (!childData) continue;\n\n      // Add FK to child data\n      const childDataWithFk = { ...(childData as Record<string, unknown>) };\n      const fkField = fkDir.fkFields[0]!;\n      childDataWithFk[fkField] = getParentIdRef();\n\n      const { columns, values } = buildValues(childCtx, childDataWithFk);\n\n      // For multi-row INSERT, we need consistent columns\n      // Just add each as a separate INSERT for simplicity\n      // (Could optimize to single multi-row INSERT later)\n      statements.push(adapter.mutations.insert(childTable, columns, values));\n    }\n\n    childCreateInfos.push({\n      relationName,\n      relationInfo: mutation.relationInfo,\n      model: targetModel,\n      count: childDataArray.filter(Boolean).length,\n    });\n  }\n\n  // ---- Build final SELECT ----\n  const finalSelect = buildFinalSelect(\n    ctx,\n    getParentIdRef(),\n    childCreateInfos,\n    select,\n    include\n  );\n  statements.push(finalSelect);\n\n  return {\n    sql: sql.join(statements, \"; \"),\n    hasNestedCreates: true,\n    statementCount: statements.length,\n  };\n}\n\n/**\n * Build the final SELECT statement that returns the created parent record\n * with relation counts or data if requested\n */\nfunction buildFinalSelect(\n  ctx: QueryContext,\n  parentIdRef: Sql,\n  childCreateInfos: ChildCreateInfo[],\n  select?: Record<string, unknown>,\n  include?: Record<string, unknown>\n): Sql {\n  const { adapter } = ctx;\n  const tableName = getTableName(ctx.model);\n  const parentTable = adapter.identifiers.escape(tableName);\n  const parentPkField = getPrimaryKeyField(ctx.model);\n  const parentPkColumn = getColumnName(ctx.model, parentPkField);\n\n  // Build scalar columns\n  const scalarFields = getScalarFieldNames(ctx.model);\n  let columns: Sql[];\n\n  if (select) {\n    columns = scalarFields\n      .filter((field) => select[field] === true)\n      .map((field) => {\n        const columnName = getColumnName(ctx.model, field);\n        return adapter.identifiers.aliased(\n          adapter.identifiers.escape(columnName),\n          field\n        );\n      });\n\n    if (columns.length === 0) {\n      columns = scalarFields.map((field) => {\n        const columnName = getColumnName(ctx.model, field);\n        return adapter.identifiers.aliased(\n          adapter.identifiers.escape(columnName),\n          field\n        );\n      });\n    }\n  } else {\n    columns = scalarFields.map((field) => {\n      const columnName = getColumnName(ctx.model, field);\n      return adapter.identifiers.aliased(\n        adapter.identifiers.escape(columnName),\n        field\n      );\n    });\n  }\n\n  // Check if relations should be included\n  const requestedRelations = getRequestedRelations(select, include);\n\n  // Add relation subqueries for included relations\n  for (const childInfo of childCreateInfos) {\n    const relationConfig = requestedRelations[childInfo.relationName];\n    if (relationConfig) {\n      const relationSubquery = buildRelationSubquery(\n        ctx,\n        childInfo,\n        relationConfig,\n        parentIdRef\n      );\n      columns.push(\n        adapter.identifiers.aliased(relationSubquery, childInfo.relationName)\n      );\n    }\n  }\n\n  const columnsSql = sql.join(columns, \", \");\n  const whereSql = sql`${adapter.identifiers.escape(\n    parentPkColumn\n  )} = ${parentIdRef}`;\n\n  return sql`SELECT ${columnsSql} FROM ${parentTable} WHERE ${whereSql}`;\n}\n\n/**\n * Extract which relations are requested from select/include\n */\nfunction getRequestedRelations(\n  select?: Record<string, unknown>,\n  include?: Record<string, unknown>\n): Record<string, unknown> {\n  const result: Record<string, unknown> = {};\n\n  if (select) {\n    for (const [key, value] of Object.entries(select)) {\n      if (value && typeof value === \"object\" && \"select\" in value) {\n        result[key] = value;\n      } else if (value === true) {\n        result[key] = true;\n      }\n    }\n  }\n\n  if (include) {\n    for (const [key, value] of Object.entries(include)) {\n      if (value) {\n        result[key] = value;\n      }\n    }\n  }\n\n  return result;\n}\n\n/**\n * Build a subquery to fetch the newly created related records\n */\nfunction buildRelationSubquery(\n  ctx: QueryContext,\n  childInfo: ChildCreateInfo,\n  config: unknown,\n  parentIdRef: Sql\n): Sql {\n  const { adapter } = ctx;\n  const { model, relationInfo } = childInfo;\n\n  // Get the FK direction to know how to correlate\n  const fkDir = getFkDirection(ctx, relationInfo);\n  const childTableName = getTableName(model);\n  const childTable = adapter.identifiers.escape(childTableName);\n  const childAlias = \"_child\";\n\n  // Get fields to select\n  const childScalarFields = getScalarFieldNames(model);\n  let fieldsToSelect: string[];\n\n  if (typeof config === \"object\" && config !== null && \"select\" in config) {\n    const selectConfig = (config as { select: Record<string, boolean> }).select;\n    fieldsToSelect = childScalarFields.filter((f) => selectConfig[f] === true);\n    if (fieldsToSelect.length === 0) {\n      fieldsToSelect = childScalarFields;\n    }\n  } else {\n    fieldsToSelect = childScalarFields;\n  }\n\n  // Build JSON object pairs\n  const jsonPairs: [string, Sql][] = fieldsToSelect.map((field) => {\n    const columnName = getColumnName(model, field);\n    return [field, adapter.identifiers.column(childAlias, columnName)];\n  });\n\n  const jsonObj = adapter.json.object(jsonPairs);\n\n  // Build correlation condition\n  const fkField = fkDir.fkFields[0]!;\n  const fkColumn = getColumnName(model, fkField);\n  const correlation = sql`${adapter.identifiers.column(\n    childAlias,\n    fkColumn\n  )} = ${parentIdRef}`;\n\n  // Build subquery\n  if (relationInfo.isToMany) {\n    // Return array\n    return sql`(SELECT COALESCE(${adapter.json.agg(\n      jsonObj\n    )}, ${adapter.json.emptyArray()}) FROM ${childTable} AS ${adapter.identifiers.escape(\n      childAlias\n    )} WHERE ${correlation})`;\n  }\n  // Return single object\n  return sql`(SELECT ${jsonObj} FROM ${childTable} AS ${adapter.identifiers.escape(\n    childAlias\n  )} WHERE ${correlation} LIMIT 1)`;\n}\n","/**\n * Aggregate Utilities\n *\n * Shared helpers for building aggregate expressions.\n * Used by both aggregate and groupBy operations.\n */\n\nimport type { Sql } from \"@sql\";\nimport { getColumnName } from \"../context\";\nimport type { QueryContext } from \"../types\";\n\n/**\n * Aggregate function types\n */\nexport type AggregateType = \"count\" | \"avg\" | \"sum\" | \"min\" | \"max\";\n\n/**\n * Build _count aggregate expression\n *\n * Accepts:\n * - true: count all rows (COUNT(*))\n * - { _all: true, fieldName: true, ... }: count specific fields wrapped in JSON\n *\n * @param ctx - Query context\n * @param countSpec - Count specification\n * @param alias - Table alias\n * @returns SQL expression for count aggregate (aliased)\n */\nexport function buildCountAggregate(\n  ctx: QueryContext,\n  countSpec: true | Record<string, boolean>,\n  alias: string\n): Sql | undefined {\n  const { adapter } = ctx;\n\n  // Simple count all\n  if (countSpec === true) {\n    return adapter.identifiers.aliased(adapter.aggregates.count(), \"_count\");\n  }\n\n  // Object with field selections\n  const entries = Object.entries(countSpec).filter(([, include]) => include);\n  if (entries.length === 0) {\n    return undefined;\n  }\n\n  // Build JSON object with count for each field\n  const pairs: [string, Sql][] = entries.map(([field]) => {\n    if (field === \"_all\") {\n      return [\"_all\", adapter.aggregates.count()];\n    }\n    // Resolve field name to actual column name (handles .map() overrides)\n    const columnName = getColumnName(ctx.model, field);\n    return [\n      field,\n      adapter.aggregates.count(adapter.identifiers.column(alias, columnName)),\n    ];\n  });\n\n  return adapter.identifiers.aliased(\n    adapter.json.objectFromColumns(pairs),\n    \"_count\"\n  );\n}\n\n/**\n * Build aggregate column expression for count, avg, sum, min, or max\n *\n * @param ctx - Query context\n * @param spec - Field specification { fieldName: true, ... } or true for count all\n * @param alias - Table alias\n * @param aggType - Aggregate type\n * @returns SQL expression for aggregate (aliased) or undefined if no fields\n */\nexport function buildAggregateColumn(\n  ctx: QueryContext,\n  spec: true | Record<string, boolean>,\n  alias: string,\n  aggType: AggregateType\n): Sql | undefined {\n  const { adapter } = ctx;\n\n  // Handle count specially - can be `true` or object\n  if (aggType === \"count\") {\n    return buildCountAggregate(ctx, spec, alias);\n  }\n\n  // For other aggregates, spec must be an object\n  if (spec === true) {\n    return undefined;\n  }\n\n  const entries = Object.entries(spec).filter(([, include]) => include);\n  if (entries.length === 0) {\n    return undefined;\n  }\n\n  // Get the appropriate aggregate function\n  const aggFn = getAggregateFn(adapter, aggType);\n  const aggName = `_${aggType}`;\n\n  const pairs: [string, Sql][] = entries.map(([field]) => {\n    // Resolve field name to actual column name (handles .map() overrides)\n    const columnName = getColumnName(ctx.model, field);\n    return [field, aggFn(adapter.identifiers.column(alias, columnName))];\n  });\n\n  return adapter.identifiers.aliased(\n    adapter.json.objectFromColumns(pairs),\n    aggName\n  );\n}\n\n/**\n * Get the aggregate function from adapter based on type\n */\nfunction getAggregateFn(\n  adapter: QueryContext[\"adapter\"],\n  aggType: \"avg\" | \"sum\" | \"min\" | \"max\"\n): (expr: Sql) => Sql {\n  switch (aggType) {\n    case \"avg\":\n      return adapter.aggregates.avg;\n    case \"sum\":\n      return adapter.aggregates.sum;\n    case \"min\":\n      return adapter.aggregates.min;\n    case \"max\":\n      return adapter.aggregates.max;\n    default:\n      return adapter.aggregates.count;\n  }\n}\n","/**\n * Aggregate Operation\n *\n * Builds SQL for aggregate queries.\n * Supports _count, _avg, _sum, _min, _max aggregations.\n */\n\nimport { type Sql, sql } from \"@sql\";\nimport {\n  buildAggregateColumn,\n  buildCountAggregate,\n} from \"../builders/aggregate-utils\";\nimport { buildWhere } from \"../builders/where-builder\";\nimport { getTableName } from \"../context\";\nimport type { QueryContext } from \"../types\";\nimport { QueryEngineError } from \"../types\";\n\n/**\n * Aggregate arguments\n */\nexport interface AggregateArgs {\n  where?: Record<string, unknown>;\n  cursor?: Record<string, unknown>;\n  take?: number;\n  skip?: number;\n  orderBy?: Record<string, unknown> | Record<string, unknown>[];\n  _count?: true | Record<string, boolean>;\n  _avg?: Record<string, boolean>;\n  _sum?: Record<string, boolean>;\n  _min?: Record<string, boolean>;\n  _max?: Record<string, boolean>;\n}\n\n/**\n * Build SQL for aggregate operation\n *\n * @param ctx - Query context\n * @param args - Aggregate arguments\n * @returns SQL statement\n */\nexport function buildAggregate(ctx: QueryContext, args: AggregateArgs): Sql {\n  const { adapter, rootAlias } = ctx;\n  const tableName = getTableName(ctx.model);\n\n  // Build aggregate columns\n  const columns = buildAggregateColumns(ctx, args, rootAlias);\n\n  if (columns.length === 0) {\n    throw new QueryEngineError(\n      \"Aggregate operation requires at least one aggregate field (_count, _avg, _sum, _min, _max)\"\n    );\n  }\n\n  // Build FROM\n  const from = adapter.identifiers.table(tableName, rootAlias);\n\n  // Build WHERE\n  const where = buildWhere(ctx, args.where, rootAlias);\n\n  // Build LIMIT/OFFSET (for cursor-based pagination)\n  const limit =\n    args.take !== undefined ? adapter.literals.value(args.take) : undefined;\n  const offset =\n    args.skip !== undefined ? adapter.literals.value(args.skip) : undefined;\n\n  // Assemble query\n  const parts: Parameters<typeof adapter.assemble.select>[0] = {\n    columns: sql.join(columns, \", \"),\n    from,\n  };\n\n  if (where) parts.where = where;\n  if (limit) parts.limit = limit;\n  if (offset) parts.offset = offset;\n\n  return adapter.assemble.select(parts);\n}\n\n/**\n * Build aggregate columns from args using shared helpers\n */\nfunction buildAggregateColumns(\n  ctx: QueryContext,\n  args: AggregateArgs,\n  alias: string\n): Sql[] {\n  const columns: Sql[] = [];\n\n  // Build _count aggregates\n  if (args._count) {\n    const countCol = buildCountAggregate(ctx, args._count, alias);\n    if (countCol) columns.push(countCol);\n  }\n\n  // Build _avg aggregates\n  if (args._avg) {\n    const avgCol = buildAggregateColumn(ctx, args._avg, alias, \"avg\");\n    if (avgCol) columns.push(avgCol);\n  }\n\n  // Build _sum aggregates\n  if (args._sum) {\n    const sumCol = buildAggregateColumn(ctx, args._sum, alias, \"sum\");\n    if (sumCol) columns.push(sumCol);\n  }\n\n  // Build _min aggregates\n  if (args._min) {\n    const minCol = buildAggregateColumn(ctx, args._min, alias, \"min\");\n    if (minCol) columns.push(minCol);\n  }\n\n  // Build _max aggregates\n  if (args._max) {\n    const maxCol = buildAggregateColumn(ctx, args._max, alias, \"max\");\n    if (maxCol) columns.push(maxCol);\n  }\n\n  return columns;\n}\n","/**\n * Count Operation\n *\n * Builds SQL for count queries.\n * Returns the number of records matching the criteria.\n */\n\nimport { type Sql, sql } from \"@sql\";\nimport { buildWhere } from \"../builders/where-builder\";\nimport { getColumnName, getTableName } from \"../context\";\nimport type { QueryContext } from \"../types\";\n\ninterface CountArgs {\n  where?: Record<string, unknown>;\n  select?: Record<string, boolean>;\n  cursor?: Record<string, unknown>;\n  take?: number;\n  skip?: number;\n}\n\n/**\n * Build SQL for count operation\n *\n * @param ctx - Query context\n * @param args - Count arguments\n * @returns SQL statement\n */\nexport function buildCount(ctx: QueryContext, args: CountArgs): Sql {\n  const { adapter, rootAlias } = ctx;\n  const tableName = getTableName(ctx.model);\n\n  // Build count columns\n  const columns = buildCountColumns(ctx, args.select);\n\n  // Build FROM\n  const from = adapter.identifiers.table(tableName, rootAlias);\n\n  // Build WHERE\n  const where = buildWhere(ctx, args.where, rootAlias);\n\n  // Build LIMIT (take)\n  const limit =\n    args.take !== undefined ? adapter.literals.value(args.take) : undefined;\n\n  // Build OFFSET (skip)\n  const offset =\n    args.skip !== undefined ? adapter.literals.value(args.skip) : undefined;\n\n  // Assemble query parts\n  const parts: Parameters<typeof adapter.assemble.select>[0] = {\n    columns,\n    from,\n  };\n  if (where) parts.where = where;\n  if (limit) parts.limit = limit;\n  if (offset) parts.offset = offset;\n\n  return adapter.assemble.select(parts);\n}\n\n/**\n * Build count columns based on select input\n */\nfunction buildCountColumns(\n  ctx: QueryContext,\n  select?: Record<string, boolean>\n): Sql {\n  const { adapter } = ctx;\n\n  if (!select) {\n    // Simple count all\n    return adapter.aggregates.count();\n  }\n\n  // Build count for specific fields\n  const counts: Sql[] = [];\n\n  if (select._all) {\n    counts.push(\n      adapter.identifiers.aliased(adapter.aggregates.count(), \"_all\")\n    );\n  }\n\n  for (const [field, include] of Object.entries(select)) {\n    if (field === \"_all\" || !include) continue;\n\n    // Resolve field name to actual column name (handles .map() overrides)\n    const columnName = getColumnName(ctx.model, field);\n    const column = adapter.identifiers.column(ctx.rootAlias, columnName);\n    const countExpr = adapter.aggregates.count(column);\n    counts.push(adapter.identifiers.aliased(countExpr, field));\n  }\n\n  if (counts.length === 0) {\n    return adapter.aggregates.count();\n  }\n\n  return sql.join(counts, \", \");\n}\n","/**\n * OrderBy Builder\n *\n * Builds ORDER BY clauses from orderBy input.\n */\n\nimport { type Sql, sql } from \"@sql\";\nimport { getColumnName, isScalarField } from \"../context\";\nimport type { QueryContext } from \"../types\";\n\ntype SortOrder = \"asc\" | \"desc\";\ntype NullsOrder = \"first\" | \"last\";\n\n/**\n * Build ORDER BY clause\n *\n * @param ctx - Query context\n * @param orderBy - OrderBy input (object or array of objects)\n * @param alias - Current table alias\n * @returns SQL for ORDER BY or undefined if no ordering\n */\nexport function buildOrderBy(\n  ctx: QueryContext,\n  orderBy: Record<string, unknown> | Record<string, unknown>[] | undefined,\n  alias: string\n): Sql | undefined {\n  if (!orderBy) {\n    return undefined;\n  }\n\n  const items = Array.isArray(orderBy) ? orderBy : [orderBy];\n  const orders: Sql[] = [];\n\n  for (const item of items) {\n    for (const [field, value] of Object.entries(item)) {\n      if (value === undefined) {\n        continue;\n      }\n\n      // Skip relation ordering for now (would need join or subquery)\n      if (!isScalarField(ctx.model, field)) {\n        continue;\n      }\n\n      // Resolve field name to actual column name (handles .map() overrides)\n      const columnName = getColumnName(ctx.model, field);\n      const column = ctx.adapter.identifiers.column(alias, columnName);\n      const orderSql = buildSingleOrder(ctx, column, value);\n      if (orderSql) {\n        orders.push(orderSql);\n      }\n    }\n  }\n\n  if (orders.length === 0) {\n    return undefined;\n  }\n\n  return sql.join(orders, \", \");\n}\n\n/**\n * Build a single order expression\n */\nfunction buildSingleOrder(\n  ctx: QueryContext,\n  column: Sql,\n  value: unknown\n): Sql | undefined {\n  const { adapter } = ctx;\n\n  // Simple string: \"asc\" or \"desc\"\n  if (typeof value === \"string\") {\n    return value === \"desc\"\n      ? adapter.orderBy.desc(column)\n      : adapter.orderBy.asc(column);\n  }\n\n  // Object with sort and optional nulls\n  if (typeof value === \"object\" && value !== null) {\n    const { sort, nulls } = value as { sort?: SortOrder; nulls?: NullsOrder };\n\n    let orderExpr =\n      sort === \"desc\"\n        ? adapter.orderBy.desc(column)\n        : adapter.orderBy.asc(column);\n\n    // Apply nulls ordering if specified\n    if (nulls === \"first\") {\n      orderExpr = adapter.orderBy.nullsFirst(orderExpr);\n    } else if (nulls === \"last\") {\n      orderExpr = adapter.orderBy.nullsLast(orderExpr);\n    }\n\n    return orderExpr;\n  }\n\n  return undefined;\n}\n","/**\n * Include Builder\n *\n * Builds nested relation subqueries with JSON aggregation.\n * - To-one: scalar subquery returning JSON object or null\n * - To-many: scalar subquery returning JSON array\n */\n\nimport { type Sql, sql } from \"@sql\";\nimport { createChildContext, getTableName } from \"../context\";\nimport type { QueryContext, RelationInfo } from \"../types\";\nimport { buildCorrelation } from \"./correlation-utils\";\nimport {\n  buildManyToManyJoinParts,\n  getManyToManyJoinInfo,\n} from \"./many-to-many-utils\";\nimport { buildOrderBy } from \"./orderby-builder\";\nimport { buildSelect } from \"./select-builder\";\nimport { buildWhere } from \"./where-builder\";\n\n/**\n * Build an include (relation subquery with JSON aggregation)\n *\n * @param ctx - Query context\n * @param relationInfo - Relation metadata\n * @param includeValue - Include options (select, include, where, orderBy, take, skip)\n * @param parentAlias - Parent table alias\n * @returns SQL for the relation subquery\n */\nexport function buildInclude(\n  ctx: QueryContext,\n  relationInfo: RelationInfo,\n  includeValue: Record<string, unknown>,\n  parentAlias: string\n): Sql {\n  // Handle manyToMany specially - requires junction table\n  if (relationInfo.type === \"manyToMany\") {\n    return buildManyToManyInclude(ctx, relationInfo, includeValue, parentAlias);\n  }\n\n  const relatedAlias = ctx.nextAlias();\n  const childCtx = createChildContext(\n    ctx,\n    relationInfo.targetModel,\n    relatedAlias\n  );\n\n  // Extract include options\n  const { select, include, where, orderBy, take, skip } = includeValue as {\n    select?: Record<string, unknown>;\n    include?: Record<string, unknown>;\n    where?: Record<string, unknown>;\n    orderBy?: Record<string, unknown> | Record<string, unknown>[];\n    take?: number;\n    skip?: number;\n  };\n\n  // Build the JSON object for selected fields (using asJson: true)\n  const jsonExpr = buildSelect(childCtx, select, include, relatedAlias, {\n    asJson: true,\n  });\n\n  // Build WHERE with correlation (throws if fields/references not defined)\n  const correlation = buildCorrelation(\n    ctx,\n    relationInfo,\n    parentAlias,\n    relatedAlias\n  );\n  const innerWhere = buildWhere(childCtx, where, relatedAlias);\n\n  const whereCondition = innerWhere\n    ? ctx.adapter.operators.and(correlation, innerWhere)\n    : correlation;\n\n  // Build ORDER BY\n  const orderBySql = buildOrderBy(childCtx, orderBy, relatedAlias);\n\n  // Build the inner query\n  const relatedTableName = getTableName(relationInfo.targetModel);\n  const fromTable = ctx.adapter.identifiers.table(\n    relatedTableName,\n    relatedAlias\n  );\n\n  if (relationInfo.isToMany) {\n    // To-many: aggregate into JSON array\n    return buildToManySubquery(\n      ctx,\n      jsonExpr,\n      fromTable,\n      whereCondition,\n      orderBySql,\n      take,\n      skip\n    );\n  }\n  // To-one: single JSON object or null\n  return buildToOneSubquery(ctx, jsonExpr, fromTable, whereCondition);\n}\n\n/**\n * Build to-many relation subquery with JSON aggregation\n */\nfunction buildToManySubquery(\n  ctx: QueryContext,\n  jsonExpr: Sql,\n  fromTable: Sql,\n  where: Sql,\n  orderBy: Sql | undefined,\n  take: number | undefined,\n  skip: number | undefined\n): Sql {\n  const { adapter } = ctx;\n\n  // Alias for the JSON column in the inner query\n  const jsonColAlias = \"_json\";\n  const aliasedJsonExpr = adapter.identifiers.aliased(jsonExpr, jsonColAlias);\n\n  // Build inner query that returns JSON objects with a named column\n  const innerParts: Sql[] = [\n    sql`SELECT ${aliasedJsonExpr}`,\n    sql`FROM ${fromTable}`,\n    sql`WHERE ${where}`,\n  ];\n\n  if (orderBy) {\n    innerParts.push(sql`ORDER BY ${orderBy}`);\n  }\n\n  if (take !== undefined) {\n    innerParts.push(sql`LIMIT ${adapter.literals.value(take)}`);\n  }\n\n  if (skip !== undefined) {\n    innerParts.push(sql`OFFSET ${adapter.literals.value(skip)}`);\n  }\n\n  const innerQuery = sql.join(innerParts, \" \");\n\n  // Wrap with aggregation: SELECT COALESCE(json_agg(subAlias._json), '[]') FROM (innerQuery) subAlias\n  const subAlias = ctx.nextAlias();\n  const jsonColumn = adapter.identifiers.column(subAlias, jsonColAlias);\n  return adapter.subqueries.scalar(\n    sql`SELECT ${adapter.json.agg(jsonColumn)} FROM (${innerQuery}) ${adapter.identifiers.escape(subAlias)}`\n  );\n}\n\n/**\n * Build to-one relation subquery returning JSON object or null\n */\nfunction buildToOneSubquery(\n  ctx: QueryContext,\n  jsonExpr: Sql,\n  fromTable: Sql,\n  where: Sql\n): Sql {\n  const { adapter } = ctx;\n\n  // Build query: SELECT json_object FROM table WHERE ... LIMIT 1\n  const query = sql`SELECT ${jsonExpr} FROM ${fromTable} WHERE ${where} LIMIT 1`;\n\n  return adapter.subqueries.scalar(query);\n}\n\n/**\n * Build include for manyToMany relation using junction table.\n *\n * SQL pattern:\n * SELECT COALESCE(json_agg(t0), '[]') FROM (\n *   SELECT json_build_object('id', t.id, 'name', t.name)\n *   FROM junction_table jt, target_table t\n *   WHERE jt.sourceId = parent.id AND t.id = jt.targetId\n *   [AND inner_where]\n *   [ORDER BY ...]\n *   [LIMIT/OFFSET]\n * ) t0\n */\nfunction buildManyToManyInclude(\n  ctx: QueryContext,\n  relationInfo: RelationInfo,\n  includeValue: Record<string, unknown>,\n  parentAlias: string\n): Sql {\n  const { adapter } = ctx;\n\n  const junctionAlias = ctx.nextAlias();\n  const targetAlias = ctx.nextAlias();\n\n  const joinInfo = getManyToManyJoinInfo(ctx, relationInfo);\n  const { correlationCondition, joinCondition, fromClause } =\n    buildManyToManyJoinParts(\n      ctx,\n      joinInfo,\n      parentAlias,\n      junctionAlias,\n      targetAlias\n    );\n\n  // Create child context for target\n  const childCtx = createChildContext(\n    ctx,\n    relationInfo.targetModel,\n    targetAlias\n  );\n\n  // Extract include options\n  const { select, include, where, orderBy, take, skip } = includeValue as {\n    select?: Record<string, unknown>;\n    include?: Record<string, unknown>;\n    where?: Record<string, unknown>;\n    orderBy?: Record<string, unknown> | Record<string, unknown>[];\n    take?: number;\n    skip?: number;\n  };\n\n  // Build the JSON object for selected fields\n  const jsonExpr = buildSelect(childCtx, select, include, targetAlias, {\n    asJson: true,\n  });\n\n  // Build inner where on target\n  const innerWhere = buildWhere(childCtx, where, targetAlias);\n\n  // Combine conditions\n  const conditions: Sql[] = [correlationCondition, joinCondition];\n  if (innerWhere) {\n    conditions.push(innerWhere);\n  }\n  const whereCondition = adapter.operators.and(...conditions);\n\n  // Build ORDER BY\n  const orderBySql = buildOrderBy(childCtx, orderBy, targetAlias);\n\n  // Alias for the JSON column in the inner query\n  const jsonColAlias = \"_json\";\n  const aliasedJsonExpr = adapter.identifiers.aliased(jsonExpr, jsonColAlias);\n\n  // Build inner query\n  const innerParts: Sql[] = [\n    sql`SELECT ${aliasedJsonExpr}`,\n    sql`FROM ${fromClause}`,\n    sql`WHERE ${whereCondition}`,\n  ];\n\n  if (orderBySql) {\n    innerParts.push(sql`ORDER BY ${orderBySql}`);\n  }\n\n  if (take !== undefined) {\n    innerParts.push(sql`LIMIT ${adapter.literals.value(take)}`);\n  }\n\n  if (skip !== undefined) {\n    innerParts.push(sql`OFFSET ${adapter.literals.value(skip)}`);\n  }\n\n  const innerQuery = sql.join(innerParts, \" \");\n\n  // Wrap with aggregation\n  const subAlias = ctx.nextAlias();\n  const jsonColumn = adapter.identifiers.column(subAlias, jsonColAlias);\n  return adapter.subqueries.scalar(\n    sql`SELECT ${adapter.json.agg(jsonColumn)} FROM (${innerQuery}) ${adapter.identifiers.escape(subAlias)}`\n  );\n}\n","/**\n * Select Builder\n *\n * Builds SELECT columns from select/include inputs.\n * Handles scalar fields and delegates relations to include-builder.\n */\n\nimport { type Sql, sql } from \"@sql\";\nimport { parse } from \"@validation\";\nimport {\n  createChildContext,\n  getColumnName,\n  getRelationInfo,\n  getScalarFieldNames,\n  getTableName,\n  isRelation,\n} from \"../context\";\nimport type { QueryContext, RelationInfo } from \"../types\";\nimport { buildCorrelation } from \"./correlation-utils\";\nimport { buildInclude } from \"./include-builder\";\nimport {\n  buildManyToManyJoinParts,\n  getManyToManyJoinInfo,\n} from \"./many-to-many-utils\";\nimport { buildWhere } from \"./where-builder\";\n\n/**\n * Options for buildSelect\n */\nexport interface BuildSelectOptions {\n  /**\n   * If true, returns a JSON object expression.\n   * If false (default), returns comma-separated aliased columns.\n   */\n  asJson?: boolean;\n}\n\n/**\n * Result of buildSelectWithAliases\n */\nexport interface SelectResult {\n  sql: Sql;\n  aliases: string[];\n}\n\n/**\n * Build SELECT columns from select/include inputs.\n *\n * @param ctx - Query context\n * @param select - Select input (fields to include)\n * @param include - Include input (relations to include)\n * @param alias - Current table alias\n * @param options - Build options\n * @returns SQL for SELECT columns (comma-separated or JSON object)\n */\nexport function buildSelect(\n  ctx: QueryContext,\n  select: Record<string, unknown> | undefined,\n  include: Record<string, unknown> | undefined,\n  alias: string,\n  options: BuildSelectOptions = {}\n): Sql {\n  // Build field/expression pairs\n  const pairs = buildSelectPairs(ctx, select, include, alias);\n\n  // Return JSON object if requested\n  if (options.asJson) {\n    return ctx.adapter.json.objectFromColumns(pairs);\n  }\n\n  // Convert pairs to aliased columns\n  const columns = pairs.map(([name, expr]) =>\n    ctx.adapter.identifiers.aliased(expr, name)\n  );\n\n  return sql.join(columns, \", \");\n}\n\n/**\n * Internal: Build pairs of [fieldName, expression] for select\n */\nfunction buildSelectPairs(\n  ctx: QueryContext,\n  select: Record<string, unknown> | undefined,\n  include: Record<string, unknown> | undefined,\n  alias: string\n): [string, Sql][] {\n  const pairs: [string, Sql][] = [];\n  const scalarFields = getScalarFieldNames(ctx.model);\n\n  if (select) {\n    // Select specific scalar fields\n    for (const fieldName of scalarFields) {\n      if (select[fieldName] === true) {\n        const columnName = getColumnName(ctx.model, fieldName);\n        pairs.push([\n          fieldName,\n          ctx.adapter.identifiers.column(alias, columnName),\n        ]);\n      }\n    }\n\n    // Handle relations in select (nested select/include)\n    for (const [key, value] of Object.entries(select)) {\n      if (value === undefined || value === false) {\n        continue;\n      }\n\n      if (isRelation(ctx.model, key)) {\n        const relationInfo = getRelationInfo(ctx, key);\n        if (relationInfo && typeof value === \"object\" && value !== null) {\n          const relationSql = buildInclude(\n            ctx,\n            relationInfo,\n            value as Record<string, unknown>,\n            alias\n          );\n          pairs.push([key, relationSql]);\n        }\n      }\n    }\n  } else {\n    // No select specified - select all scalar fields\n    for (const fieldName of scalarFields) {\n      const columnName = getColumnName(ctx.model, fieldName);\n      pairs.push([\n        fieldName,\n        ctx.adapter.identifiers.column(alias, columnName),\n      ]);\n    }\n  }\n\n  // Handle _count in select\n  if (select && \"_count\" in select && select._count) {\n    const countInput = select._count as { select: Record<string, unknown> };\n    if (countInput.select) {\n      const countPairs = buildCountPairs(ctx, countInput.select, alias);\n      pairs.push(...countPairs);\n    }\n  }\n\n  // Handle include (adds relations on top of scalars)\n  if (include) {\n    for (const [key, value] of Object.entries(include)) {\n      if (value === undefined || value === false) {\n        continue;\n      }\n\n      // Handle _count in include\n      if (key === \"_count\") {\n        const countInput = value as { select: Record<string, unknown> };\n        if (countInput.select) {\n          const countPairs = buildCountPairs(ctx, countInput.select, alias);\n          pairs.push(...countPairs);\n        }\n        continue;\n      }\n\n      if (isRelation(ctx.model, key)) {\n        const relationInfo = getRelationInfo(ctx, key);\n        if (relationInfo) {\n          const includeValue =\n            value === true ? {} : (value as Record<string, unknown>);\n          const relationSql = buildInclude(\n            ctx,\n            relationInfo,\n            includeValue,\n            alias\n          );\n          pairs.push([key, relationSql]);\n        }\n      }\n    }\n  }\n\n  // Fallback to all scalars if empty\n  if (pairs.length === 0) {\n    for (const fieldName of scalarFields) {\n      const columnName = getColumnName(ctx.model, fieldName);\n      pairs.push([\n        fieldName,\n        ctx.adapter.identifiers.column(alias, columnName),\n      ]);\n    }\n  }\n\n  return pairs;\n}\n\n/**\n * Build SELECT columns and return both SQL and column aliases.\n * Useful when the adapter needs to know column names (e.g., DISTINCT simulation).\n *\n * @param ctx - Query context\n * @param select - Select input (fields to include)\n * @param include - Include input (relations to include)\n * @param alias - Current table alias\n * @param options - Build options\n * @returns Object with SQL and column aliases\n */\nexport function buildSelectWithAliases(\n  ctx: QueryContext,\n  select: Record<string, unknown> | undefined,\n  include: Record<string, unknown> | undefined,\n  alias: string,\n  options: BuildSelectOptions = {}\n): SelectResult {\n  // Build field/expression pairs\n  const pairs = buildSelectPairs(ctx, select, include, alias);\n\n  // Extract aliases\n  const aliases = pairs.map(([name]) => name);\n\n  // Build SQL\n  let sqlResult: Sql;\n  if (options.asJson) {\n    sqlResult = ctx.adapter.json.objectFromColumns(pairs);\n  } else {\n    const columns = pairs.map(([name, expr]) =>\n      ctx.adapter.identifiers.aliased(expr, name)\n    );\n    sqlResult = sql.join(columns, \", \");\n  }\n\n  return { sql: sqlResult, aliases };\n}\n\n/**\n * Get all scalar field columns for a simple select all\n */\nexport function buildSelectAll(ctx: QueryContext, alias: string): Sql {\n  const scalarFields = getScalarFieldNames(ctx.model);\n  const columns = scalarFields.map((fieldName) => {\n    const columnName = getColumnName(ctx.model, fieldName);\n    return ctx.adapter.identifiers.column(alias, columnName);\n  });\n  return sql.join(columns, \", \");\n}\n\n/**\n * Build count pairs for _count aggregation\n *\n * @param ctx - Query context\n * @param countSelect - Object mapping relation names to true or { where: ... }\n * @param parentAlias - Parent table alias\n * @returns Array of [fieldName, countExpression] pairs\n */\nfunction buildCountPairs(\n  ctx: QueryContext,\n  countSelect: Record<string, unknown>,\n  parentAlias: string\n): [string, Sql][] {\n  const pairs: [string, Sql][] = [];\n\n  for (const [relationName, config] of Object.entries(countSelect)) {\n    if (config === undefined || config === false) {\n      continue;\n    }\n\n    const relationInfo = getRelationInfo(ctx, relationName);\n    if (!relationInfo) {\n      continue;\n    }\n\n    const countSql = buildRelationCount(ctx, relationInfo, config, parentAlias);\n    pairs.push([`_count_${relationName}`, countSql]);\n  }\n\n  return pairs;\n}\n\n/**\n * Build a COUNT subquery for a relation\n *\n * @param ctx - Query context\n * @param relationInfo - Relation metadata\n * @param config - true or { where: ... }\n * @param parentAlias - Parent table alias\n * @returns SQL for COUNT subquery\n */\nfunction buildRelationCount(\n  ctx: QueryContext,\n  relationInfo: RelationInfo,\n  config: unknown,\n  parentAlias: string\n): Sql {\n  const { adapter } = ctx;\n\n  // Handle manyToMany specially\n  if (relationInfo.type === \"manyToMany\") {\n    return buildManyToManyCount(ctx, relationInfo, config, parentAlias);\n  }\n\n  const targetAlias = ctx.nextAlias();\n  const targetTableName = getTableName(relationInfo.targetModel);\n  const targetTable = adapter.identifiers.table(targetTableName, targetAlias);\n\n  // Build correlation\n  const correlation = buildCorrelation(\n    ctx,\n    relationInfo,\n    parentAlias,\n    targetAlias\n  );\n\n  // Build inner where if provided\n  let whereCondition = correlation;\n\n  if (typeof config === \"object\" && config !== null && \"where\" in config) {\n    const childCtx = createChildContext(\n      ctx,\n      relationInfo.targetModel,\n      targetAlias\n    );\n    // Use the raw where clause directly - it's already validated by the parent schema\n    const rawWhere = (config as { where: Record<string, unknown> }).where;\n    const innerWhere = buildWhere(childCtx, rawWhere, targetAlias);\n    if (innerWhere) {\n      whereCondition = adapter.operators.and(correlation, innerWhere);\n    }\n  }\n\n  // Build COUNT subquery\n  return adapter.subqueries.scalar(\n    sql`SELECT COUNT(*) FROM ${targetTable} WHERE ${whereCondition}`\n  );\n}\n\n/**\n * Build a COUNT subquery for manyToMany relation through junction table\n */\nfunction buildManyToManyCount(\n  ctx: QueryContext,\n  relationInfo: RelationInfo,\n  config: unknown,\n  parentAlias: string\n): Sql {\n  const { adapter } = ctx;\n\n  const junctionAlias = ctx.nextAlias();\n  const targetAlias = ctx.nextAlias();\n\n  const joinInfo = getManyToManyJoinInfo(ctx, relationInfo);\n  const { correlationCondition, joinCondition, fromClause } =\n    buildManyToManyJoinParts(\n      ctx,\n      joinInfo,\n      parentAlias,\n      junctionAlias,\n      targetAlias\n    );\n\n  const conditions: Sql[] = [correlationCondition, joinCondition];\n\n  // Add inner where if provided\n  if (typeof config === \"object\" && config !== null && \"where\" in config) {\n    const childCtx = createChildContext(\n      ctx,\n      relationInfo.targetModel,\n      targetAlias\n    );\n    const rawWhere = (config as { where: Record<string, unknown> }).where;\n    const whereSchema = relationInfo.targetModel[\"~\"].schemas.where;\n    const normalizedWhere = whereSchema\n      ? (parse(whereSchema, rawWhere) as { value: Record<string, unknown> })\n          .value\n      : rawWhere;\n    const innerWhere = buildWhere(childCtx, normalizedWhere, targetAlias);\n    if (innerWhere) {\n      conditions.push(innerWhere);\n    }\n  }\n\n  const whereCondition = adapter.operators.and(...conditions);\n\n  return adapter.subqueries.scalar(\n    sql`SELECT COUNT(*) FROM ${fromClause} WHERE ${whereCondition}`\n  );\n}\n","/**\n * Create Operation\n *\n * Builds SQL for create mutations.\n * Returns the created record.\n */\n\nimport { type Sql, sql } from \"@sql\";\nimport { buildSelect } from \"../builders/select-builder\";\nimport { buildValues } from \"../builders/values-builder\";\nimport { getTableName } from \"../context\";\nimport type { QueryContext } from \"../types\";\n\ninterface CreateArgs {\n  data: Record<string, unknown>;\n  select?: Record<string, unknown>;\n  include?: Record<string, unknown>;\n}\n\n/**\n * Build SQL for create operation\n *\n * @param ctx - Query context\n * @param args - Create arguments\n * @returns SQL statement (INSERT with optional RETURNING)\n */\nexport function buildCreate(ctx: QueryContext, args: CreateArgs): Sql {\n  const { adapter } = ctx;\n  const tableName = getTableName(ctx.model);\n\n  // Build VALUES\n  const { columns, values } = buildValues(ctx, args.data);\n\n  if (columns.length === 0) {\n    throw new Error(\"No data to insert\");\n  }\n\n  // Build INSERT\n  const table = adapter.identifiers.escape(tableName);\n  const insertSql = adapter.mutations.insert(table, columns, values);\n\n  // Build RETURNING clause if supported (no alias for INSERT RETURNING)\n  // Note: MySQL doesn't support RETURNING, so this will be empty\n  const returningCols = buildSelect(ctx, args.select, args.include, \"\");\n  const returningSql = adapter.mutations.returning(returningCols);\n\n  // Combine INSERT with RETURNING\n  if (returningSql.strings.join(\"\").trim() === \"\") {\n    // No RETURNING support (MySQL) - just return INSERT\n    return insertSql;\n  }\n\n  return sql`${insertSql} ${returningSql}`;\n}\n\n/**\n * Build SQL for createMany operation\n *\n * @param ctx - Query context\n * @param data - Array of records to create\n * @param skipDuplicates - Whether to skip duplicate key errors\n * @returns SQL statement\n */\nexport function buildCreateMany(\n  ctx: QueryContext,\n  data: Record<string, unknown>[],\n  skipDuplicates = false\n): Sql {\n  const { adapter } = ctx;\n  const tableName = getTableName(ctx.model);\n\n  // Build VALUES for all records\n  const { columns, values } = buildValues(ctx, data);\n\n  if (columns.length === 0 || values.length === 0) {\n    throw new Error(\"No data to insert\");\n  }\n\n  // Build INSERT\n  const table = adapter.identifiers.escape(tableName);\n  let insertSql = adapter.mutations.insert(table, columns, values);\n\n  // Add ON CONFLICT DO NOTHING if skipDuplicates\n  if (skipDuplicates) {\n    const onConflict = adapter.mutations.onConflict(null, sql.raw`NOTHING`);\n    insertSql = sql`${insertSql} ${onConflict}`;\n  }\n\n  return insertSql;\n}\n","/**\n * Delete Operation\n *\n * Builds SQL for delete mutations.\n */\n\nimport { type Sql, sql } from \"@sql\";\nimport { buildSelect } from \"../builders/select-builder\";\nimport { buildWhere, buildWhereUnique } from \"../builders/where-builder\";\nimport { getTableName } from \"../context\";\nimport type { QueryContext } from \"../types\";\n\ninterface DeleteArgs {\n  where: Record<string, unknown>;\n  select?: Record<string, unknown>;\n  include?: Record<string, unknown>;\n}\n\ninterface DeleteManyArgs {\n  where?: Record<string, unknown>;\n}\n\n/**\n * Build SQL for delete operation (single record by unique key)\n *\n * @param ctx - Query context\n * @param args - Delete arguments\n * @returns SQL statement (DELETE with optional RETURNING)\n */\nexport function buildDelete(ctx: QueryContext, args: DeleteArgs): Sql {\n  const { adapter } = ctx;\n  const tableName = getTableName(ctx.model);\n\n  // Build WHERE from unique input (no alias for DELETE statements)\n  const whereSql = buildWhereUnique(ctx, args.where, \"\");\n\n  // Build DELETE\n  const table = adapter.identifiers.escape(tableName);\n  const deleteSql = adapter.mutations.delete(table, whereSql);\n\n  // Build RETURNING clause if supported (no alias for DELETE RETURNING)\n  const returningCols = buildSelect(ctx, args.select, args.include, \"\");\n  const returningSql = adapter.mutations.returning(returningCols);\n\n  // Combine DELETE with RETURNING\n  if (returningSql.strings.join(\"\").trim() === \"\") {\n    // No RETURNING support (MySQL)\n    return deleteSql;\n  }\n\n  return sql`${deleteSql} ${returningSql}`;\n}\n\n/**\n * Build SQL for deleteMany operation\n *\n * @param ctx - Query context\n * @param args - DeleteMany arguments\n * @returns SQL statement\n */\nexport function buildDeleteMany(ctx: QueryContext, args: DeleteManyArgs): Sql {\n  const { adapter } = ctx;\n  const tableName = getTableName(ctx.model);\n\n  // Build WHERE (optional for deleteMany, no alias for DELETE statements)\n  const whereSql = buildWhere(ctx, args.where, \"\");\n\n  // Build DELETE\n  const table = adapter.identifiers.escape(tableName);\n  return adapter.mutations.delete(table, whereSql);\n}\n","/**\n * Find Common\n *\n * Shared logic for findFirst/findMany operations.\n * Handles cursor-based pagination and distinct.\n */\n\nimport { type Sql, sql } from \"@sql\";\nimport { buildOrderBy } from \"../builders/orderby-builder\";\nimport {\n  buildSelect,\n  buildSelectWithAliases,\n} from \"../builders/select-builder\";\nimport { buildWhere } from \"../builders/where-builder\";\nimport { getColumnName, getScalarFieldNames, getTableName } from \"../context\";\nimport type { QueryContext } from \"../types\";\nimport { QueryEngineError } from \"../types\";\n\n/**\n * Common find arguments\n */\nexport interface FindArgs {\n  where?: Record<string, unknown>;\n  orderBy?: Record<string, unknown> | Record<string, unknown>[];\n  select?: Record<string, unknown>;\n  include?: Record<string, unknown>;\n  cursor?: Record<string, unknown>;\n  skip?: number;\n  distinct?: string[];\n}\n\n/**\n * Options for buildFind\n */\nexport interface FindOptions {\n  /** Limit number of results (1 for findFirst, take value for findMany, undefined for no limit) */\n  limit?: number | undefined;\n}\n\n/**\n * Build SQL for find operations (shared between findFirst and findMany)\n *\n * @param ctx - Query context\n * @param args - Find arguments\n * @param options - Find options\n * @returns SQL statement\n */\nexport function buildFind(\n  ctx: QueryContext,\n  args: FindArgs,\n  options: FindOptions = {}\n): Sql {\n  const { adapter, rootAlias } = ctx;\n  const tableName = getTableName(ctx.model);\n\n  // Build SELECT columns - use buildSelectWithAliases if distinct is needed\n  // so the adapter can reference columns by alias in outer SELECT\n  let columns: Sql;\n  let columnAliases: string[] | undefined;\n\n  if (args.distinct && args.distinct.length > 0) {\n    const selectResult = buildSelectWithAliases(\n      ctx,\n      args.select,\n      args.include,\n      rootAlias\n    );\n    columns = selectResult.sql;\n    columnAliases = selectResult.aliases;\n  } else {\n    columns = buildSelect(ctx, args.select, args.include, rootAlias);\n  }\n\n  // Build FROM\n  const from = adapter.identifiers.table(tableName, rootAlias);\n\n  // Build WHERE with cursor conditions\n  let where = buildWhere(ctx, args.where, rootAlias);\n\n  // Add cursor condition if specified\n  if (args.cursor) {\n    const cursorCondition = buildCursorCondition(\n      ctx,\n      args.cursor,\n      args.orderBy,\n      rootAlias\n    );\n    if (cursorCondition) {\n      where = where\n        ? adapter.operators.and(where, cursorCondition)\n        : cursorCondition;\n    }\n  }\n\n  // Build ORDER BY\n  const orderBy = buildOrderBy(ctx, args.orderBy, rootAlias);\n\n  // Build LIMIT\n  const limit =\n    options.limit !== undefined\n      ? adapter.literals.value(options.limit)\n      : undefined;\n\n  // Build OFFSET (skip)\n  const offset =\n    args.skip !== undefined ? adapter.literals.value(args.skip) : undefined;\n\n  // Handle DISTINCT\n  const distinct = args.distinct\n    ? buildDistinct(ctx, args.distinct, rootAlias)\n    : undefined;\n\n  // Assemble query parts\n  const parts: Parameters<typeof adapter.assemble.select>[0] = {\n    columns,\n    from,\n  };\n\n  if (distinct && columnAliases) {\n    parts.distinct = distinct;\n    parts.distinctColumnAliases = columnAliases;\n  } else if (distinct) {\n    parts.distinct = distinct;\n  }\n  if (where) parts.where = where;\n  if (orderBy) parts.orderBy = orderBy;\n  if (limit) parts.limit = limit;\n  if (offset) parts.offset = offset;\n\n  return adapter.assemble.select(parts);\n}\n\n/**\n * Build cursor condition for Prisma-style cursor pagination.\n *\n * The cursor is a unique identifier (usually the ID field).\n * Prisma includes the cursor record by default (use skip: 1 to exclude).\n * We use >= / <= to include the cursor record.\n *\n * @param ctx - Query context\n * @param cursor - Cursor object (e.g., { id: \"abc\" })\n * @param orderBy - Order by specification\n * @param alias - Table alias\n * @returns SQL condition for cursor\n * @throws QueryEngineError if cursor contains null values\n */\nfunction buildCursorCondition(\n  ctx: QueryContext,\n  cursor: Record<string, unknown>,\n  orderBy: Record<string, unknown> | Record<string, unknown>[] | undefined,\n  alias: string\n): Sql | undefined {\n  // Get cursor field and value\n  const cursorEntries = Object.entries(cursor);\n  if (cursorEntries.length === 0) return undefined;\n\n  // Validate no null values in cursor\n  for (const [field, value] of cursorEntries) {\n    if (value === null || value === undefined) {\n      throw new QueryEngineError(\n        `Cursor field '${field}' cannot be null or undefined. ` +\n          \"Cursor must point to a specific record.\"\n      );\n    }\n  }\n\n  // Single field cursor (most common case)\n  if (cursorEntries.length === 1) {\n    const [cursorField, cursorValue] = cursorEntries[0]!;\n    return buildSingleFieldCursor(\n      ctx,\n      cursorField,\n      cursorValue,\n      orderBy,\n      alias\n    );\n  }\n\n  // Compound cursor - validate and build\n  return buildCompoundCursor(ctx, cursor, orderBy, alias);\n}\n\n/**\n * Build cursor condition for a single field cursor.\n * Uses >= / <= to include the cursor record (Prisma behavior).\n */\nfunction buildSingleFieldCursor(\n  ctx: QueryContext,\n  cursorField: string,\n  cursorValue: unknown,\n  orderBy: Record<string, unknown> | Record<string, unknown>[] | undefined,\n  alias: string\n): Sql {\n  const { adapter } = ctx;\n  // Resolve field name to actual column name (handles .map() overrides)\n  const columnName = getColumnName(ctx.model, cursorField);\n  const column = adapter.identifiers.column(alias, columnName);\n  const value = adapter.literals.value(cursorValue);\n\n  // Determine direction from orderBy\n  const direction = getFieldDirection(cursorField, orderBy);\n\n  // Prisma includes cursor record by default:\n  // - For ascending order, we want records >= cursor\n  // - For descending order, we want records <= cursor\n  if (direction === \"desc\") {\n    return adapter.operators.lte(column, value);\n  }\n  return adapter.operators.gte(column, value);\n}\n\n/**\n * Build cursor condition for compound cursor (multiple fields).\n *\n * Validates that all fields have the same sort direction.\n * Throws error for mixed directions as they require complex tuple logic.\n *\n * Uses row value comparison: (a, b) >= (cursor_a, cursor_b)\n */\nfunction buildCompoundCursor(\n  ctx: QueryContext,\n  cursor: Record<string, unknown>,\n  orderBy: Record<string, unknown> | Record<string, unknown>[] | undefined,\n  alias: string\n): Sql {\n  const { adapter } = ctx;\n  const entries = Object.entries(cursor);\n\n  // Validate all fields have same direction\n  const directions = entries.map(([field]) =>\n    getFieldDirection(field, orderBy)\n  );\n  const firstDirection = directions[0];\n  const hasMixedDirections = directions.some((d) => d !== firstDirection);\n\n  if (hasMixedDirections) {\n    throw new QueryEngineError(\n      \"Compound cursor with mixed sort directions (asc/desc) is not supported. \" +\n        \"Either use a single-field cursor or ensure all orderBy fields use the same direction.\"\n    );\n  }\n\n  // Build column tuple (resolve field names to column names)\n  const columns = entries.map(([field]) => {\n    const columnName = getColumnName(ctx.model, field);\n    return adapter.identifiers.column(alias, columnName);\n  });\n\n  // Build value tuple\n  const values = entries.map(([, value]) => adapter.literals.value(value));\n\n  // Build: (col1, col2, ...) >= (val1, val2, ...) or <= for desc\n  // Prisma includes cursor record by default\n  const columnTuple = sql`(${sql.join(columns, \", \")})`;\n  const valueTuple = sql`(${sql.join(values, \", \")})`;\n\n  if (firstDirection === \"desc\") {\n    return sql`${columnTuple} <= ${valueTuple}`;\n  }\n  return sql`${columnTuple} >= ${valueTuple}`;\n}\n\n/**\n * Get sort direction for a field from orderBy specification\n *\n * Handles both formats:\n * - String: { field: \"desc\" }\n * - Object: { field: { sort: \"desc\", nulls: \"last\" } }\n */\nfunction getFieldDirection(\n  field: string,\n  orderBy: Record<string, unknown> | Record<string, unknown>[] | undefined\n): \"asc\" | \"desc\" {\n  if (!orderBy) return \"asc\";\n\n  // Normalize to array\n  const orderByArray = Array.isArray(orderBy) ? orderBy : [orderBy];\n\n  // Find the field in orderBy\n  for (const order of orderByArray) {\n    if (field in order) {\n      const direction = order[field];\n\n      // String format: { field: \"desc\" }\n      if (typeof direction === \"string\") {\n        if (direction === \"desc\" || direction === \"Desc\") {\n          return \"desc\";\n        }\n        return \"asc\";\n      }\n\n      // Object format: { field: { sort: \"desc\", nulls: \"last\" } }\n      if (typeof direction === \"object\" && direction !== null) {\n        const sortValue = (direction as Record<string, unknown>).sort;\n        if (sortValue === \"desc\" || sortValue === \"Desc\") {\n          return \"desc\";\n        }\n        return \"asc\";\n      }\n\n      return \"asc\";\n    }\n  }\n\n  // Default to ascending\n  return \"asc\";\n}\n\n/**\n * Build DISTINCT clause for find operations.\n *\n * PostgreSQL: DISTINCT ON (field1, field2, ...)\n * MySQL/SQLite: Simulated via ROW_NUMBER() in the adapter\n *\n * @param ctx - Query context\n * @param distinct - Array of field names for distinct\n * @param alias - Table alias\n * @returns SQL for DISTINCT clause\n */\nfunction buildDistinct(\n  ctx: QueryContext,\n  distinct: string[],\n  alias: string\n): Sql | undefined {\n  if (distinct.length === 0) return undefined;\n\n  const { adapter } = ctx;\n\n  // Validate distinct fields exist\n  const scalarFields = getScalarFieldNames(ctx.model);\n  for (const field of distinct) {\n    if (!scalarFields.includes(field)) {\n      throw new QueryEngineError(\n        `Distinct field '${field}' not found on model '${ctx.model[\"~\"].state.name}'`\n      );\n    }\n  }\n\n  // Build column list for distinct (resolve field names to column names)\n  // The adapter will handle database-specific implementation\n  const columns = distinct.map((field) => {\n    const columnName = getColumnName(ctx.model, field);\n    return adapter.identifiers.column(alias, columnName);\n  });\n\n  return sql.join(columns, \", \");\n}\n","/**\n * Find First Operation\n *\n * Builds SQL for findFirst queries.\n * Returns a single record matching the criteria or null.\n */\n\nimport type { Sql } from \"@sql\";\nimport type { QueryContext } from \"../types\";\nimport { buildFind, type FindArgs } from \"./find-common\";\n\nexport interface FindFirstArgs extends FindArgs {\n  // FindFirst specific: no take (always returns 1)\n}\n\n/**\n * Build SQL for findFirst operation\n *\n * @param ctx - Query context\n * @param args - FindFirst arguments\n * @returns SQL statement\n */\nexport function buildFindFirst(ctx: QueryContext, args: FindFirstArgs): Sql {\n  // FindFirst always limits to 1 result\n  return buildFind(ctx, args, { limit: 1 });\n}\n","/**\n * Find Many Operation\n *\n * Builds SQL for findMany queries.\n * Returns an array of records matching the criteria.\n */\n\nimport type { Sql } from \"@sql\";\nimport type { QueryContext } from \"../types\";\nimport { buildFind, type FindArgs } from \"./find-common\";\n\nexport interface FindManyArgs extends FindArgs {\n  /** Maximum number of records to return */\n  take?: number;\n}\n\n/**\n * Build SQL for findMany operation\n *\n * @param ctx - Query context\n * @param args - FindMany arguments\n * @returns SQL statement\n */\nexport function buildFindMany(ctx: QueryContext, args: FindManyArgs): Sql {\n  return buildFind(ctx, args, { limit: args.take });\n}\n","/**\n * Find Unique Operation\n *\n * Builds SQL for findUnique queries.\n * Returns a single record by unique identifier or null.\n */\n\nimport { type Sql, sql } from \"@sql\";\nimport { buildSelect } from \"../builders/select-builder\";\nimport { buildWhereUnique } from \"../builders/where-builder\";\nimport { getTableName } from \"../context\";\nimport type { QueryContext } from \"../types\";\n\ninterface FindUniqueArgs {\n  where: Record<string, unknown>;\n  select?: Record<string, unknown>;\n  include?: Record<string, unknown>;\n}\n\n/**\n * Build SQL for findUnique operation\n *\n * @param ctx - Query context\n * @param args - FindUnique arguments\n * @returns SQL statement\n */\nexport function buildFindUnique(ctx: QueryContext, args: FindUniqueArgs): Sql {\n  const { adapter, rootAlias } = ctx;\n  const tableName = getTableName(ctx.model);\n\n  // Build SELECT columns\n  const columns = buildSelect(ctx, args.select, args.include, rootAlias);\n\n  // Build FROM\n  const from = adapter.identifiers.table(tableName, rootAlias);\n\n  // Build WHERE from unique input\n  const where = buildWhereUnique(ctx, args.where, rootAlias);\n\n  // Build LIMIT (always 1 for findUnique)\n  const limit = sql`1`;\n\n  // Assemble query parts\n  const parts: Parameters<typeof adapter.assemble.select>[0] = {\n    columns,\n    from,\n  };\n  if (where) parts.where = where;\n  parts.limit = limit;\n\n  return adapter.assemble.select(parts);\n}\n","/**\n * GroupBy Operation\n *\n * Builds SQL for groupBy queries with aggregate functions.\n * Returns records grouped by specified fields with optional aggregates.\n */\n\nimport { type Sql, sql } from \"@sql\";\nimport {\n  buildAggregateColumn,\n  buildCountAggregate,\n} from \"../builders/aggregate-utils\";\nimport { buildOrderBy } from \"../builders/orderby-builder\";\nimport { buildWhere } from \"../builders/where-builder\";\nimport { getColumnName, getScalarFieldNames, getTableName } from \"../context\";\nimport type { QueryContext } from \"../types\";\nimport { QueryEngineError } from \"../types\";\n\n/**\n * GroupBy arguments\n */\nexport interface GroupByArgs {\n  /** Fields to group by (required) */\n  by: string | string[];\n  /** Filter records before grouping */\n  where?: Record<string, unknown>;\n  /** Filter groups (HAVING clause) */\n  having?: Record<string, unknown>;\n  /** Order results */\n  orderBy?: Record<string, unknown> | Record<string, unknown>[];\n  /** Limit results */\n  take?: number;\n  /** Skip results */\n  skip?: number;\n  /** Count aggregates */\n  _count?: true | Record<string, boolean>;\n  /** Average aggregates */\n  _avg?: Record<string, boolean>;\n  /** Sum aggregates */\n  _sum?: Record<string, boolean>;\n  /** Min aggregates */\n  _min?: Record<string, boolean>;\n  /** Max aggregates */\n  _max?: Record<string, boolean>;\n}\n\n/**\n * Build SQL for groupBy operation\n *\n * @param ctx - Query context\n * @param args - GroupBy arguments\n * @returns SQL statement\n */\nexport function buildGroupBy(ctx: QueryContext, args: GroupByArgs): Sql {\n  const { adapter, rootAlias } = ctx;\n  const tableName = getTableName(ctx.model);\n  const scalarFields = getScalarFieldNames(ctx.model);\n\n  // Normalize 'by' to array\n  const byFields = Array.isArray(args.by) ? args.by : [args.by];\n\n  // Validate by fields\n  for (const field of byFields) {\n    if (!scalarFields.includes(field)) {\n      throw new QueryEngineError(\n        `GroupBy field '${field}' not found on model '${ctx.model[\"~\"].state.name}'`\n      );\n    }\n  }\n\n  if (byFields.length === 0) {\n    throw new QueryEngineError(\n      \"GroupBy operation requires at least one field in 'by'\"\n    );\n  }\n\n  // Build SELECT columns: grouped fields + aggregates\n  const columns = buildGroupByColumns(ctx, byFields, args, rootAlias);\n\n  // Build FROM\n  const from = adapter.identifiers.table(tableName, rootAlias);\n\n  // Build WHERE\n  const where = buildWhere(ctx, args.where, rootAlias);\n\n  // Build GROUP BY (resolve field names to column names)\n  const groupByColumns = byFields.map((field) => {\n    const columnName = getColumnName(ctx.model, field);\n    return adapter.identifiers.column(rootAlias, columnName);\n  });\n  const groupBy = sql.join(groupByColumns, \", \");\n\n  // Build HAVING\n  const having = args.having\n    ? buildHaving(ctx, args.having, rootAlias)\n    : undefined;\n\n  // Build ORDER BY\n  const orderBy = buildOrderBy(ctx, args.orderBy, rootAlias);\n\n  // Build LIMIT/OFFSET\n  const limit =\n    args.take !== undefined ? adapter.literals.value(args.take) : undefined;\n  const offset =\n    args.skip !== undefined ? adapter.literals.value(args.skip) : undefined;\n\n  // Assemble query\n  const parts: Parameters<typeof adapter.assemble.select>[0] = {\n    columns: sql.join(columns, \", \"),\n    from,\n  };\n\n  if (where) parts.where = where;\n  parts.groupBy = groupBy;\n  if (having) parts.having = having;\n  if (orderBy) parts.orderBy = orderBy;\n  if (limit) parts.limit = limit;\n  if (offset) parts.offset = offset;\n\n  return adapter.assemble.select(parts);\n}\n\n/**\n * Build columns for groupBy query (grouped fields + aggregates)\n * Uses shared aggregate helpers\n */\nfunction buildGroupByColumns(\n  ctx: QueryContext,\n  byFields: string[],\n  args: GroupByArgs,\n  alias: string\n): Sql[] {\n  const { adapter } = ctx;\n  const columns: Sql[] = [];\n\n  // Add grouped fields (resolve field names to column names)\n  for (const field of byFields) {\n    const columnName = getColumnName(ctx.model, field);\n    columns.push(adapter.identifiers.column(alias, columnName));\n  }\n\n  // Add _count aggregate\n  if (args._count) {\n    const countCol = buildCountAggregate(ctx, args._count, alias);\n    if (countCol) columns.push(countCol);\n  }\n\n  // Add _avg aggregate\n  if (args._avg) {\n    const avgCol = buildAggregateColumn(ctx, args._avg, alias, \"avg\");\n    if (avgCol) columns.push(avgCol);\n  }\n\n  // Add _sum aggregate\n  if (args._sum) {\n    const sumCol = buildAggregateColumn(ctx, args._sum, alias, \"sum\");\n    if (sumCol) columns.push(sumCol);\n  }\n\n  // Add _min aggregate\n  if (args._min) {\n    const minCol = buildAggregateColumn(ctx, args._min, alias, \"min\");\n    if (minCol) columns.push(minCol);\n  }\n\n  // Add _max aggregate\n  if (args._max) {\n    const maxCol = buildAggregateColumn(ctx, args._max, alias, \"max\");\n    if (maxCol) columns.push(maxCol);\n  }\n\n  return columns;\n}\n\n/**\n * Build HAVING clause from having specification\n *\n * Having can filter on:\n * - Scalar fields (same as WHERE)\n * - Aggregate results: _count, _avg, _sum, _min, _max\n */\nfunction buildHaving(\n  ctx: QueryContext,\n  having: Record<string, unknown>,\n  alias: string\n): Sql | undefined {\n  const { adapter } = ctx;\n  const conditions: Sql[] = [];\n\n  for (const [key, value] of Object.entries(having)) {\n    if (value === undefined) continue;\n\n    // Check if it's an aggregate filter\n    if (\n      key === \"_count\" ||\n      key === \"_avg\" ||\n      key === \"_sum\" ||\n      key === \"_min\" ||\n      key === \"_max\"\n    ) {\n      const aggConditions = buildAggregateHaving(\n        ctx,\n        key,\n        value as Record<string, unknown>,\n        alias\n      );\n      if (aggConditions) conditions.push(aggConditions);\n      continue;\n    }\n\n    // Scalar field filter (same as WHERE) - resolve to column name\n    const columnName = getColumnName(ctx.model, key);\n    const column = adapter.identifiers.column(alias, columnName);\n    const scalarCondition = buildScalarHaving(ctx, column, value);\n    if (scalarCondition) conditions.push(scalarCondition);\n  }\n\n  if (conditions.length === 0) return undefined;\n  return adapter.operators.and(...conditions);\n}\n\n/**\n * Build aggregate HAVING condition\n *\n * Example: { _count: { id: { gt: 5 } } }\n */\nfunction buildAggregateHaving(\n  ctx: QueryContext,\n  aggType: string,\n  spec: Record<string, unknown>,\n  alias: string\n): Sql | undefined {\n  const { adapter } = ctx;\n  const conditions: Sql[] = [];\n\n  for (const [field, filter] of Object.entries(spec)) {\n    if (filter === undefined) continue;\n\n    // Build the aggregate expression based on aggregate type\n    let aggExpr: Sql;\n    // Resolve field name to column name (skip for _all)\n    const columnName =\n      field === \"_all\" ? undefined : getColumnName(ctx.model, field);\n    const column = columnName\n      ? adapter.identifiers.column(alias, columnName)\n      : undefined;\n\n    switch (aggType) {\n      case \"_count\":\n        aggExpr = column\n          ? adapter.aggregates.count(column)\n          : adapter.aggregates.count();\n        break;\n      case \"_avg\":\n        if (!column) continue; // _avg doesn't support _all\n        aggExpr = adapter.aggregates.avg(column);\n        break;\n      case \"_sum\":\n        if (!column) continue; // _sum doesn't support _all\n        aggExpr = adapter.aggregates.sum(column);\n        break;\n      case \"_min\":\n        if (!column) continue; // _min doesn't support _all\n        aggExpr = adapter.aggregates.min(column);\n        break;\n      case \"_max\":\n        if (!column) continue; // _max doesn't support _all\n        aggExpr = adapter.aggregates.max(column);\n        break;\n      default:\n        continue;\n    }\n\n    // Build the comparison condition\n    const filterCondition = buildScalarHaving(ctx, aggExpr, filter);\n    if (filterCondition) conditions.push(filterCondition);\n  }\n\n  if (conditions.length === 0) return undefined;\n  return adapter.operators.and(...conditions);\n}\n\n/**\n * Build scalar HAVING condition (comparison operators)\n */\nfunction buildScalarHaving(\n  ctx: QueryContext,\n  column: Sql,\n  filter: unknown\n): Sql | undefined {\n  const { adapter } = ctx;\n\n  // Direct value (equality)\n  if (typeof filter !== \"object\" || filter === null) {\n    return adapter.operators.eq(column, adapter.literals.value(filter));\n  }\n\n  const conditions: Sql[] = [];\n  const filterObj = filter as Record<string, unknown>;\n\n  for (const [op, value] of Object.entries(filterObj)) {\n    if (value === undefined) continue;\n\n    switch (op) {\n      case \"equals\":\n        conditions.push(\n          adapter.operators.eq(column, adapter.literals.value(value))\n        );\n        break;\n      case \"not\":\n        conditions.push(\n          adapter.operators.neq(column, adapter.literals.value(value))\n        );\n        break;\n      case \"gt\":\n        conditions.push(\n          adapter.operators.gt(column, adapter.literals.value(value))\n        );\n        break;\n      case \"gte\":\n        conditions.push(\n          adapter.operators.gte(column, adapter.literals.value(value))\n        );\n        break;\n      case \"lt\":\n        conditions.push(\n          adapter.operators.lt(column, adapter.literals.value(value))\n        );\n        break;\n      case \"lte\":\n        conditions.push(\n          adapter.operators.lte(column, adapter.literals.value(value))\n        );\n        break;\n      case \"in\":\n        if (Array.isArray(value)) {\n          const values = value.map((v) => adapter.literals.value(v));\n          conditions.push(\n            adapter.operators.in(column, adapter.literals.list(values))\n          );\n        }\n        break;\n      case \"notIn\":\n        if (Array.isArray(value)) {\n          const values = value.map((v) => adapter.literals.value(v));\n          conditions.push(\n            adapter.operators.notIn(column, adapter.literals.list(values))\n          );\n        }\n        break;\n      default: {\n        throw new QueryEngineError(`Invalid operator: ${op}`);\n      }\n    }\n  }\n\n  if (conditions.length === 0) return undefined;\n  if (conditions.length === 1) return conditions[0];\n  return adapter.operators.and(...conditions);\n}\n","/**\n * Nested Write Operations\n *\n * Handles transactional nested writes: create, connect, disconnect, connectOrCreate, delete.\n * These operations are executed within a transaction when needed.\n */\n\nimport type { Driver } from \"@drivers\";\nimport type { Model } from \"@schema/model\";\nimport { type Sql, sql } from \"@sql\";\nimport { getPrimaryKeyField } from \"../builders/correlation-utils\";\nimport {\n  type ConnectOrCreateInput,\n  type FkDirection,\n  getFkDirection,\n  type RelationMutation,\n  separateData,\n} from \"../builders/relation-data-builder\";\nimport { buildValues } from \"../builders/values-builder\";\nimport { buildWhereUnique } from \"../builders/where-builder\";\nimport { createChildContext, getColumnName, getTableName } from \"../context\";\nimport type { QueryContext, RelationInfo } from \"../types\";\nimport { NestedWriteError } from \"../types\";\n\n// ============================================================\n// TYPES\n// ============================================================\n\n/**\n * Result of a nested create operation\n */\nexport interface NestedCreateResult {\n  /** The created parent record */\n  record: Record<string, unknown>;\n  /** Created related records by relation name */\n  related: Record<string, Record<string, unknown> | Record<string, unknown>[]>;\n}\n\n/**\n * Step in a transaction plan\n */\nexport interface TransactionStep {\n  /** SQL to execute */\n  sql: Sql;\n  /** What to do with the result */\n  resultHandler?: (\n    result: Record<string, unknown>[],\n    context: TransactionContext\n  ) => void;\n}\n\n/**\n * Context passed through transaction steps\n */\nexport interface TransactionContext {\n  /** Generated IDs from previous steps */\n  generatedIds: Map<string, unknown>;\n  /** Created records for return value assembly */\n  createdRecords: Map<\n    string,\n    Record<string, unknown> | Record<string, unknown>[]\n  >;\n}\n\n// ============================================================\n// FK MATCH CONDITION HELPER\n// ============================================================\n\n/**\n * Build WHERE condition to match related records by FK\n *\n * When FK is on the related model (to-many from parent's perspective):\n *   WHERE related.fk = parent.pk\n *\n * When FK is on the current model (to-one from parent's perspective):\n *   WHERE related.pk = parent.fk\n *\n * @param ctx - Query context\n * @param fkDir - FK direction info\n * @param targetModel - Related model\n * @param parentData - Parent record data\n * @returns SQL WHERE condition\n */\nfunction buildFkMatchCondition(\n  ctx: QueryContext,\n  fkDir: FkDirection,\n  targetModel: Model<any>,\n  parentData: Record<string, unknown>\n): Sql {\n  const { adapter } = ctx;\n  const conditions: Sql[] = [];\n\n  if (fkDir.holdsFK) {\n    // FK on current side - match related records where their PK = our FK value\n    for (let i = 0; i < fkDir.pkFields.length; i++) {\n      const pkField = fkDir.pkFields[i]!;\n      const fkField = fkDir.fkFields[i]!;\n      const pkColumn = getColumnName(targetModel, pkField);\n      const column = adapter.identifiers.escape(pkColumn);\n      const value = adapter.literals.value(parentData[fkField]);\n      conditions.push(adapter.operators.eq(column, value));\n    }\n  } else {\n    // FK on related side - match related records where their FK = parent PK\n    for (let i = 0; i < fkDir.fkFields.length; i++) {\n      const fkField = fkDir.fkFields[i]!;\n      const pkField = fkDir.pkFields[i]!;\n      const fkColumn = getColumnName(targetModel, fkField);\n      const column = adapter.identifiers.escape(fkColumn);\n      const value = adapter.literals.value(parentData[pkField]);\n      conditions.push(adapter.operators.eq(column, value));\n    }\n  }\n\n  return conditions.length === 1\n    ? conditions[0]!\n    : adapter.operators.and(...conditions);\n}\n\n/**\n * Build SET clause for FK null assignment\n *\n * Sets all FK fields to NULL for disconnect operations.\n *\n * @param ctx - Query context\n * @param fkDir - FK direction info\n * @param targetModel - Related model\n * @returns SQL SET clause assignments\n */\nfunction buildFkNullAssignments(\n  ctx: QueryContext,\n  fkDir: FkDirection,\n  targetModel: Model<any>\n): Sql[] {\n  const { adapter } = ctx;\n  const assignments: Sql[] = [];\n\n  for (const fkField of fkDir.fkFields) {\n    const fkColumn = getColumnName(targetModel, fkField);\n    const column = adapter.identifiers.escape(fkColumn);\n    assignments.push(adapter.set.assign(column, adapter.literals.null()));\n  }\n\n  return assignments;\n}\n\n/**\n * Build SET clause for FK value assignment\n *\n * Sets FK fields to parent PK values for connect operations.\n *\n * @param ctx - Query context\n * @param fkDir - FK direction info\n * @param targetModel - Related model\n * @param parentData - Parent record data\n * @returns SQL SET clause assignments\n */\nfunction buildFkValueAssignments(\n  ctx: QueryContext,\n  fkDir: FkDirection,\n  targetModel: Model<any>,\n  parentData: Record<string, unknown>\n): Sql[] {\n  const { adapter } = ctx;\n  const assignments: Sql[] = [];\n\n  for (let i = 0; i < fkDir.fkFields.length; i++) {\n    const fkField = fkDir.fkFields[i]!;\n    const pkField = fkDir.pkFields[i]!;\n    const fkColumn = getColumnName(targetModel, fkField);\n    const column = adapter.identifiers.escape(fkColumn);\n    const value = adapter.literals.value(parentData[pkField]);\n    assignments.push(adapter.set.assign(column, value));\n  }\n\n  return assignments;\n}\n\n// ============================================================\n// NESTED CREATE\n// ============================================================\n\n/**\n * Execute a nested create operation\n *\n * Handles FK-direction-aware ordering:\n * - If current model holds FK: create related first, then current\n * - If related model holds FK: create current first, then related\n *\n * @param driver - Database driver with transaction support\n * @param ctx - Query context\n * @param data - Create data including nested relations\n * @returns Created record with nested records\n */\nexport async function executeNestedCreate(\n  driver: Driver,\n  ctx: QueryContext,\n  data: Record<string, unknown>\n): Promise<NestedCreateResult> {\n  const { scalar, relations } = separateData(ctx, data);\n\n  // If no relations, just do a simple insert\n  if (Object.keys(relations).length === 0) {\n    const result = await executeSimpleInsert(driver, ctx, scalar);\n    return { record: result, related: {} };\n  }\n\n  // Execute in transaction\n  return driver.transaction(async (tx) => {\n    const txCtx: TransactionContext = {\n      generatedIds: new Map(),\n      createdRecords: new Map(),\n    };\n\n    // Separate relations by FK direction\n    const currentHoldsFK: Array<[string, RelationMutation]> = [];\n    const relatedHoldsFK: Array<[string, RelationMutation]> = [];\n\n    for (const [name, mutation] of Object.entries(relations)) {\n      const fkDir = getFkDirection(ctx, mutation.relationInfo);\n      if (fkDir.holdsFK) {\n        currentHoldsFK.push([name, mutation]);\n      } else {\n        relatedHoldsFK.push([name, mutation]);\n      }\n    }\n\n    // Step 1: Process relations where current holds FK (create related first)\n    for (const [relationName, mutation] of currentHoldsFK) {\n      await processRelationMutation(\n        tx,\n        ctx,\n        relationName,\n        mutation,\n        \"before\",\n        scalar,\n        txCtx\n      );\n    }\n\n    // Step 2: Create current record\n    const parentRecord = await executeSimpleInsert(tx, ctx, scalar);\n    const parentPk = getPrimaryKeyField(ctx.model);\n    const parentId = parentRecord[parentPk];\n    txCtx.generatedIds.set(\"__parent__\", parentId);\n\n    // Step 3: Process relations where related holds FK (create related after)\n    for (const [relationName, mutation] of relatedHoldsFK) {\n      await processRelationMutation(\n        tx,\n        ctx,\n        relationName,\n        mutation,\n        \"after\",\n        parentRecord,\n        txCtx\n      );\n    }\n\n    // Assemble result\n    const related: Record<\n      string,\n      Record<string, unknown> | Record<string, unknown>[]\n    > = {};\n    for (const [name] of [...currentHoldsFK, ...relatedHoldsFK]) {\n      const created = txCtx.createdRecords.get(name);\n      if (created) {\n        related[name] = created;\n      }\n    }\n\n    return { record: parentRecord, related };\n  });\n}\n\n// ============================================================\n// NESTED UPDATE\n// ============================================================\n\n/**\n * Result of a nested update operation\n */\nexport interface NestedUpdateResult {\n  /** The updated parent record */\n  record: Record<string, unknown>;\n  /** Related records by relation name */\n  related: Record<string, Record<string, unknown> | Record<string, unknown>[]>;\n}\n\n/**\n * Execute a nested update operation\n *\n * Handles relation mutations: connect, disconnect, create, delete.\n * Operations are executed after the parent update since the parent\n * already exists and we need its PK for FK operations.\n *\n * @param driver - Database driver with transaction support\n * @param ctx - Query context\n * @param parentRecord - The existing parent record (with its PK)\n * @param relations - Parsed relation mutations from separateData\n * @returns Updated record with related records\n */\nexport async function executeNestedUpdate(\n  driver: Driver,\n  ctx: QueryContext,\n  parentRecord: Record<string, unknown>,\n  relations: Record<string, RelationMutation>\n): Promise<NestedUpdateResult> {\n  // If no relations, nothing to do\n  if (Object.keys(relations).length === 0) {\n    return { record: parentRecord, related: {} };\n  }\n\n  // Execute in transaction\n  return driver.transaction(async (tx) => {\n    const txCtx: TransactionContext = {\n      generatedIds: new Map(),\n      createdRecords: new Map(),\n    };\n\n    // Store parent PK for FK operations\n    const parentPk = getPrimaryKeyField(ctx.model);\n    const parentId = parentRecord[parentPk];\n    txCtx.generatedIds.set(\"__parent__\", parentId);\n\n    // For updates, all relation operations happen \"after\" since parent exists\n    for (const [relationName, mutation] of Object.entries(relations)) {\n      await processRelationMutation(\n        tx,\n        ctx,\n        relationName,\n        mutation,\n        \"after\",\n        parentRecord,\n        txCtx\n      );\n    }\n\n    // Assemble result\n    const related: Record<\n      string,\n      Record<string, unknown> | Record<string, unknown>[]\n    > = {};\n    for (const [name] of Object.entries(relations)) {\n      const created = txCtx.createdRecords.get(name);\n      if (created) {\n        related[name] = created;\n      }\n    }\n\n    return { record: parentRecord, related };\n  });\n}\n\n/**\n * Process a single relation mutation\n */\nasync function processRelationMutation(\n  tx: Driver,\n  ctx: QueryContext,\n  relationName: string,\n  mutation: RelationMutation,\n  timing: \"before\" | \"after\",\n  parentData: Record<string, unknown>,\n  txCtx: TransactionContext\n): Promise<void> {\n  const { relationInfo } = mutation;\n\n  // Handle create\n  if (mutation.create) {\n    const creates = Array.isArray(mutation.create)\n      ? mutation.create\n      : [mutation.create];\n\n    const createdRecords: Record<string, unknown>[] = [];\n\n    for (const createData of creates) {\n      const record = await executeRelationCreate(\n        tx,\n        ctx,\n        relationInfo,\n        createData,\n        timing,\n        parentData,\n        txCtx\n      );\n      createdRecords.push(record);\n    }\n\n    // Store for return value\n    if (relationInfo.isToMany) {\n      txCtx.createdRecords.set(relationName, createdRecords);\n    } else {\n      txCtx.createdRecords.set(relationName, createdRecords[0]!);\n    }\n  }\n\n  // Handle connect (when FK is on other side)\n  if (mutation.connect && timing === \"after\") {\n    const connects = Array.isArray(mutation.connect)\n      ? mutation.connect\n      : [mutation.connect];\n\n    for (const connectInput of connects) {\n      await executeRelationConnect(\n        tx,\n        ctx,\n        relationInfo,\n        connectInput,\n        parentData,\n        txCtx\n      );\n    }\n  }\n\n  // Handle connectOrCreate\n  if (mutation.connectOrCreate) {\n    const cocs = Array.isArray(mutation.connectOrCreate)\n      ? mutation.connectOrCreate\n      : [mutation.connectOrCreate];\n\n    const records: Record<string, unknown>[] = [];\n\n    for (const coc of cocs) {\n      const record = await executeConnectOrCreate(\n        tx,\n        ctx,\n        relationInfo,\n        coc,\n        timing,\n        parentData,\n        txCtx\n      );\n      if (record) {\n        records.push(record);\n      }\n    }\n\n    if (records.length > 0) {\n      if (relationInfo.isToMany) {\n        const existing = txCtx.createdRecords.get(relationName);\n        if (Array.isArray(existing)) {\n          txCtx.createdRecords.set(relationName, [...existing, ...records]);\n        } else {\n          txCtx.createdRecords.set(relationName, records);\n        }\n      } else {\n        txCtx.createdRecords.set(relationName, records[0]!);\n      }\n    }\n  }\n\n  // Handle disconnect\n  if (mutation.disconnect && timing === \"after\") {\n    await executeRelationDisconnect(\n      tx,\n      ctx,\n      relationInfo,\n      mutation.disconnect,\n      parentData\n    );\n  }\n\n  // Handle delete\n  if (mutation.delete && timing === \"after\") {\n    await executeRelationDelete(\n      tx,\n      ctx,\n      relationInfo,\n      mutation.delete,\n      parentData\n    );\n  }\n\n  // Handle set (replace all related records)\n  if (mutation.set && timing === \"after\") {\n    await executeRelationSet(tx, ctx, relationInfo, mutation.set, parentData);\n  }\n}\n\n/**\n * Execute a nested create for a relation\n */\nasync function executeRelationCreate(\n  tx: Driver,\n  ctx: QueryContext,\n  relationInfo: RelationInfo,\n  createData: Record<string, unknown>,\n  timing: \"before\" | \"after\",\n  parentData: Record<string, unknown>,\n  txCtx: TransactionContext\n): Promise<Record<string, unknown>> {\n  const { targetModel } = relationInfo;\n  const fkDir = getFkDirection(ctx, relationInfo);\n  const childCtx = createChildContext(ctx, targetModel, ctx.nextAlias());\n\n  // Prepare data with FK if needed\n  const dataWithFk = { ...createData };\n\n  if (timing === \"after\" && !fkDir.holdsFK) {\n    // Related holds FK - add parent's PK to the data\n    const parentPkFields = fkDir.pkFields;\n    const fkFields = fkDir.fkFields;\n\n    for (let i = 0; i < fkFields.length; i++) {\n      const fkField = fkFields[i]!;\n      const pkField = parentPkFields[i]!;\n      dataWithFk[fkField] = parentData[pkField];\n    }\n  }\n\n  // Recursively handle nested relations in the create data\n  const { scalar, relations } = separateData(childCtx, dataWithFk);\n\n  if (Object.keys(relations).length > 0) {\n    // Recursive nested create\n    const result = await executeNestedCreate(tx, childCtx, dataWithFk);\n    return result.record;\n  }\n\n  // Simple insert\n  return executeSimpleInsert(tx, childCtx, scalar);\n}\n\n/**\n * Execute a relation connect (when FK is on related side)\n */\nasync function executeRelationConnect(\n  tx: Driver,\n  ctx: QueryContext,\n  relationInfo: RelationInfo,\n  connectInput: Record<string, unknown>,\n  parentData: Record<string, unknown>,\n  _txCtx: TransactionContext\n): Promise<void> {\n  const { adapter } = ctx;\n  const { targetModel, name } = relationInfo;\n  const fkDir = getFkDirection(ctx, relationInfo);\n\n  if (fkDir.holdsFK) {\n    // FK on current side - this should have been handled via subquery\n    // in the scalar data, not here\n    return;\n  }\n\n  // FK on related side - UPDATE the related record to point to parent\n  const targetTable = getTableName(targetModel);\n  const childCtx = createChildContext(ctx, targetModel, ctx.nextAlias());\n\n  // Build WHERE for the record to connect\n  const whereClause = buildWhereUnique(\n    childCtx,\n    connectInput,\n    childCtx.rootAlias\n  );\n  if (!whereClause) {\n    throw new NestedWriteError(\n      `Invalid connect input for relation '${name}'`,\n      name\n    );\n  }\n\n  // Build SET clause - set FK fields to parent PK values\n  const assignments: Sql[] = [];\n  const fkFields = fkDir.fkFields;\n  const pkFields = fkDir.pkFields;\n\n  for (let i = 0; i < fkFields.length; i++) {\n    const fkField = fkFields[i]!;\n    const pkField = pkFields[i]!;\n    const fkColumn = getColumnName(targetModel, fkField);\n    const column = adapter.identifiers.escape(fkColumn);\n    const value = adapter.literals.value(parentData[pkField]);\n    assignments.push(adapter.set.assign(column, value));\n  }\n\n  const setSql = sql.join(assignments, \", \");\n  const table = adapter.identifiers.escape(targetTable);\n  const updateSql = adapter.mutations.update(table, setSql, whereClause);\n\n  await tx.execute(updateSql);\n}\n\n/**\n * Execute a connectOrCreate operation\n */\nasync function executeConnectOrCreate(\n  tx: Driver,\n  ctx: QueryContext,\n  relationInfo: RelationInfo,\n  input: ConnectOrCreateInput,\n  timing: \"before\" | \"after\",\n  parentData: Record<string, unknown>,\n  txCtx: TransactionContext\n): Promise<Record<string, unknown> | undefined> {\n  const { adapter } = ctx;\n  const { targetModel, name } = relationInfo;\n  const childCtx = createChildContext(ctx, targetModel, ctx.nextAlias());\n\n  // Check if record exists\n  const targetTable = getTableName(targetModel);\n  const alias = childCtx.rootAlias;\n\n  const whereClause = buildWhereUnique(childCtx, input.where, alias);\n  if (!whereClause) {\n    throw new NestedWriteError(\n      `Invalid connectOrCreate where for relation '${name}'`,\n      name\n    );\n  }\n\n  // SELECT to check existence\n  const pkField = getPrimaryKeyField(targetModel);\n  const pkColumn = getColumnName(targetModel, pkField);\n  const selectSql = sql`SELECT ${adapter.identifiers.column(alias, pkColumn)} FROM ${adapter.identifiers.escape(targetTable)} ${sql.raw(alias)} WHERE ${whereClause} LIMIT 1`;\n\n  const result = await tx.execute<Record<string, unknown>>(selectSql);\n\n  if (result.rows.length > 0) {\n    // Record exists - just connect it\n    const existingRecord = result.rows[0]!;\n\n    // If FK is on related side, update it to point to parent\n    const fkDir = getFkDirection(ctx, relationInfo);\n    if (!fkDir.holdsFK && timing === \"after\") {\n      await executeRelationConnect(\n        tx,\n        ctx,\n        relationInfo,\n        input.where,\n        parentData,\n        txCtx\n      );\n    }\n\n    return existingRecord;\n  }\n\n  // Record doesn't exist - create it\n  return executeRelationCreate(\n    tx,\n    ctx,\n    relationInfo,\n    input.create,\n    timing,\n    parentData,\n    txCtx\n  );\n}\n\n/**\n * Execute a disconnect operation\n */\nasync function executeRelationDisconnect(\n  tx: Driver,\n  ctx: QueryContext,\n  relationInfo: RelationInfo,\n  disconnectInput:\n    | boolean\n    | Record<string, unknown>\n    | Record<string, unknown>[],\n  parentData: Record<string, unknown>\n): Promise<void> {\n  const { adapter } = ctx;\n  const { targetModel, name } = relationInfo;\n  const fkDir = getFkDirection(ctx, relationInfo);\n\n  if (fkDir.holdsFK) {\n    // FK on current side - should be handled by setting FK to NULL in scalar update\n    return;\n  }\n\n  // FK on related side - UPDATE related records to set FK to NULL\n  const targetTable = getTableName(targetModel);\n  const childCtx = createChildContext(ctx, targetModel, ctx.nextAlias());\n\n  // Build WHERE clause\n  let whereClause: Sql;\n\n  if (disconnectInput === true) {\n    // Disconnect all - WHERE FK = parent PK\n    whereClause = buildFkMatchCondition(ctx, fkDir, targetModel, parentData);\n  } else {\n    // Disconnect specific record(s)\n    const inputs = Array.isArray(disconnectInput)\n      ? disconnectInput\n      : [disconnectInput];\n    const conditions: Sql[] = [];\n\n    for (const input of inputs) {\n      const condition = buildWhereUnique(childCtx, input, childCtx.rootAlias);\n      if (condition) {\n        conditions.push(condition);\n      }\n    }\n\n    if (conditions.length === 0) {\n      throw new NestedWriteError(\n        `Invalid disconnect input for relation '${name}'`,\n        name\n      );\n    }\n\n    whereClause =\n      conditions.length === 1\n        ? conditions[0]!\n        : adapter.operators.or(...conditions);\n  }\n\n  // Build SET clause - set FK fields to NULL\n  const assignments = buildFkNullAssignments(ctx, fkDir, targetModel);\n  const setSql = sql.join(assignments, \", \");\n  const table = adapter.identifiers.escape(targetTable);\n  const updateSql = adapter.mutations.update(table, setSql, whereClause);\n\n  await tx.execute(updateSql);\n}\n\n/**\n * Execute a nested delete operation\n */\nasync function executeRelationDelete(\n  tx: Driver,\n  ctx: QueryContext,\n  relationInfo: RelationInfo,\n  deleteInput: boolean | Record<string, unknown> | Record<string, unknown>[],\n  parentData: Record<string, unknown>\n): Promise<void> {\n  const { adapter } = ctx;\n  const { targetModel, name } = relationInfo;\n  const fkDir = getFkDirection(ctx, relationInfo);\n\n  const targetTable = getTableName(targetModel);\n  const childCtx = createChildContext(ctx, targetModel, ctx.nextAlias());\n\n  // Build WHERE clause\n  let whereClause: Sql;\n\n  if (deleteInput === true) {\n    // Delete all related - use FK match condition\n    whereClause = buildFkMatchCondition(ctx, fkDir, targetModel, parentData);\n  } else {\n    // Delete specific record(s)\n    const inputs = Array.isArray(deleteInput) ? deleteInput : [deleteInput];\n    const conditions: Sql[] = [];\n\n    for (const input of inputs) {\n      const condition = buildWhereUnique(childCtx, input, childCtx.rootAlias);\n      if (condition) {\n        conditions.push(condition);\n      }\n    }\n\n    if (conditions.length === 0) {\n      throw new NestedWriteError(\n        `Invalid delete input for relation '${name}'`,\n        name\n      );\n    }\n\n    whereClause =\n      conditions.length === 1\n        ? conditions[0]!\n        : adapter.operators.or(...conditions);\n  }\n\n  // Execute DELETE\n  const table = adapter.identifiers.escape(targetTable);\n  const deleteSql = adapter.mutations.delete(table, whereClause);\n\n  await tx.execute(deleteSql);\n}\n\n/**\n * Execute a set operation (replace all related records)\n *\n * For to-many relations where related model holds FK:\n * 1. Disconnect all existing (set FK to NULL)\n * 2. Connect all items in the set array\n */\nasync function executeRelationSet(\n  tx: Driver,\n  ctx: QueryContext,\n  relationInfo: RelationInfo,\n  setItems: Record<string, unknown>[],\n  parentData: Record<string, unknown>\n): Promise<void> {\n  const { adapter } = ctx;\n  const { targetModel, name } = relationInfo;\n  const fkDir = getFkDirection(ctx, relationInfo);\n\n  if (fkDir.holdsFK) {\n    // FK on current side - set operation doesn't make sense for to-one\n    throw new NestedWriteError(\n      `'set' operation is not supported for relation '${name}' where current model holds FK. ` +\n        `Use 'connect' instead for to-one relations.`,\n      name\n    );\n  }\n\n  // Validate that parent has the required PK fields\n  for (const pkField of fkDir.pkFields) {\n    if (parentData[pkField] === undefined || parentData[pkField] === null) {\n      throw new NestedWriteError(\n        `Cannot execute 'set' for relation '${name}': parent record is missing primary key field '${pkField}'. ` +\n          \"Ensure the parent record is saved before performing nested operations.\",\n        name\n      );\n    }\n  }\n\n  // FK on related side - this is a to-many relation\n  const targetTable = getTableName(targetModel);\n  const childCtx = createChildContext(ctx, targetModel, ctx.nextAlias());\n  const table = adapter.identifiers.escape(targetTable);\n\n  // Step 1: Disconnect all existing (set FK to NULL for all related records)\n  const disconnectWhere = buildFkMatchCondition(\n    ctx,\n    fkDir,\n    targetModel,\n    parentData\n  );\n  const nullAssignments = buildFkNullAssignments(ctx, fkDir, targetModel);\n  const disconnectSetSql = sql.join(nullAssignments, \", \");\n  const disconnectSql = adapter.mutations.update(\n    table,\n    disconnectSetSql,\n    disconnectWhere\n  );\n\n  await tx.execute(disconnectSql);\n\n  // Step 2: Connect all items in the set array\n  const valueAssignments = buildFkValueAssignments(\n    ctx,\n    fkDir,\n    targetModel,\n    parentData\n  );\n  const connectSetSql = sql.join(valueAssignments, \", \");\n\n  for (const setItem of setItems) {\n    // Build WHERE to find the record to connect\n    const whereClause = buildWhereUnique(childCtx, setItem, childCtx.rootAlias);\n    if (!whereClause) {\n      throw new NestedWriteError(\n        `Invalid set input for relation '${name}'`,\n        name\n      );\n    }\n\n    const connectSql = adapter.mutations.update(\n      table,\n      connectSetSql,\n      whereClause\n    );\n    await tx.execute(connectSql);\n  }\n}\n\n// ============================================================\n// SIMPLE INSERT HELPER\n// ============================================================\n\n/**\n * Execute a simple INSERT and return the created record\n */\nasync function executeSimpleInsert(\n  driver: Driver,\n  ctx: QueryContext,\n  data: Record<string, unknown>\n): Promise<Record<string, unknown>> {\n  const { adapter } = ctx;\n  const tableName = getTableName(ctx.model);\n  const modelName = ctx.model.name ?? tableName;\n\n  const { columns, values } = buildValues(ctx, data);\n\n  if (columns.length === 0) {\n    throw new NestedWriteError(\n      `No data to insert for model '${modelName}'`,\n      modelName\n    );\n  }\n\n  const table = adapter.identifiers.escape(tableName);\n  const insertSql = adapter.mutations.insert(table, columns, values);\n\n  // Add RETURNING * to get the created record\n  const returningSql = adapter.mutations.returning(sql`*`);\n\n  // Check if RETURNING is supported (PostgreSQL) or empty (MySQL/SQLite)\n  const hasReturning = returningSql.strings.join(\"\").trim() !== \"\";\n\n  if (hasReturning) {\n    // PostgreSQL with RETURNING - single query returns the created record\n    const finalSql = sql`${insertSql} ${returningSql}`;\n    const result = await driver.execute<Record<string, unknown>>(finalSql);\n\n    if (result.rows.length === 0) {\n      throw new NestedWriteError(\n        `Insert did not return a record for model '${modelName}'`,\n        modelName\n      );\n    }\n\n    return result.rows[0]!;\n  }\n\n  // MySQL/SQLite without RETURNING - INSERT then refetch\n  await driver.execute(insertSql);\n\n  // Get the last inserted ID based on dialect\n  const pkField = getPrimaryKeyField(ctx.model);\n  const pkValue = data[pkField];\n\n  if (pkValue !== undefined) {\n    // PK was provided in data - use it to refetch\n    return refetchInsertedRecord(\n      driver,\n      ctx,\n      pkField,\n      pkValue,\n      data,\n      modelName\n    );\n  }\n\n  // PK was auto-generated - get last insert ID\n  const lastInsertId = await getLastInsertId(driver);\n\n  if (lastInsertId !== undefined) {\n    return refetchInsertedRecord(\n      driver,\n      ctx,\n      pkField,\n      lastInsertId,\n      data,\n      modelName\n    );\n  }\n\n  // Fallback: return input data (can't refetch without ID)\n  return { ...data };\n}\n\n/**\n * Get the last inserted ID using dialect-specific query\n */\nasync function getLastInsertId(driver: Driver): Promise<unknown | undefined> {\n  const dialect = driver.dialect;\n\n  // PostgreSQL uses RETURNING, no need to query for last insert ID\n  if (dialect === \"postgresql\") {\n    return undefined;\n  }\n\n  let query: string;\n  if (dialect === \"mysql\") {\n    query = \"SELECT LAST_INSERT_ID() as id\";\n  } else if (dialect === \"sqlite\") {\n    query = \"SELECT last_insert_rowid() as id\";\n  } else {\n    // Unknown dialect - let errors propagate\n    return undefined;\n  }\n\n  // Let DB errors propagate - don't silently return undefined\n  const result = await driver.executeRaw<{ id: unknown }>(query, []);\n  return result.rows[0]?.id;\n}\n\n/**\n * Refetch the inserted record by primary key\n *\n * This is needed for MySQL/SQLite which don't support RETURNING.\n * If refetch fails, we throw rather than returning partial data.\n */\nasync function refetchInsertedRecord(\n  driver: Driver,\n  ctx: QueryContext,\n  pkField: string,\n  pkValue: unknown,\n  originalData: Record<string, unknown>,\n  modelName: string\n): Promise<Record<string, unknown>> {\n  const { adapter } = ctx;\n  const tableName = getTableName(ctx.model);\n  const alias = ctx.rootAlias;\n\n  // Build SELECT * FROM table WHERE pk = value\n  const pkColumn = getColumnName(ctx.model, pkField);\n  const table = adapter.identifiers.table(tableName, alias);\n  const columns = sql`*`;\n  const where = adapter.operators.eq(\n    adapter.identifiers.column(alias, pkColumn),\n    adapter.literals.value(pkValue)\n  );\n\n  const selectSql = adapter.assemble.select({\n    columns,\n    from: table,\n    where,\n  });\n\n  // Let DB errors propagate - don't silently return partial data\n  const result = await driver.execute<Record<string, unknown>>(selectSql);\n\n  if (result.rows.length > 0) {\n    return result.rows[0]!;\n  }\n\n  // Record not found after insert - this is a bug or race condition\n  // Return original data with PK as a fallback, but this shouldn't happen\n  console.warn(\n    `[nested-writes] Record not found after insert for ${modelName}.${pkField}=${pkValue}. ` +\n      \"This may indicate a race condition or transaction isolation issue.\"\n  );\n  return { ...originalData, [pkField]: pkValue };\n}\n","/**\n * Set Builder\n *\n * Builds SET clause for UPDATE operations.\n * Handles simple assignments, increment/decrement, and array operations.\n */\n\nimport { type Sql, sql } from \"@sql\";\nimport { getColumnName, getScalarFieldNames, isRelation } from \"../context\";\nimport type { QueryContext } from \"../types\";\n\n/**\n * Build SET clause for UPDATE from update data\n *\n * @param ctx - Query context\n * @param data - Update input data\n * @param alias - Table alias (optional, for qualified columns)\n * @returns SQL for SET clause\n */\nexport function buildSet(\n  ctx: QueryContext,\n  data: Record<string, unknown>,\n  alias?: string\n): Sql {\n  const { adapter } = ctx;\n  const assignments: Sql[] = [];\n  const scalarFields = getScalarFieldNames(ctx.model);\n\n  for (const [key, value] of Object.entries(data)) {\n    if (value === undefined) {\n      continue;\n    }\n    if (isRelation(ctx.model, key)) {\n      continue; // Skip relations\n    }\n    if (!scalarFields.includes(key)) {\n      continue;\n    }\n\n    // Resolve field name to actual column name (handles .map() overrides)\n    const columnName = getColumnName(ctx.model, key);\n    const column = alias\n      ? adapter.identifiers.column(alias, columnName)\n      : adapter.identifiers.escape(columnName);\n\n    const assignment = buildAssignment(ctx, column, value);\n    if (assignment) {\n      assignments.push(assignment);\n    }\n  }\n\n  if (assignments.length === 0) {\n    throw new Error(\"No fields to update\");\n  }\n\n  return sql.join(assignments, \", \");\n}\n\n/**\n * Check if a value is a Sql object\n */\nfunction isSql(value: unknown): value is Sql {\n  return (\n    value !== null &&\n    typeof value === \"object\" &&\n    \"strings\" in value &&\n    \"values\" in value &&\n    Array.isArray((value as Sql).strings) &&\n    Array.isArray((value as Sql).values)\n  );\n}\n\n/**\n * Build a single assignment expression\n *\n * Schema validation normalizes all values to operation objects:\n * - Simple values become { set: value }\n * - null becomes { set: null }\n */\nfunction buildAssignment(\n  ctx: QueryContext,\n  column: Sql,\n  value: unknown\n): Sql | undefined {\n  const { adapter } = ctx;\n\n  // Handle Sql values directly (from connect subqueries)\n  if (isSql(value)) {\n    return adapter.set.assign(column, value);\n  }\n\n  // Handle null values\n  if (value === null) {\n    return adapter.set.assign(column, adapter.literals.null());\n  }\n\n  // Schema validation guarantees value is always an operation object\n  if (typeof value !== \"object\") {\n    throw new Error(\n      \"Update value must be an operation object (schema validation should have normalized this)\"\n    );\n  }\n\n  const op = value as Record<string, unknown>;\n\n  // set: assign value directly\n  if (\"set\" in op) {\n    const setValue = op.set;\n    if (setValue === null) {\n      return adapter.set.assign(column, adapter.literals.null());\n    }\n    return adapter.set.assign(column, adapter.literals.value(setValue));\n  }\n\n  // increment: add to current value\n  if (\"increment\" in op && op.increment !== undefined) {\n    return adapter.set.increment(column, adapter.literals.value(op.increment));\n  }\n\n  // decrement: subtract from current value\n  if (\"decrement\" in op && op.decrement !== undefined) {\n    return adapter.set.decrement(column, adapter.literals.value(op.decrement));\n  }\n\n  // multiply: multiply current value\n  if (\"multiply\" in op && op.multiply !== undefined) {\n    return adapter.set.multiply(column, adapter.literals.value(op.multiply));\n  }\n\n  // divide: divide current value\n  if (\"divide\" in op && op.divide !== undefined) {\n    return adapter.set.divide(column, adapter.literals.value(op.divide));\n  }\n\n  // push: append to array\n  if (\"push\" in op && op.push !== undefined) {\n    return adapter.set.push(column, adapter.literals.value(op.push));\n  }\n\n  // unshift: prepend to array\n  if (\"unshift\" in op && op.unshift !== undefined) {\n    return adapter.set.unshift(column, adapter.literals.value(op.unshift));\n  }\n\n  // Unknown operation - schema validation should prevent this\n  throw new Error(`Unknown update operation: ${Object.keys(op).join(\", \")}`);\n}\n","/**\n * Update Operation\n *\n * Builds SQL for update mutations.\n * Returns the updated record.\n */\n\nimport { type Sql, sql } from \"@sql\";\nimport { buildSelect } from \"../builders/select-builder\";\nimport { buildSet } from \"../builders/set-builder\";\nimport { buildWhere, buildWhereUnique } from \"../builders/where-builder\";\nimport { getRelationInfo, getTableName, isRelation } from \"../context\";\nimport type { QueryContext } from \"../types\";\n\ninterface UpdateArgs {\n  where: Record<string, unknown>;\n  data: Record<string, unknown>;\n  select?: Record<string, unknown>;\n  include?: Record<string, unknown>;\n}\n\ninterface UpdateManyArgs {\n  where?: Record<string, unknown>;\n  data: Record<string, unknown>;\n}\n\n/**\n * Process relation operations (connect/disconnect) and convert to FK assignments.\n * For to-one relations where the current model holds the FK, we can translate\n * connect/disconnect to direct FK field updates.\n *\n * @param ctx - Query context\n * @param data - Update data containing scalar and relation fields\n * @returns Processed data with FK assignments from relation operations\n */\nfunction processRelationOperations(\n  ctx: QueryContext,\n  data: Record<string, unknown>\n): Record<string, unknown> {\n  const result: Record<string, unknown> = {};\n\n  for (const [key, value] of Object.entries(data)) {\n    if (value === undefined) continue;\n\n    // Check if this is a relation field\n    if (isRelation(ctx.model, key)) {\n      const relationInfo = getRelationInfo(ctx, key);\n      if (!relationInfo) continue;\n\n      // Only handle to-one relations where current model holds FK\n      const relState = relationInfo.relation[\"~\"].state;\n      if (\n        (relState.type === \"manyToOne\" || relState.type === \"oneToOne\") &&\n        relState.fields &&\n        relState.references\n      ) {\n        const mutation = value as Record<string, unknown>;\n        const fields = Array.isArray(relState.fields)\n          ? relState.fields\n          : [relState.fields];\n        const references = Array.isArray(relState.references)\n          ? relState.references\n          : [relState.references];\n\n        // Handle connect: set FK to target's PK value\n        if (mutation.connect !== undefined) {\n          const connectInput = mutation.connect as Record<string, unknown>;\n          for (let i = 0; i < fields.length; i++) {\n            const fkField = fields[i] as string;\n            const refField = references[i] as string;\n            // Wrap in { set: value } for the set-builder\n            result[fkField] = { set: connectInput[refField] };\n          }\n        }\n\n        // Handle disconnect: set FK to NULL\n        if (mutation.disconnect !== undefined) {\n          for (const fkField of fields) {\n            result[fkField as string] = { set: null };\n          }\n        }\n      }\n      // Skip other relation operations (they need transaction handling)\n    } else {\n      // Pass through scalar fields\n      result[key] = value;\n    }\n  }\n\n  return result;\n}\n\n/**\n * Build SQL for update operation (single record by unique key)\n *\n * @param ctx - Query context\n * @param args - Update arguments\n * @returns SQL statement (UPDATE with optional RETURNING)\n */\nexport function buildUpdate(ctx: QueryContext, args: UpdateArgs): Sql {\n  const { adapter } = ctx;\n  const tableName = getTableName(ctx.model);\n\n  // Process relation operations (connect/disconnect) to FK assignments\n  const processedData = processRelationOperations(ctx, args.data);\n\n  // Build SET clause with processed data\n  const setSql = buildSet(ctx, processedData);\n\n  // Build WHERE from unique input (no alias for UPDATE statements)\n  const whereSql = buildWhereUnique(ctx, args.where, \"\");\n\n  // Build UPDATE\n  const table = adapter.identifiers.escape(tableName);\n  const updateSql = adapter.mutations.update(table, setSql, whereSql);\n\n  // Build RETURNING clause if supported (no alias for UPDATE RETURNING)\n  const returningCols = buildSelect(ctx, args.select, args.include, \"\");\n  const returningSql = adapter.mutations.returning(returningCols);\n\n  // Combine UPDATE with RETURNING\n  if (returningSql.strings.join(\"\").trim() === \"\") {\n    // No RETURNING support (MySQL)\n    return updateSql;\n  }\n\n  return sql`${updateSql} ${returningSql}`;\n}\n\n/**\n * Build SQL for updateMany operation\n *\n * @param ctx - Query context\n * @param args - UpdateMany arguments\n * @returns SQL statement\n */\nexport function buildUpdateMany(ctx: QueryContext, args: UpdateManyArgs): Sql {\n  const { adapter } = ctx;\n  const tableName = getTableName(ctx.model);\n\n  // Build SET clause\n  const setSql = buildSet(ctx, args.data);\n\n  // Build WHERE (optional for updateMany, no alias for UPDATE statements)\n  const whereSql = buildWhere(ctx, args.where, \"\");\n\n  // Build UPDATE\n  const table = adapter.identifiers.escape(tableName);\n  return adapter.mutations.update(table, setSql, whereSql);\n}\n","/**\n * Upsert Operation\n *\n * Builds SQL for upsert mutations.\n * Inserts a new record or updates existing one on conflict.\n */\n\nimport { type Sql, sql } from \"@sql\";\nimport { buildSelect } from \"../builders/select-builder\";\nimport { buildSet } from \"../builders/set-builder\";\nimport { buildValues } from \"../builders/values-builder\";\nimport { getColumnName, getTableName } from \"../context\";\nimport type { QueryContext } from \"../types\";\n\ninterface UpsertArgs {\n  where: Record<string, unknown>;\n  create: Record<string, unknown>;\n  update: Record<string, unknown>;\n  select?: Record<string, unknown>;\n  include?: Record<string, unknown>;\n}\n\n/**\n * Build SQL for upsert operation\n *\n * @param ctx - Query context\n * @param args - Upsert arguments\n * @returns SQL statement (INSERT ... ON CONFLICT ... DO UPDATE)\n */\nexport function buildUpsert(ctx: QueryContext, args: UpsertArgs): Sql {\n  const { adapter, rootAlias } = ctx;\n  const tableName = getTableName(ctx.model);\n\n  // Build INSERT from create data\n  const { columns, values } = buildValues(ctx, args.create);\n\n  if (columns.length === 0) {\n    throw new Error(\"No data to insert\");\n  }\n\n  const table = adapter.identifiers.escape(tableName);\n  const insertSql = adapter.mutations.insert(table, columns, values);\n\n  // Build conflict target from where (unique fields)\n  const conflictTarget = buildConflictTarget(ctx, args.where);\n\n  // Build update action from update data\n  const updateAction = buildSet(ctx, args.update);\n\n  // Build ON CONFLICT ... DO UPDATE\n  const onConflictSql = adapter.mutations.onConflict(\n    conflictTarget,\n    sql`UPDATE SET ${updateAction}`\n  );\n\n  // Combine INSERT with ON CONFLICT\n  let upsertSql = sql`${insertSql} ${onConflictSql}`;\n\n  // Build RETURNING clause if supported\n  // Use empty alias since INSERT doesn't have a FROM clause with table aliases\n  const returningCols = buildSelect(ctx, args.select, args.include, \"\");\n  const returningSql = adapter.mutations.returning(returningCols);\n\n  if (returningSql.strings.join(\"\").trim() !== \"\") {\n    upsertSql = sql`${upsertSql} ${returningSql}`;\n  }\n\n  return upsertSql;\n}\n\n/**\n * Build conflict target from where input\n * Extracts the unique key fields from the where clause\n */\nfunction buildConflictTarget(\n  ctx: QueryContext,\n  where: Record<string, unknown>\n): Sql {\n  const { adapter } = ctx;\n  const fields: Sql[] = [];\n\n  for (const [key, value] of Object.entries(where)) {\n    if (value === undefined) continue;\n\n    // Check if this is a compound key\n    if (typeof value === \"object\" && value !== null && !Array.isArray(value)) {\n      // Compound key: { userId_orgId: { userId: \"1\", orgId: \"2\" } }\n      const compound = value as Record<string, unknown>;\n      for (const fieldName of Object.keys(compound)) {\n        const columnName = getColumnName(ctx.model, fieldName);\n        fields.push(adapter.identifiers.escape(columnName));\n      }\n    } else {\n      // Single field\n      const columnName = getColumnName(ctx.model, key);\n      fields.push(adapter.identifiers.escape(columnName));\n    }\n  }\n\n  return sql.join(fields, \", \");\n}\n","/**\n * Result Parser\n *\n * Transforms raw database rows into typed objects.\n * Handles JSON parsing for MySQL/SQLite and null coalescing.\n */\n\nimport { isBatchOperation, type Operation, type QueryContext } from \"../types\";\n\n/**\n * Parse query result based on operation type\n *\n * @param ctx - Query context\n * @param operation - The operation that was executed\n * @param raw - Raw database result\n * @returns Parsed and typed result\n */\nexport function parseResult<T>(\n  ctx: QueryContext,\n  operation: Operation,\n  raw: unknown\n): T {\n  // Handle null/undefined\n  if (raw === null || raw === undefined) {\n    return getDefaultResult(operation) as T;\n  }\n\n  // Handle exist operation - convert count to boolean\n  if (operation === \"exist\") {\n    const count = parseCountResult(raw);\n    const hasRecords =\n      typeof count === \"number\"\n        ? count > 0\n        : Object.values(count).some((v) => v > 0);\n    return hasRecords as T;\n  }\n\n  // Handle count operation - return number or object with counts\n  if (operation === \"count\") {\n    return parseCountResult(raw) as T;\n  }\n\n  // Handle batch operations - return { count: number }\n  if (isBatchOperation(operation)) {\n    return parseMutationCount(raw) as T;\n  }\n\n  // Handle array results\n  if (Array.isArray(raw)) {\n    // For operations that return single records\n    if (isSingleRecordOperation(operation)) {\n      const first = raw[0];\n      if (!first) {\n        return null as T;\n      }\n      return parseRow(ctx, first) as T;\n    }\n\n    // For operations that return arrays\n    return raw.map((row) => parseRow(ctx, row)) as T;\n  }\n\n  // Single row result\n  if (typeof raw === \"object\") {\n    return parseRow(ctx, raw as Record<string, unknown>) as T;\n  }\n\n  // Scalar result (count, etc.)\n  return raw as T;\n}\n\n/**\n * Parse a single row, handling JSON columns\n */\nfunction parseRow(\n  ctx: QueryContext,\n  row: Record<string, unknown>\n): Record<string, unknown> {\n  const result: Record<string, unknown> = {};\n\n  for (const [key, value] of Object.entries(row)) {\n    result[key] = parseValue(value);\n  }\n\n  return result;\n}\n\n/**\n * Parse a single value, handling JSON strings and BigInt\n */\nfunction parseValue(value: unknown): unknown {\n  // Null passthrough\n  if (value === null || value === undefined) {\n    return null;\n  }\n\n  // Handle BigInt - keep as BigInt to preserve precision for large values\n  // Users can convert to Number if needed for smaller values\n  if (typeof value === \"bigint\") {\n    return value;\n  }\n\n  // Try to parse JSON strings (MySQL/SQLite may return JSON as strings)\n  if (typeof value === \"string\") {\n    // Check if it looks like JSON\n    const trimmed = value.trim();\n    if (\n      (trimmed.startsWith(\"{\") && trimmed.endsWith(\"}\")) ||\n      (trimmed.startsWith(\"[\") && trimmed.endsWith(\"]\"))\n    ) {\n      try {\n        return JSON.parse(value);\n      } catch {\n        // Not valid JSON, return as-is\n        return value;\n      }\n    }\n    return value;\n  }\n\n  // Already parsed object (PostgreSQL returns JSON as objects)\n  if (typeof value === \"object\") {\n    if (Array.isArray(value)) {\n      return value.map(parseValue);\n    }\n    // Recursively parse nested objects\n    const result: Record<string, unknown> = {};\n    for (const [k, v] of Object.entries(value as Record<string, unknown>)) {\n      result[k] = parseValue(v);\n    }\n    return result;\n  }\n\n  // Primitive values\n  return value;\n}\n\n/**\n * Check if operation returns a single record (vs array)\n */\nfunction isSingleRecordOperation(operation: Operation): boolean {\n  return [\n    \"findFirst\",\n    \"findUnique\",\n    \"create\",\n    \"update\",\n    \"delete\",\n    \"upsert\",\n    \"aggregate\", // aggregate returns a single row with aggregate values\n  ].includes(operation);\n}\n\n/**\n * Get default result for empty results based on operation\n */\nfunction getDefaultResult(operation: Operation): unknown {\n  switch (operation) {\n    case \"findFirst\":\n    case \"findUnique\":\n    case \"create\":\n    case \"update\":\n    case \"delete\":\n    case \"upsert\":\n      return null;\n\n    case \"findMany\":\n      return [];\n\n    case \"createMany\":\n    case \"updateMany\":\n    case \"deleteMany\":\n      return { count: 0 };\n\n    case \"count\":\n      return 0;\n\n    case \"aggregate\":\n    case \"groupBy\":\n      return {};\n\n    case \"exist\":\n      return false;\n\n    default:\n      return null;\n  }\n}\n\n/**\n * Parse count result\n *\n * Returns a plain number for simple count, or an object with multiple counts\n * when using select (e.g., { _all: 5, name: 4 })\n */\nexport function parseCountResult(\n  raw: unknown\n): number | Record<string, number> {\n  if (raw === null || raw === undefined) {\n    return 0;\n  }\n\n  // Single count value\n  if (typeof raw === \"number\") {\n    return raw;\n  }\n\n  // BigInt from database\n  if (typeof raw === \"bigint\") {\n    return Number(raw);\n  }\n\n  // Array with single row containing count(s)\n  if (Array.isArray(raw) && raw.length > 0) {\n    const firstRow = raw[0];\n    if (typeof firstRow === \"object\" && firstRow !== null) {\n      const entries = Object.entries(firstRow);\n      // Simple count: single \"count\" key -> return just the number\n      if (entries.length === 1 && entries[0][0] === \"count\") {\n        const value = entries[0][1];\n        return typeof value === \"bigint\" ? Number(value) : Number(value);\n      }\n      // Multiple counts (with select) -> return object\n      const result: Record<string, number> = {};\n      for (const [key, value] of entries) {\n        result[key] = typeof value === \"bigint\" ? Number(value) : Number(value);\n      }\n      return result;\n    }\n  }\n\n  // Object with count(s)\n  if (typeof raw === \"object\" && raw !== null) {\n    const entries = Object.entries(raw as Record<string, unknown>);\n    // Simple count: single \"count\" key -> return just the number\n    if (entries.length === 1 && entries[0][0] === \"count\") {\n      const value = entries[0][1];\n      return typeof value === \"bigint\" ? Number(value) : Number(value);\n    }\n    // Multiple counts -> return object\n    const result: Record<string, number> = {};\n    for (const [key, value] of entries) {\n      result[key] = typeof value === \"bigint\" ? Number(value) : Number(value);\n    }\n    return result;\n  }\n\n  return 0;\n}\n\n/**\n * Parse mutation result to get affected count\n */\nexport function parseMutationCount(raw: unknown): { count: number } {\n  if (raw === null || raw === undefined) {\n    return { count: 0 };\n  }\n\n  // Direct count\n  if (typeof raw === \"number\") {\n    return { count: raw };\n  }\n\n  // Object with count or rowCount\n  if (typeof raw === \"object\" && raw !== null) {\n    const obj = raw as Record<string, unknown>;\n    if (\"count\" in obj) {\n      return { count: Number(obj.count) };\n    }\n    if (\"rowCount\" in obj) {\n      return { count: Number(obj.rowCount) };\n    }\n    if (\"affectedRows\" in obj) {\n      return { count: Number(obj.affectedRows) };\n    }\n  }\n\n  return { count: 0 };\n}\n","/**\n * Query Validator\n *\n * Single validator using model schemas.\n * Maps operation names to schema keys and validates input.\n */\n\nimport type { Model } from \"@schema/model\";\nimport { parse, type VibSchema } from \"@validation\";\nimport { type Operation, ValidationError } from \"./types\";\n\n/**\n * Get the appropriate schema for an operation\n */\nfunction getOperationSchema(\n  model: Model<any>,\n  operation: Operation\n): VibSchema | undefined {\n  const schemas = model[\"~\"].schemas;\n\n  // Map operations to their schema locations\n  switch (operation) {\n    case \"findFirst\":\n      return schemas.args?.findFirst;\n    case \"findMany\":\n      return schemas.args?.findMany;\n    case \"findUnique\":\n      return schemas.args?.findUnique;\n    case \"create\":\n      return schemas.args?.create;\n    case \"createMany\":\n      return schemas.args?.createMany;\n    case \"update\":\n      return schemas.args?.update;\n    case \"updateMany\":\n      return schemas.args?.updateMany;\n    case \"delete\":\n      return schemas.args?.delete;\n    case \"deleteMany\":\n      return schemas.args?.deleteMany;\n    case \"upsert\":\n      return schemas.args?.upsert;\n    case \"count\":\n      return schemas.args?.count;\n    case \"aggregate\":\n      return schemas.args?.aggregate;\n    case \"groupBy\":\n      return schemas.args?.groupBy;\n    case \"exist\":\n      // exist uses same schema as count but simpler\n      return schemas.args?.count;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Validate operation input against model schema\n *\n * @param model - The model to validate against\n * @param operation - The operation being performed\n * @param input - The input to validate\n * @returns The validated input (with defaults applied)\n * @throws ValidationError if validation fails\n */\nexport function validate<T>(\n  model: Model<any>,\n  operation: Operation,\n  input: unknown\n): T {\n  const schema = getOperationSchema(model, operation);\n\n  if (!schema) {\n    throw new ValidationError(\n      operation,\n      `Schema not found for operation: ${operation}`\n    );\n  }\n\n  const result = parse(schema, input);\n\n  if (result.issues) {\n    const issues = result.issues\n      .map(\n        (issue) =>\n          `${issue.path?.map((p: any) => p.key).join(\".\") || \"root\"}: ${issue.message}`\n      )\n      .join(\"; \");\n    throw new ValidationError(operation, issues);\n  }\n\n  return result.value as T;\n}\n\n/**\n * Validate with optional - returns undefined instead of throwing for missing optional input\n */\nexport function validateOptional<T>(\n  model: Model<any>,\n  operation: Operation,\n  input: unknown\n): T | undefined {\n  if (input === undefined || input === null) {\n    return undefined;\n  }\n  return validate<T>(model, operation, input);\n}\n","/**\n * Query Engine\n *\n * Main orchestrator that builds and executes queries.\n * Validates input, builds SQL, and parses results.\n */\n\nimport type { DatabaseAdapter } from \"@adapters\";\nimport type { Driver } from \"@drivers\";\nimport { hydrateSchemaNames } from \"@schema/hydration\";\nimport type { Model } from \"@schema/model\";\nimport type { Sql } from \"@sql\";\nimport { getPrimaryKeyField } from \"./builders/correlation-utils\";\nimport { buildCreateWithNested } from \"./builders/nested-create-builder\";\nimport {\n  buildConnectFkValues,\n  canUseSubqueryOnly,\n  needsTransaction,\n  separateData,\n} from \"./builders/relation-data-builder\";\nimport { createQueryContext } from \"./context\";\nimport {\n  buildAggregate,\n  buildCount,\n  buildCreate,\n  buildCreateMany,\n  buildDelete,\n  buildDeleteMany,\n  buildFindFirst,\n  buildFindMany,\n  buildFindUnique,\n  buildGroupBy,\n  buildUpdate,\n  buildUpdateMany,\n  buildUpsert,\n  executeNestedCreate,\n  executeNestedUpdate,\n} from \"./operations\";\nimport { buildFindUnique as buildFindUniqueQuery } from \"./operations/find-unique\";\nimport { parseResult } from \"./result\";\nimport {\n  isBatchOperation,\n  type ModelRegistry,\n  type Operation,\n  type QueryContext,\n  QueryEngineError,\n} from \"./types\";\nimport { validate } from \"./validator\";\n\n/**\n * Query Engine class\n *\n * Responsible for:\n * 1. Validating input against model schemas\n * 2. Building SQL using the adapter\n * 3. Executing queries via driver\n * 4. Parsing results into typed objects\n */\nexport class QueryEngine {\n  constructor(\n    private readonly adapter: DatabaseAdapter,\n    private readonly registry: ModelRegistry,\n    private readonly driver?: Driver\n  ) {}\n\n  /**\n   * Build SQL for an operation without executing\n   * Useful for debugging or using with a different executor\n   */\n  build(\n    model: Model<any>,\n    operation: Operation,\n    args: Record<string, unknown>\n  ): Sql {\n    // Validate input\n    const validated = validate<Record<string, unknown>>(model, operation, args);\n\n    // Create context\n    const ctx = createQueryContext(this.adapter, model, this.registry);\n\n    // For create operations, check for nested creates and use CTE-based builder\n    if (operation === \"create\" && validated.data) {\n      const data = validated.data as Record<string, unknown>;\n      const { relations } = separateData(ctx, data);\n\n      // Check for nested creates\n      const hasNestedCreates = Object.values(relations).some((m) => m.create);\n\n      if (hasNestedCreates) {\n        // Use multi-statement nested create builder\n        const result = buildCreateWithNested(\n          ctx,\n          data,\n          validated.select as Record<string, unknown> | undefined,\n          validated.include as Record<string, unknown> | undefined\n        );\n        return result.sql;\n      }\n\n      // No nested creates - process connect operations and use standard builder\n      const processedArgs = this.processConnectOperations(\n        ctx,\n        operation,\n        validated\n      );\n      return this.buildOperation(ctx, operation, processedArgs);\n    }\n\n    // For update operations, process connect operations to inline FK values\n    if (operation === \"update\") {\n      const processedArgs = this.processConnectOperations(\n        ctx,\n        operation,\n        validated\n      );\n      return this.buildOperation(ctx, operation, processedArgs);\n    }\n\n    // Build SQL\n    return this.buildOperation(ctx, operation, validated);\n  }\n\n  /**\n   * Process connect operations in data to inline FK values\n   * This allows build() to generate correct SQL for simple connect cases\n   * without needing a transaction.\n   */\n  private processConnectOperations(\n    ctx: QueryContext,\n    operation: Operation,\n    args: Record<string, unknown>\n  ): Record<string, unknown> {\n    const data =\n      operation === \"create\" || operation === \"update\"\n        ? (args.data as Record<string, unknown>)\n        : undefined;\n\n    if (!data) return args;\n\n    const { scalar, relations } = separateData(ctx, data);\n\n    // Check if any relations need processing\n    if (Object.keys(relations).length === 0) {\n      return args;\n    }\n\n    // Process connect operations where current model holds FK\n    const processedData = { ...scalar };\n\n    for (const [, mutation] of Object.entries(relations)) {\n      // Handle connect: inline FK value or subquery\n      if (mutation.connect && mutation.relationInfo.fields?.length) {\n        // For subquery approach, we only handle single connect\n        const connectInput = Array.isArray(mutation.connect)\n          ? mutation.connect[0]\n          : mutation.connect;\n\n        if (connectInput) {\n          const fkValues = buildConnectFkValues(\n            ctx,\n            mutation.relationInfo,\n            connectInput\n          );\n          // Add FK values to processed data\n          Object.assign(processedData, fkValues);\n        }\n      }\n\n      // Handle disconnect: set FK to NULL\n      if (mutation.disconnect && mutation.relationInfo.fields?.length) {\n        for (const fkField of mutation.relationInfo.fields) {\n          processedData[fkField] = null;\n        }\n      }\n    }\n\n    return { ...args, data: processedData };\n  }\n\n  /**\n   * Execute an operation and return parsed results\n   */\n  async execute<T>(\n    model: Model<any>,\n    operation: Operation,\n    args: Record<string, unknown>\n  ): Promise<T> {\n    if (!this.driver) {\n      throw new QueryEngineError(\n        \"No driver provided. Use build() to get SQL without executing.\"\n      );\n    }\n\n    // Validate input\n    const validated = validate<Record<string, unknown>>(model, operation, args);\n\n    // Create context once and reuse for both building and parsing\n    const ctx = createQueryContext(this.adapter, model, this.registry);\n\n    // Check if this is a mutation with nested writes\n    if (this.hasNestedWrites(operation, validated)) {\n      return this.executeWithNestedWrites<T>(ctx, operation, validated);\n    }\n\n    // Build SQL\n    const sqlQuery = this.buildOperation(ctx, operation, validated);\n\n    // Execute via driver\n    const result = await this.driver.execute(sqlQuery);\n\n    // Parse result using the same context\n    // For batch operations, pass rowCount; for others, pass rows\n    if (isBatchOperation(operation)) {\n      return parseResult<T>(ctx, operation, { rowCount: result.rowCount });\n    }\n    return parseResult<T>(ctx, operation, result.rows);\n  }\n\n  /**\n   * Check if an operation has nested write operations\n   */\n  private hasNestedWrites(\n    operation: Operation,\n    args: Record<string, unknown>\n  ): boolean {\n    // Only create, update, and upsert can have nested writes\n    if (![\"create\", \"update\", \"upsert\"].includes(operation)) {\n      return false;\n    }\n\n    const data =\n      operation === \"upsert\"\n        ? (args.create as Record<string, unknown>) ||\n          (args.update as Record<string, unknown>)\n        : (args.data as Record<string, unknown>);\n\n    if (!data) return false;\n\n    // Check for any relation mutations in the data\n    for (const value of Object.values(data)) {\n      if (value && typeof value === \"object\" && !Array.isArray(value)) {\n        const obj = value as Record<string, unknown>;\n        if (\n          \"connect\" in obj ||\n          \"create\" in obj ||\n          \"connectOrCreate\" in obj ||\n          \"disconnect\" in obj ||\n          \"delete\" in obj ||\n          \"set\" in obj\n        ) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Execute a mutation with nested write operations\n   */\n  private async executeWithNestedWrites<T>(\n    ctx: QueryContext,\n    operation: Operation,\n    args: Record<string, unknown>\n  ): Promise<T> {\n    const driver = this.driver!;\n\n    switch (operation) {\n      case \"create\": {\n        const data = args.data as Record<string, unknown>;\n        const { scalar, relations } = separateData(ctx, data);\n\n        // Check if we can use subquery-only approach (no transaction needed)\n        // Additional check: if any connect has multiple items, force transaction\n        // (because we can only set one FK value per INSERT)\n        const hasMultipleConnects = Object.values(relations).some(\n          (mutation) =>\n            mutation.connect &&\n            Array.isArray(mutation.connect) &&\n            mutation.connect.length > 1\n        );\n\n        if (canUseSubqueryOnly(relations) && !hasMultipleConnects) {\n          // Add FK values from connect operations as subqueries\n          const dataWithFks = { ...scalar };\n          for (const [, mutation] of Object.entries(relations)) {\n            if (mutation.connect && mutation.relationInfo.fields?.length) {\n              // For subquery approach, we only handle single connect\n              // (array connects with >1 item are handled by transaction path above)\n              const connectInput = Array.isArray(mutation.connect)\n                ? mutation.connect[0]!\n                : mutation.connect;\n              const fkValues = buildConnectFkValues(\n                ctx,\n                mutation.relationInfo,\n                connectInput\n              );\n              // Add FK values to scalar data (they are Sql subqueries)\n              Object.assign(dataWithFks, fkValues);\n            }\n          }\n\n          // Build and execute single INSERT with subqueries\n          const sqlQuery = buildCreate(ctx, {\n            data: dataWithFks,\n            select: args.select as Record<string, unknown>,\n            include: args.include as Record<string, unknown>,\n          });\n          const result = await driver.execute(sqlQuery);\n          return parseResult<T>(ctx, operation, result.rows);\n        }\n\n        // Need transaction for complex nested writes\n        const createResult = await executeNestedCreate(driver, ctx, data);\n\n        // Handle include/select for return value\n        if (args.include || args.select) {\n          // Re-fetch the created record with includes\n          const pkField = getPrimaryKeyField(ctx.model);\n          const pkValue = createResult.record[pkField];\n          if (pkValue !== undefined) {\n            const refetchArgs = {\n              where: { [pkField]: pkValue },\n              select: args.select,\n              include: args.include,\n            };\n            const refetchSql = buildFindUniqueQuery(\n              ctx,\n              refetchArgs as { where: Record<string, unknown> }\n            );\n            const refetchResult = await driver.execute(refetchSql);\n            if (refetchResult.rows.length > 0) {\n              return parseResult<T>(ctx, \"findUnique\", refetchResult.rows);\n            }\n          }\n        }\n\n        // Return the created record with nested records merged\n        const finalRecord = { ...createResult.record, ...createResult.related };\n        return finalRecord as T;\n      }\n\n      case \"update\": {\n        // For update, we first execute the update, then handle nested operations\n        const data = args.data as Record<string, unknown>;\n        const where = args.where as Record<string, unknown>;\n        const { scalar, relations } = separateData(ctx, data);\n\n        // Check if we need a transaction for nested operations\n        if (Object.keys(relations).length > 0 && needsTransaction(relations)) {\n          return driver.transaction(async (tx) => {\n            // First, update the scalar fields\n            if (Object.keys(scalar).length > 0) {\n              const updateSql = buildUpdate(ctx, { where, data: scalar });\n              await tx.execute(updateSql);\n            }\n\n            // Get the updated record for FK operations\n            const selectSql = buildFindUniqueQuery(ctx, { where });\n            const selectResult =\n              await tx.execute<Record<string, unknown>>(selectSql);\n            const updatedRecord = selectResult.rows[0];\n\n            if (!updatedRecord) {\n              throw new QueryEngineError(\"Record to update not found\");\n            }\n\n            // Handle relation mutations (connect, disconnect, create, delete)\n            await executeNestedUpdate(tx, ctx, updatedRecord, relations);\n\n            // Re-fetch with includes if needed\n            if (args.include || args.select) {\n              const refetchSql = buildFindUniqueQuery(ctx, {\n                where,\n                select: args.select as Record<string, unknown> | undefined,\n                include: args.include as Record<string, unknown> | undefined,\n              } as { where: Record<string, unknown> });\n              const refetchResult =\n                await tx.execute<Record<string, unknown>>(refetchSql);\n              return parseResult<T>(ctx, \"findUnique\", refetchResult.rows);\n            }\n\n            return updatedRecord as T;\n          });\n        }\n\n        // Simple update without nested operations\n        const updateSql = buildUpdate(\n          ctx,\n          args as {\n            where: Record<string, unknown>;\n            data: Record<string, unknown>;\n          }\n        );\n        const result = await driver.execute(updateSql);\n        return parseResult<T>(ctx, operation, result.rows);\n      }\n\n      case \"upsert\": {\n        // Upsert with nested writes is complex - for now, delegate to transaction\n        return driver.transaction(async (tx) => {\n          const where = args.where as Record<string, unknown>;\n\n          // Check if record exists\n          const selectSql = buildFindUniqueQuery(ctx, { where });\n          const selectResult =\n            await tx.execute<Record<string, unknown>>(selectSql);\n\n          if (selectResult.rows.length > 0) {\n            // Record exists - do update\n            const updateData = args.update as Record<string, unknown>;\n            const { scalar } = separateData(ctx, updateData);\n\n            if (Object.keys(scalar).length > 0) {\n              const updateSql = buildUpdate(ctx, { where, data: scalar });\n              await tx.execute(updateSql);\n            }\n\n            // Re-fetch\n            const refetchResult =\n              await tx.execute<Record<string, unknown>>(selectSql);\n            return parseResult<T>(ctx, \"findUnique\", refetchResult.rows);\n          }\n          // Record doesn't exist - do create\n          const createData = args.create as Record<string, unknown>;\n          const createResult = await executeNestedCreate(tx, ctx, createData);\n          return createResult.record as T;\n        });\n      }\n\n      default:\n        throw new QueryEngineError(\n          `Nested writes not supported for operation: ${operation}`\n        );\n    }\n  }\n\n  /**\n   * Get the driver instance for direct access\n   */\n  getDriver(): Driver | undefined {\n    return this.driver;\n  }\n\n  /**\n   * Build SQL for a specific operation\n   */\n  private buildOperation(\n    ctx: QueryContext,\n    operation: Operation,\n    args: Record<string, unknown>\n  ): Sql {\n    switch (operation) {\n      case \"findFirst\":\n        return buildFindFirst(ctx, args);\n\n      case \"findMany\":\n        return buildFindMany(ctx, args);\n\n      case \"findUnique\":\n        return buildFindUnique(ctx, args as { where: Record<string, unknown> });\n\n      case \"create\":\n        return buildCreate(ctx, args as { data: Record<string, unknown> });\n\n      case \"createMany\":\n        return buildCreateMany(\n          ctx,\n          args.data as Record<string, unknown>[],\n          args.skipDuplicates as boolean | undefined\n        );\n\n      case \"update\":\n        return buildUpdate(\n          ctx,\n          args as {\n            where: Record<string, unknown>;\n            data: Record<string, unknown>;\n          }\n        );\n\n      case \"updateMany\":\n        return buildUpdateMany(\n          ctx,\n          args as {\n            where?: Record<string, unknown>;\n            data: Record<string, unknown>;\n          }\n        );\n\n      case \"delete\":\n        return buildDelete(ctx, args as { where: Record<string, unknown> });\n\n      case \"deleteMany\":\n        return buildDeleteMany(\n          ctx,\n          args as { where?: Record<string, unknown> }\n        );\n\n      case \"upsert\":\n        return buildUpsert(\n          ctx,\n          args as {\n            where: Record<string, unknown>;\n            create: Record<string, unknown>;\n            update: Record<string, unknown>;\n          }\n        );\n\n      case \"count\":\n        return buildCount(ctx, args);\n\n      case \"aggregate\":\n        return buildAggregate(ctx, args);\n\n      case \"groupBy\":\n        return buildGroupBy(ctx, args as { by: string | string[] });\n\n      case \"exist\": {\n        // Exist is a simple count > 0 check\n        const existArgs: { where?: Record<string, unknown> } = {};\n        if (args.where) existArgs.where = args.where as Record<string, unknown>;\n        return buildCount(ctx, existArgs);\n      }\n\n      default:\n        throw new QueryEngineError(`Unknown operation: ${operation}`);\n    }\n  }\n}\n\n/**\n * Create a simple in-memory model registry\n */\nexport function createModelRegistry(\n  models: Record<string, Model<any>>\n): ModelRegistry {\n  hydrateSchemaNames(models);\n  const byName = new Map<string, Model<any>>();\n  const byTableName = new Map<string, Model<any>>();\n\n  for (const [name, model] of Object.entries(models)) {\n    byName.set(name, model);\n    const tableName = model[\"~\"].names.sql ?? name;\n    byTableName.set(tableName, model);\n  }\n\n  return {\n    get(name: string): Model<any> | undefined {\n      return byName.get(name);\n    },\n    getByTableName(tableName: string): Model<any> | undefined {\n      return byTableName.get(tableName);\n    },\n  };\n}\n\n/**\n * Factory function to create a query engine\n */\nexport function createQueryEngine(\n  adapter: DatabaseAdapter,\n  models: Record<string, Model<any>>,\n  driver?: Driver\n): QueryEngine {\n  const registry = createModelRegistry(models);\n  return new QueryEngine(adapter, registry, driver);\n}\n","import type { Driver, QueryResult, TransactionOptions } from \"@drivers\";\nimport { createModelRegistry, QueryEngine } from \"@query-engine/query-engine\";\nimport type { Operation } from \"@query-engine/types\";\nimport { hydrateSchemaNames } from \"@schema/hydration\";\nimport type { Sql } from \"@sql\";\nimport type { CacheDriver, CacheOptions } from \"./cache/types\";\nimport type { Client, Operations, Schema } from \"./types\";\n\n/**\n * Error thrown when a record is not found for OrThrow operations\n */\nexport class NotFoundError extends Error {\n  readonly model: string;\n  readonly operation: string;\n  constructor(model: string, operation: string) {\n    super(`No ${model} record found for ${operation}`);\n    this.model = model;\n    this.operation = operation;\n    this.name = \"NotFoundError\";\n  }\n}\n\n/**\n * Create a recursive proxy for model operations\n */\nfunction createModelProxy<S extends Schema>(\n  schema: S,\n  executeOperation: (opts: {\n    modelName: keyof S;\n    operation: Operations;\n    args: unknown;\n  }) => Promise<unknown>,\n  path: string[] = []\n): unknown {\n  // biome-ignore lint: <it's ok>\n  return new Proxy(() => {}, {\n    get(_target, key) {\n      if (typeof key !== \"string\") return undefined;\n      // Prevent Promise-like behavior - return undefined for 'then'\n      // This allows the proxy to be returned from async functions without\n      // being treated as a thenable\n      if (key === \"then\") return undefined;\n      return createModelProxy(schema, executeOperation, [...path, key]);\n    },\n    apply(_target, _thisArg, [args]) {\n      const modelName = path[0] as keyof S;\n      const operation = path[1] as Operations;\n      return executeOperation({ modelName, operation, args });\n    },\n  });\n}\n\n/**\n * VibORM Configuration\n */\nexport interface VibORMConfig<S extends Schema> {\n  schema: S;\n  driver: Driver;\n  cache?: CacheDriver;\n}\n\n/**\n * Extended client type with utility methods\n */\nexport type VibORMClient<S extends Schema> = Client<S> & {\n  /** Access the underlying driver */\n  $driver: Driver;\n  /** Execute a raw SQL query */\n  $executeRaw: <T = Record<string, unknown>>(\n    query: Sql\n  ) => Promise<QueryResult<T>>;\n  /** Execute a raw SQL string */\n  $queryRaw: <T = Record<string, unknown>>(\n    sql: string,\n    params?: unknown[]\n  ) => Promise<QueryResult<T>>;\n  /** Run operations in a transaction */\n  $transaction: <T>(\n    fn: (tx: Client<S>) => Promise<T>,\n    options?: TransactionOptions\n  ) => Promise<T>;\n  /** Connect to the database */\n  $connect: () => Promise<void>;\n  /** Disconnect from the database */\n  $disconnect: () => Promise<void>;\n  /** Create a client with cache */\n  withCache: (config: CacheOptions) => Client<S>;\n};\n\n/**\n * VibORM Client\n */\nexport class VibORM<S extends Schema> {\n  private readonly driver: Driver;\n  private readonly schema: S;\n  private readonly cache: CacheDriver | undefined;\n\n  constructor(config: VibORMConfig<S>) {\n    this.driver = config.driver;\n    this.schema = config.schema;\n    this.cache = config.cache;\n  }\n\n  /**\n   * Create the client with model proxies and utility methods\n   */\n  private createClient(driver: Driver = this.driver): Client<S> {\n    // Create a query engine for this driver (may be transaction driver)\n    const registry = createModelRegistry(this.schema as Record<string, any>);\n    const engine = new QueryEngine(driver.adapter, registry, driver);\n\n    return createModelProxy(\n      this.schema,\n      async ({ modelName, operation, args }) => {\n        const model = this.schema[modelName];\n        if (!model) {\n          throw new Error(`Model \"${String(modelName)}\" not found in schema`);\n        }\n\n        // Strip \"OrThrow\" suffix for query engine (it only knows base operations)\n        const OR_THROW_SUFFIX = \"OrThrow\";\n        const baseOperation = operation.endsWith(OR_THROW_SUFFIX)\n          ? (operation.slice(0, -OR_THROW_SUFFIX.length) as Operation)\n          : (operation as Operation);\n\n        const result = await engine.execute(\n          model,\n          baseOperation,\n          (args ?? {}) as Record<string, unknown>\n        );\n\n        if (operation.endsWith(\"OrThrow\")) {\n          if (result === null) {\n            throw new NotFoundError(String(modelName), operation);\n          }\n          return result;\n        }\n\n        // Handle exist operation (convert count to boolean)\n        if (operation === \"exist\") {\n          return (result as number) > 0;\n        }\n\n        return result;\n      }\n    ) as Client<S>;\n  }\n\n  /**\n   * Create a client with caching enabled\n   */\n  withCache(_config: CacheOptions): Client<S> {\n    // TODO: Implement caching layer\n    // For now, return a regular client\n    return this.createClient();\n  }\n\n  /**\n   * Create the full client with all utility methods\n   */\n  static create<S extends Schema>(config: VibORMConfig<S>): VibORMClient<S> {\n    // Hydrate schema names (tsName, sqlName) for all models, fields, and relations\n    hydrateSchemaNames(config.schema);\n\n    const orm = new VibORM(config);\n    const client = orm.createClient();\n\n    // Create proxy that combines model operations with utility methods\n    return new Proxy(client, {\n      get(target, prop) {\n        // Utility methods\n        if (prop === \"$driver\") {\n          return orm.driver;\n        }\n\n        if (prop === \"$executeRaw\") {\n          return <T>(query: Sql) => orm.driver.execute<T>(query);\n        }\n\n        if (prop === \"$queryRaw\") {\n          return <T>(sql: string, params?: unknown[]) =>\n            orm.driver.executeRaw<T>(sql, params);\n        }\n\n        if (prop === \"$transaction\") {\n          return <T>(\n            fn: (tx: Client<S>) => Promise<T>,\n            options?: TransactionOptions\n          ) => {\n            return orm.driver.transaction((txDriver) => {\n              // Create a transactional client backed by the tx driver\n              const txClient = orm.createClient(txDriver);\n              return fn(txClient);\n            }, options);\n          };\n        }\n\n        if (prop === \"$connect\") {\n          return () => orm.driver.connect?.() ?? Promise.resolve();\n        }\n\n        if (prop === \"$disconnect\") {\n          return () => orm.driver.disconnect?.() ?? Promise.resolve();\n        }\n\n        if (prop === \"withCache\") {\n          return (cacheConfig: CacheOptions) => orm.withCache(cacheConfig);\n        }\n\n        // Model operations\n        return (target as any)[prop];\n      },\n    }) as VibORMClient<S>;\n  }\n}\n\n/**\n * Create a VibORM client\n *\n * @example\n * ```ts\n * import { PGlite } from \"@electric-sql/pglite\";\n * import { PGliteDriver } from \"viborm/drivers/pglite\";\n * import { createClient } from \"viborm\";\n *\n * const db = new PGlite();\n * const driver = new PGliteDriver({ client: db });\n * const client = createClient({ driver, schema: { user, post } });\n *\n * // Query\n * const users = await client.user.findMany({ where: { name: \"Alice\" } });\n *\n * // Transaction\n * await client.$transaction(async (tx) => {\n *   const user = await tx.user.create({ data: { name: \"Bob\" } });\n *   await tx.post.create({ data: { title: \"Hello\", authorId: user.id } });\n * });\n *\n * // Raw query\n * const result = await client.$executeRaw(sql`SELECT * FROM users`);\n *\n * // Disconnect\n * await client.$disconnect();\n * ```\n */\nexport const createClient = <S extends Schema>(\n  config: VibORMConfig<S>\n): VibORMClient<S> => {\n  return VibORM.create(config);\n};\n"],"mappings":"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"}