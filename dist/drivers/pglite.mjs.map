{"version":3,"file":"pglite.mjs","names":["baseCreateClient"],"sources":["../../src/drivers/pglite/index.ts"],"sourcesContent":["/**\n * PGlite Driver\n *\n * Driver implementation for PGlite (PostgreSQL in WebAssembly).\n * Supports optional pgvector and PostGIS extensions.\n */\n\nimport type { DatabaseAdapter } from \"@adapters/database-adapter\";\nimport { PostgresAdapter } from \"@adapters/databases/postgres/postgres-adapter\";\nimport {\n  createClient as baseCreateClient,\n  type VibORMClient,\n} from \"@client/client\";\nimport type { Schema } from \"@client/types\";\nimport type { Sql } from \"@sql\";\nimport type { Driver } from \"../driver\";\nimport { unsupportedGeospatial, unsupportedVector } from \"../errors\";\nimport type { Dialect, QueryResult, TransactionOptions } from \"../types\";\n\n/**\n * PGlite client interface (from @electric-sql/pglite)\n */\ninterface PGliteClient {\n  query<T = Record<string, unknown>>(\n    sql: string,\n    params?: unknown[]\n  ): Promise<{ rows: T[]; affectedRows?: number }>;\n  transaction<T>(fn: (tx: PGliteTransaction) => Promise<T>): Promise<T>;\n  close(): Promise<void>;\n}\n\n/**\n * PGlite transaction interface\n */\ninterface PGliteTransaction {\n  query<T = Record<string, unknown>>(\n    sql: string,\n    params?: unknown[]\n  ): Promise<{ rows: T[]; affectedRows?: number }>;\n}\n\n/**\n * PGlite constructor interface (for auto-creation)\n */\ninterface PGliteConstructor {\n  new (dataDir?: string): PGliteClient;\n}\n\n/**\n * PGlite driver options\n */\nexport interface PGliteDriverOptions {\n  /**\n   * PGlite client instance.\n   * If not provided, a new PGlite instance will be created with the dataDir option.\n   */\n  client?: PGliteClient;\n  /**\n   * Data directory for PGlite persistence.\n   * Only used when client is not provided.\n   * Defaults to \".pglite\"\n   */\n  dataDir?: string;\n  /** Enable pgvector extension support (default: false) */\n  pgvector?: boolean;\n  /** Enable PostGIS extension support (default: false) */\n  postgis?: boolean;\n}\n\n/**\n * PGlite client config for createClient\n */\nexport interface PGliteClientConfig<S extends Schema> {\n  /** Schema models */\n  schema: S;\n  /**\n   * PGlite client instance.\n   * If not provided, a new PGlite instance will be created with the dataDir option.\n   */\n  client?: PGliteClient;\n  /**\n   * Data directory for PGlite persistence.\n   * Only used when client is not provided.\n   * Defaults to \".pglite\"\n   */\n  dataDir?: string;\n  /** Enable pgvector extension support (default: false) */\n  pgvector?: boolean;\n  /** Enable PostGIS extension support (default: false) */\n  postgis?: boolean;\n}\n\n// Lazily loaded PGlite constructor\nlet PGliteClass: PGliteConstructor | null = null;\n\n/**\n * Build a PostgreSQL statement with $1, $2, etc. placeholders\n */\nfunction buildPostgresStatement(query: Sql): string {\n  const len = query.strings.length;\n  let i = 1;\n  let result = query.strings[0] ?? \"\";\n  while (i < len) {\n    result += `$${i}${query.strings[i] ?? \"\"}`;\n    i++;\n  }\n  return result;\n}\n\n/**\n * Get PGlite constructor, loading it dynamically if needed\n */\nasync function getPGliteClass(): Promise<PGliteConstructor> {\n  if (PGliteClass) return PGliteClass;\n\n  try {\n    const module = await import(\"@electric-sql/pglite\");\n    PGliteClass = module.PGlite;\n    return PGliteClass;\n  } catch {\n    throw new Error(\n      \"PGlite is not installed. Install it with: npm install @electric-sql/pglite\"\n    );\n  }\n}\n\n/**\n * PGlite Driver\n *\n * Implements the Driver interface for PGlite.\n *\n * @example Basic usage with auto-created client\n * ```ts\n * import { createClient } from \"viborm/drivers/pglite\";\n *\n * const client = await createClient({ schema });\n * // Data persisted to .viborm/pglite by default\n * ```\n *\n * @example With custom data directory\n * ```ts\n * import { createClient } from \"viborm/drivers/pglite\";\n *\n * const client = await createClient({\n *   schema,\n *   dataDir: \"./my-data/db\"\n * });\n * ```\n *\n * @example With existing PGlite client\n * ```ts\n * import { PGlite } from \"@electric-sql/pglite\";\n * import { createClient } from \"viborm/drivers/pglite\";\n *\n * const db = new PGlite();\n * const client = await createClient({ client: db, schema });\n * ```\n *\n * @example With pgvector extension\n * ```ts\n * import { PGlite } from \"@electric-sql/pglite\";\n * import { vector } from \"@electric-sql/pglite/vector\";\n * import { createClient } from \"viborm/drivers/pglite\";\n *\n * const db = new PGlite({ extensions: { vector } });\n * const client = await createClient({ client: db, schema, pgvector: true });\n * ```\n */\nexport class PGliteDriver implements Driver {\n  readonly dialect: Dialect = \"postgresql\";\n  readonly adapter: DatabaseAdapter;\n\n  private readonly client: PGliteClient;\n\n  constructor(options: PGliteDriverOptions & { client: PGliteClient }) {\n    this.client = options.client;\n\n    // Create adapter and override unsupported features\n    const adapter = new PostgresAdapter();\n\n    if (!options.pgvector) {\n      adapter.vector = unsupportedVector;\n    }\n\n    if (!options.postgis) {\n      adapter.geospatial = unsupportedGeospatial;\n    }\n\n    this.adapter = adapter;\n  }\n\n  /**\n   * Create a PGliteDriver, auto-creating the PGlite client if not provided\n   */\n  static async create(\n    options: PGliteDriverOptions = {}\n  ): Promise<PGliteDriver> {\n    let client = options.client;\n\n    if (!client) {\n      const PGlite = await getPGliteClass();\n      const dataDir = options.dataDir ?? \".pglite\";\n      client = new PGlite(dataDir);\n    }\n\n    return new PGliteDriver({ ...options, client });\n  }\n\n  async execute<T = Record<string, unknown>>(\n    query: Sql\n  ): Promise<QueryResult<T>> {\n    // Build parameterized statement with $1, $2, etc. placeholders\n    const statement = buildPostgresStatement(query);\n    const result = await this.client.query<T>(statement, query.values);\n    return {\n      rows: result.rows,\n      rowCount: result.affectedRows ?? result.rows.length,\n    };\n  }\n\n  async executeRaw<T = Record<string, unknown>>(\n    sql: string,\n    params?: unknown[]\n  ): Promise<QueryResult<T>> {\n    const result = await this.client.query<T>(sql, params);\n    return {\n      rows: result.rows,\n      rowCount: result.affectedRows ?? result.rows.length,\n    };\n  }\n\n  transaction<T>(\n    fn: (tx: Driver) => Promise<T>,\n    _options?: TransactionOptions\n  ): Promise<T> {\n    return this.client.transaction((tx) => {\n      const txDriver = new PGliteTransactionDriver(tx, this.adapter);\n      return fn(txDriver);\n    });\n  }\n\n  async disconnect(): Promise<void> {\n    await this.client.close();\n  }\n}\n\n/**\n * PGlite Transaction Driver\n *\n * Driver implementation for transactions within PGlite.\n */\nclass PGliteTransactionDriver implements Driver {\n  readonly dialect: Dialect = \"postgresql\";\n  readonly adapter: DatabaseAdapter;\n  readonly tx: PGliteTransaction;\n  constructor(tx: PGliteTransaction, adapter: DatabaseAdapter) {\n    this.tx = tx;\n    this.adapter = adapter;\n  }\n\n  async execute<T = Record<string, unknown>>(\n    query: Sql\n  ): Promise<QueryResult<T>> {\n    const statement = buildPostgresStatement(query);\n    const result = await this.tx.query<T>(statement, query.values);\n    return {\n      rows: result.rows,\n      rowCount: result.affectedRows ?? result.rows.length,\n    };\n  }\n\n  async executeRaw<T = Record<string, unknown>>(\n    sql: string,\n    params?: unknown[]\n  ): Promise<QueryResult<T>> {\n    const result = await this.tx.query<T>(sql, params);\n    return {\n      rows: result.rows,\n      rowCount: result.affectedRows ?? result.rows.length,\n    };\n  }\n\n  transaction<T>(fn: (tx: Driver) => Promise<T>): Promise<T> {\n    // Nested transaction - PGlite doesn't support savepoints,\n    // so we run in the same transaction context\n    return fn(this);\n  }\n}\n\n/**\n * Create a VibORM client with PGlite driver\n *\n * Convenience function that creates the driver and client in one step.\n * If no PGlite client is provided, one will be created automatically\n * with data persisted to `.viborm/pglite` (or custom dataDir).\n *\n * @example\n * ```ts\n * import { createClient } from \"viborm/drivers/pglite\";\n *\n * const client = await createClient({ schema: { user, post } });\n *\n * // With custom data directory\n * const client = await createClient({\n *   schema: { user, post },\n *   dataDir: \"./data/mydb\"\n * });\n * ```\n */\nexport async function createClient<S extends Schema>(\n  config: PGliteClientConfig<S>\n): Promise<VibORMClient<S>> {\n  const { client, dataDir, pgvector, postgis, ...restConfig } = config;\n\n  const driverOptions: PGliteDriverOptions = {};\n  if (client !== undefined) driverOptions.client = client;\n  if (dataDir !== undefined) driverOptions.dataDir = dataDir;\n  if (pgvector !== undefined) driverOptions.pgvector = pgvector;\n  if (postgis !== undefined) driverOptions.postgis = postgis;\n\n  const driver = await PGliteDriver.create(driverOptions);\n\n  return baseCreateClient<S>({\n    ...restConfig,\n    driver,\n  }) as VibORMClient<S>;\n}\n"],"mappings":"yKA6FA,IAAI,EAAwC,KAK5C,SAAS,EAAuB,EAAoB,CAClD,IAAM,EAAM,EAAM,QAAQ,OACtB,EAAI,EACJ,EAAS,EAAM,QAAQ,IAAM,GACjC,KAAO,EAAI,GACT,GAAU,IAAI,IAAI,EAAM,QAAQ,IAAM,KACtC,IAEF,OAAO,EAMT,eAAe,GAA6C,CAC1D,GAAI,EAAa,OAAO,EAExB,GAAI,CAGF,MADA,IADe,MAAM,OAAO,yBACP,OACd,OACD,CACN,MAAU,MACR,6EACD,EA8CL,IAAa,EAAb,MAAa,CAA+B,CAM1C,YAAY,EAAyD,cALzC,aAM1B,KAAK,OAAS,EAAQ,OAGtB,IAAM,EAAU,IAAI,EAEf,EAAQ,WACX,EAAQ,OAAS,GAGd,EAAQ,UACX,EAAQ,WAAa,GAGvB,KAAK,QAAU,EAMjB,aAAa,OACX,EAA+B,EAAE,CACV,CACvB,IAAI,EAAS,EAAQ,OAQrB,MANA,CAGE,IAAS,IAFM,MAAM,GAAgB,GACrB,EAAQ,SAAW,UACP,CAGvB,IAAI,EAAa,CAAE,GAAG,EAAS,SAAQ,CAAC,CAGjD,MAAM,QACJ,EACyB,CAEzB,IAAM,EAAY,EAAuB,EAAM,CACzC,EAAS,MAAM,KAAK,OAAO,MAAS,EAAW,EAAM,OAAO,CAClE,MAAO,CACL,KAAM,EAAO,KACb,SAAU,EAAO,cAAgB,EAAO,KAAK,OAC9C,CAGH,MAAM,WACJ,EACA,EACyB,CACzB,IAAM,EAAS,MAAM,KAAK,OAAO,MAAS,EAAK,EAAO,CACtD,MAAO,CACL,KAAM,EAAO,KACb,SAAU,EAAO,cAAgB,EAAO,KAAK,OAC9C,CAGH,YACE,EACA,EACY,CACZ,OAAO,KAAK,OAAO,YAAa,GAEvB,EADU,IAAI,EAAwB,EAAI,KAAK,QAAQ,CAC3C,CACnB,CAGJ,MAAM,YAA4B,CAChC,MAAM,KAAK,OAAO,OAAO,GASvB,EAAN,KAAgD,CAI9C,YAAY,EAAuB,EAA0B,cAHjC,aAI1B,KAAK,GAAK,EACV,KAAK,QAAU,EAGjB,MAAM,QACJ,EACyB,CACzB,IAAM,EAAY,EAAuB,EAAM,CACzC,EAAS,MAAM,KAAK,GAAG,MAAS,EAAW,EAAM,OAAO,CAC9D,MAAO,CACL,KAAM,EAAO,KACb,SAAU,EAAO,cAAgB,EAAO,KAAK,OAC9C,CAGH,MAAM,WACJ,EACA,EACyB,CACzB,IAAM,EAAS,MAAM,KAAK,GAAG,MAAS,EAAK,EAAO,CAClD,MAAO,CACL,KAAM,EAAO,KACb,SAAU,EAAO,cAAgB,EAAO,KAAK,OAC9C,CAGH,YAAe,EAA4C,CAGzD,OAAO,EAAG,KAAK,GAwBnB,eAAsB,EACpB,EAC0B,CAC1B,GAAM,CAAE,SAAQ,UAAS,WAAU,UAAS,GAAG,GAAe,EAExD,EAAqC,EAAE,CACzC,IAAW,IAAA,KAAW,EAAc,OAAS,GAC7C,IAAY,IAAA,KAAW,EAAc,QAAU,GAC/C,IAAa,IAAA,KAAW,EAAc,SAAW,GACjD,IAAY,IAAA,KAAW,EAAc,QAAU,GAEnD,IAAM,EAAS,MAAM,EAAa,OAAO,EAAc,CAEvD,OAAOA,EAAoB,CACzB,GAAG,EACH,SACD,CAAC"}