import{t as e}from"./sql-CFtZ-oR0.mjs";import{t}from"./validation-zYF7-cPF.mjs";function n(e){for(let[t,n]of Object.entries(e))r(t,n)}function r(e,t){let n=t[`~`].names,r=t[`~`].state,i=t[`~`].nameRegistry;n.ts=e,n.sql=r.tableName??e;for(let[e,t]of Object.entries(r.scalars)){let n={ts:e,sql:t[`~`].state.columnName??e};i.fields.set(e,n)}for(let[e]of Object.entries(r.relations)){let t={ts:e,sql:e};i.relations.set(e,t)}}var i=class e{constructor(){this.counter=0}next(){return`t${this.counter++}`}root(){return`t0`}current(){return`t${Math.max(0,this.counter-1)}`}reset(){this.counter=0}fork(){let t=new e;return t.counter=this.counter,t}};const a=()=>new i;function o(e,t,n){let r=a();return{adapter:e,model:t,registry:n,nextAlias:()=>r.next(),rootAlias:r.next()}}function s(e,t,n){return{adapter:e.adapter,model:t,registry:e.registry,nextAlias:e.nextAlias,rootAlias:n}}function c(e,t){let n=e.model[`~`].state.relations[t];if(!n)return;let r=n[`~`].state,i=r.getter(),a=r.type===`oneToMany`||r.type===`manyToMany`,o=r.type===`oneToOne`||r.type===`manyToOne`;return{name:t,relation:n,targetModel:i,type:r.type,isToMany:a,isToOne:o,isOptional:r.optional??!1,fields:r.fields,references:r.references}}function l(e){return e[`~`].names.sql??e[`~`].state.tableName??`unknown`}function u(e){return Object.keys(e[`~`].state.scalars)}function d(e,t){return t in e[`~`].state.scalars}function f(e,t){return t in e[`~`].state.relations}function p(e,t){return e[`~`].getFieldName(t).sql}const m=[`createMany`,`updateMany`,`deleteMany`];function h(e){return m.includes(e)}var g=class extends Error{constructor(e,t){super(`Validation failed for ${e}: ${t}`),this.operation=e,this.details=t,this.name=`ValidationError`}},_=class extends Error{constructor(e){super(e),this.name=`QueryEngineError`}},v=class extends _{constructor(e,t,n){super(e),this.relation=t,this.cause=n,this.name=`NestedWriteError`,n?.stack&&(this.stack=`${this.stack}\nCaused by: ${n.stack}`)}};function y(e,t,n,r){let{adapter:i}=e,a=t.relation[`~`].state,o,s,c=a.fields,l=a.references;if(c&&l&&c.length>0&&l.length>0)o=c,s=l;else if(a.type===`oneToMany`||a.type===`oneToOne`){let n=b(e,t);if(!n)throw new _(`Relation '${t.name}' on model '${x(e.model)}' requires an inverse relation on '${x(t.targetModel)}' with explicit 'fields' and 'references'.`);o=n.references,s=n.fields}else if(a.type===`manyToMany`)throw new _(`Many-to-many relation '${t.name}' requires junction table handling (not yet implemented).`);else throw new _(`Relation '${t.name}' on model '${x(e.model)}' must define 'fields' and 'references' explicitly.`);if(o.length!==s.length)throw new _(`Relation '${t.name}' has mismatched fields (${o.length}) and references (${s.length}).`);let u=[];for(let a=0;a<o.length;a++){let c=p(e.model,o[a]),l=p(t.targetModel,s[a]),d=i.identifiers.column(n,c),f=i.identifiers.column(r,l);u.push(i.operators.eq(d,f))}return u.length===1?u[0]:i.operators.and(...u)}function b(e,t){let n=t.targetModel,r=e.model,i=n[`~`].state.relations;for(let[,e]of Object.entries(i)){let t=e[`~`].state;if(t.getter()===r){let e=t.fields,n=t.references;if(e&&n&&e.length>0&&n.length>0)return{fields:e,references:n}}}}function x(e){return e[`~`].names.ts??e[`~`].state.tableName??`unknown`}function S(e){let t=e[`~`].state.scalars;for(let[e,n]of Object.entries(t))if(n[`~`].state.isId)return e;let n=e[`~`].state.compoundId;if(n){let e=Object.keys(n);if(e.length>0)return e[0]}return`id`}function C(e){let t=e[`~`].state.scalars,n=e[`~`].state.compoundId;if(n){let e=Object.keys(n);if(e.length>0)return e}for(let[e,n]of Object.entries(t))if(n[`~`].state.isId)return[e];return[`id`]}function w(e,t){let n=[e.toLowerCase(),t.toLowerCase()].sort();return`${n[0]}_${n[1]}`}function T(e){return`${e.toLowerCase()}Id`}function ee(e,t,n){let r=e[`~`].state;return r.type===`manyToMany`&&r.through?r.through:w(t,n)}function E(e,t,n){let r=e[`~`].state;return[r.A||T(t),r.B||T(n)]}function D(e,t){let n=e.model[`~`].names.ts??`unknown`,r=t.targetModel[`~`].names.ts??`unknown`,i=ee(t.relation,n,r),[a,o]=E(t.relation,n,r);return{junctionTableName:i,sourceFieldName:a,targetFieldName:o,sourcePkField:S(e.model),targetPkField:S(t.targetModel),targetTableName:l(t.targetModel)}}function O(t,n,r,i,a){let{adapter:o}=t,{junctionTableName:s,sourceFieldName:c,targetFieldName:l,sourcePkField:u,targetPkField:d,targetTableName:f}=n,p=o.identifiers.column(i,c),m=o.identifiers.column(r,u),h=o.operators.eq(p,m),g=o.identifiers.column(a,d),_=o.identifiers.column(i,l);return{correlationCondition:h,joinCondition:o.operators.eq(g,_),fromClause:e`${o.identifiers.table(s,i)}, ${o.identifiers.table(f,a)}`}}function te(e,t,n,r){if(t.isToMany)return n.some===void 0?n.every===void 0?n.none===void 0?void 0:ie(e,t,n.none,r):re(e,t,n.every,r):ne(e,t,n.some,r);if(t.isToOne){if(n.is!==void 0){let i=n.is;return i===null?se(e,t,r):ae(e,t,i,r)}if(n.isNot!==void 0){let i=n.isNot;return i===null?ce(e,t,r):oe(e,t,i,r)}}}function ne(e,t,n,r){let i=k(e,t,n,r,!1);return e.adapter.filters.some(i)}function re(e,t,n,r){let i=k(e,t,n,r,!0);return e.adapter.filters.every(i)}function ie(e,t,n,r){let i=k(e,t,n,r,!1);return e.adapter.filters.none(i)}function ae(e,t,n,r){let i=k(e,t,n,r,!1);return e.adapter.filters.is(i)}function oe(e,t,n,r){let i=k(e,t,n,r,!1);return e.adapter.filters.isNot(i)}function se(e,t,n){let r=t.fields?.[0];if(r){let t=e.adapter.identifiers.column(n,r);return e.adapter.operators.isNull(t)}let i=k(e,t,void 0,n,!1);return e.adapter.operators.notExists(i)}function ce(e,t,n){let r=t.fields?.[0];if(r){let t=e.adapter.identifiers.column(n,r);return e.adapter.operators.isNotNull(t)}let i=k(e,t,void 0,n,!1);return e.adapter.operators.exists(i)}function k(e,t,n,r,i){let{adapter:a}=e;if(t.type===`manyToMany`)return le(e,t,n,r,i);let o=e.nextAlias(),c=l(t.targetModel),u=y(e,t,r,o),d=A(s(e,t.targetModel,o),n,o);i&&d&&(d=a.operators.not(d));let f=[u];d&&f.push(d);let p=a.operators.and(...f);return a.subqueries.existsCheck(a.identifiers.table(c,o),p)}function le(t,n,r,i,a){let{adapter:o}=t,c=t.nextAlias(),l=t.nextAlias(),{correlationCondition:u,joinCondition:d,fromClause:f}=O(t,D(t,n),i,c,l),p=A(s(t,n.targetModel,l),r,l);a&&p&&(p=o.operators.not(p));let m=[u,d];return p&&m.push(p),e`SELECT 1 FROM ${f} WHERE ${o.operators.and(...m)}`}function A(e,t,n){if(!t||Object.keys(t).length===0)return;let r=[];for(let[i,a]of Object.entries(t))if(a!==void 0){if(i===`AND`){let t=ue(e,a,n);t&&r.push(t);continue}if(i===`OR`){let t=de(e,a,n);t&&r.push(t);continue}if(i===`NOT`){let t=fe(e,a,n);t&&r.push(t);continue}if(d(e.model,i)){let t=pe(e,i,a,n);t&&r.push(t);continue}if(f(e.model,i)){let t=c(e,i);if(t){let i=te(e,t,a,n);i&&r.push(i)}}}if(r.length!==0)return e.adapter.operators.and(...r)}function ue(e,t,n){let r=Array.isArray(t)?t:[t],i=[];for(let t of r){let r=A(e,t,n);r&&i.push(r)}if(i.length!==0)return e.adapter.operators.and(...i)}function de(e,t,n){if(!Array.isArray(t))return;let r=[];for(let i of t){let t=A(e,i,n);t&&r.push(t)}if(r.length!==0)return e.adapter.operators.or(...r)}function fe(e,t,n){let r=Array.isArray(t)?t:[t],i=[];for(let t of r){let r=A(e,t,n);r&&i.push(r)}if(i.length===0)return;let a=e.adapter.operators.and(...i);return e.adapter.operators.not(a)}function pe(e,t,n,r){let i=p(e.model,t),a=e.adapter.identifiers.column(r,i);if(typeof n!=`object`||!n)throw Error(`Filter for '${t}' must be a filter object (schema validation should have normalized this)`);let o=n,s=[],c=o.mode===`insensitive`?`insensitive`:`default`;for(let[t,n]of Object.entries(o)){if(n===void 0||t===`mode`)continue;let r=me(e,a,t,n,c);r&&s.push(r)}if(s.length!==0)return e.adapter.operators.and(...s)}function me(t,n,r,i,a=`default`){let{adapter:o}=t,s=e=>o.literals.value(e),c=a===`insensitive`;switch(r){case`equals`:return i===null?o.operators.isNull(n):o.operators.eq(n,s(i));case`not`:if(i===null)return o.operators.isNotNull(n);if(typeof i==`object`&&i){let e=he(t,n,i,a);return e?o.operators.not(e):void 0}return o.operators.neq(n,s(i));case`lt`:return o.operators.lt(n,s(i));case`lte`:return o.operators.lte(n,s(i));case`gt`:return o.operators.gt(n,s(i));case`gte`:return o.operators.gte(n,s(i));case`in`:{if(!Array.isArray(i)||i.length===0)return;let e=i.map(e=>s(e));return o.operators.in(n,o.literals.list(e))}case`notIn`:{if(!Array.isArray(i)||i.length===0)return;let e=i.map(e=>s(e));return o.operators.notIn(n,o.literals.list(e))}case`contains`:{let t=e`${`%${String(i)}%`}`;return c?o.operators.ilike(n,t):o.operators.like(n,t)}case`startsWith`:{let t=e`${`${String(i)}%`}`;return c?o.operators.ilike(n,t):o.operators.like(n,t)}case`endsWith`:{let t=e`${`%${String(i)}`}`;return c?o.operators.ilike(n,t):o.operators.like(n,t)}case`has`:return o.arrays.has(n,s(i));case`hasEvery`:return Array.isArray(i)?o.arrays.hasEvery(n,o.arrays.literal(i.map(s))):void 0;case`hasSome`:return Array.isArray(i)?o.arrays.hasSome(n,o.arrays.literal(i.map(s))):void 0;case`isEmpty`:return i?o.arrays.isEmpty(n):o.operators.not(o.arrays.isEmpty(n));default:return}}function he(e,t,n,r=`default`){let i=[],a=n.mode===`insensitive`?`insensitive`:r;for(let[r,o]of Object.entries(n)){if(o===void 0||r===`mode`)continue;let n=me(e,t,r,o,a);n&&i.push(n)}if(i.length!==0)return e.adapter.operators.and(...i)}function j(e,t,n){let r=[];for(let[i,a]of Object.entries(t))if(a!==void 0)if(typeof a==`object`&&a&&!Array.isArray(a)){let t=a;for(let[i,a]of Object.entries(t)){if(a===void 0)continue;let t=p(e.model,i),o=e.adapter.identifiers.column(n,t);r.push(e.adapter.operators.eq(o,e.adapter.literals.value(a)))}}else{let t=p(e.model,i),o=e.adapter.identifiers.column(n,t);r.push(e.adapter.operators.eq(o,e.adapter.literals.value(a)))}if(r.length!==0)return e.adapter.operators.and(...r)}function M(e,t){let n={},r={};for(let[i,a]of Object.entries(t))if(a!==void 0)if(f(e.model,i)){let t=c(e,i);if(!t)continue;let n=ge(t,a);n&&(r[i]=n)}else n[i]=a;return{scalar:n,relations:r}}function ge(e,t){if(typeof t!=`object`||!t)return;let n=t,r={relationInfo:e};return`connect`in n&&(r.connect=n.connect),`disconnect`in n&&(r.disconnect=n.disconnect),`create`in n&&(r.create=n.create),`connectOrCreate`in n&&(r.connectOrCreate=n.connectOrCreate),`delete`in n&&(r.delete=n.delete),`set`in n&&(r.set=n.set),r}function _e(e,t,n){let r=t[`~`].state.relations;if(r)for(let[,t]of Object.entries(r)){let n=t[`~`];if(n.state?.getter?.()===e&&n.state?.fields?.length)return n.state.fields}throw new _(`Cannot determine FK fields for relation '${n}'. Define the inverse relation with .fields([...]) or use explicit FK fields.`)}function N(e,t){let{fields:n,references:r,targetModel:i,name:a}=t;return n&&n.length>0?{holdsFK:!0,fkFields:n,pkFields:r??C(i),fkHolder:e.model,referenced:i}:{holdsFK:!1,fkFields:_e(e.model,i,a),pkFields:C(e.model),fkHolder:i,referenced:e.model}}function P(e,t,n){let r=N(e,t);if(!r.holdsFK)return{};let i=r.fkFields,a=r.pkFields;if(i.length!==a.length)throw new v(`FK/PK mismatch for relation '${t.name}': ${i.length} FK fields, ${a.length} PK fields`,t.name);let o={};if(a.every(e=>e in n))for(let t=0;t<i.length;t++){let r=i[t],s=n[a[t]];o[r]=e.adapter.literals.value(s)}else for(let r=0;r<i.length;r++){let s=i[r],c=a[r];if(c in n){let t=n[c];o[s]=e.adapter.literals.value(t)}else o[s]=ve(e,t,n,c)}return o}function ve(t,n,r,i){let{adapter:a}=t,{targetModel:o}=n,c=l(o),u=t.nextAlias(),d=j(s(t,o,u),r,u);if(!d)throw new v(`Invalid connect input for relation '${n.name}'`,n.name);let f=p(o,i);return e`(SELECT ${a.identifiers.column(u,f)} FROM ${a.identifiers.escape(c)} ${e.raw([u])} WHERE ${d})`}function F(e){return e.isToMany?!1:!!(e.fields&&e.fields.length>0)}function I(e){for(let t of Object.values(e))if(t.create||t.connectOrCreate||t.delete||t.set||t.disconnect&&!F(t.relationInfo)||t.connect&&!F(t.relationInfo))return!0;return!1}function ye(e){return!I(e)}function L(e,t){let n=Array.isArray(t)?t:[t];if(n.length===0)return{columns:[],values:[]};let r=u(e.model),i=new Set;for(let t of n)for(let[n,a]of Object.entries(t))a!==void 0&&(f(e.model,n)||r.includes(n)&&i.add(n));for(let t of r){let n=e.model[`~`].state.scalars[t];if(n){let e=n[`~`].state;if(e?.autoGenerate&&!i.has(t)){let n=e.autoGenerate;if(n!==`autoincrement`)throw new _(`Auto-generated value '${n}' for field '${t}' must be provided explicitly or handled by the database. Application-level ID generation (uuid, ulid, cuid) is not yet implemented.`)}}}let a=Array.from(i),o=a.map(t=>p(e.model,t)),s=[];for(let t of n){let n=[];for(let r of a){let i=t[r];n.push(be(e,r,i))}s.push(n)}return{columns:o,values:s}}function be(e,t,n){return n==null?e.adapter.literals.null():xe(n)?n:e.model[`~`].state.scalars[t]?.[`~`]?.state?.type===`json`&&typeof n==`object`?e.adapter.literals.json(n):e.adapter.literals.value(n)}function xe(e){return typeof e==`object`&&!!e&&`strings`in e&&`values`in e&&Array.isArray(e.strings)&&Array.isArray(e.values)}function Se(e,t,n,r){let{scalar:i,relations:a}=M(e,t),o=Object.entries(a).filter(([,e])=>e.create!==void 0);return o.length===0?{sql:Ce(e,i,n,r),hasNestedCreates:!1,statementCount:1}:Ee(e,i,o,n,r)}function Ce(t,n,r,i){let{adapter:a}=t,o=l(t.model),{columns:s,values:c}=L(t,n);if(s.length===0)throw new _(`No data to insert`);let u=a.identifiers.escape(o),d=a.mutations.insert(u,s,c);if(a.capabilities.supportsReturning){let n=we(t,r,``),i=a.mutations.returning(n);if(i.strings.join(``).trim()!==``)return e`${d} ${i}`}return d}function we(t,n,r){let i=u(t.model);if(n){let a=i.filter(e=>n[e]===!0).map(e=>{let n=p(t.model,e);return t.adapter.identifiers.aliased(r?t.adapter.identifiers.column(r,n):t.adapter.identifiers.escape(n),e)});return a.length===0?Te(t,r):e.join(a,`, `)}return Te(t,r)}function Te(t,n){let r=u(t.model).map(e=>{let r=p(t.model,e);return t.adapter.identifiers.aliased(n?t.adapter.identifiers.column(n,r):t.adapter.identifiers.escape(r),e)});return e.join(r,`, `)}function Ee(t,n,r,i,a){let{adapter:o}=t,c=[],u=[],d=n[S(t.model)],f=()=>d===void 0?o.lastInsertId():o.literals.value(d),p=[],m=[];for(let[e,n]of r)N(t,n.relationInfo).holdsFK?p.push([e,n]):m.push([e,n]);let h={...n};for(let[e,n]of p){let r=Array.isArray(n.create)?n.create:[n.create],{targetModel:i}=n.relationInfo,a=s(t,i,``),d=l(i),f=o.identifiers.escape(d),p=N(t,n.relationInfo);for(let e=0;e<r.length;e++){let t=r[e];if(!t)continue;let{columns:n,values:i}=L(a,t);c.push(o.mutations.insert(f,n,i))}if(r.length===1)for(let e=0;e<p.fkFields.length;e++){let t=p.fkFields[e],n=r[0],a=S(i),s=n?.[a];s===void 0?h[t]=o.lastInsertId():h[t]=s}u.push({relationName:e,relationInfo:n.relationInfo,model:i,count:r.filter(Boolean).length})}let g=l(t.model),_=o.identifiers.escape(g),{columns:v,values:y}=L(t,h);c.push(o.mutations.insert(_,v,y));for(let[e,n]of m){let r=Array.isArray(n.create)?n.create:[n.create],{targetModel:i}=n.relationInfo,a=s(t,i,``),d=l(i),p=o.identifiers.escape(d),m=N(t,n.relationInfo);for(let e of r){if(!e)continue;let t={...e},n=m.fkFields[0];t[n]=f();let{columns:r,values:i}=L(a,t);c.push(o.mutations.insert(p,r,i))}u.push({relationName:e,relationInfo:n.relationInfo,model:i,count:r.filter(Boolean).length})}let b=De(t,f(),u,i,a);return c.push(b),{sql:e.join(c,`; `),hasNestedCreates:!0,statementCount:c.length}}function De(t,n,r,i,a){let{adapter:o}=t,s=l(t.model),c=o.identifiers.escape(s),d=S(t.model),f=p(t.model,d),m=u(t.model),h;i?(h=m.filter(e=>i[e]===!0).map(e=>{let n=p(t.model,e);return o.identifiers.aliased(o.identifiers.escape(n),e)}),h.length===0&&(h=m.map(e=>{let n=p(t.model,e);return o.identifiers.aliased(o.identifiers.escape(n),e)}))):h=m.map(e=>{let n=p(t.model,e);return o.identifiers.aliased(o.identifiers.escape(n),e)});let g=Oe(i,a);for(let e of r){let r=g[e.relationName];if(r){let i=ke(t,e,r,n);h.push(o.identifiers.aliased(i,e.relationName))}}return e`SELECT ${e.join(h,`, `)} FROM ${c} WHERE ${e`${o.identifiers.escape(f)} = ${n}`}`}function Oe(e,t){let n={};if(e)for(let[t,r]of Object.entries(e))r&&typeof r==`object`&&`select`in r?n[t]=r:r===!0&&(n[t]=!0);if(t)for(let[e,r]of Object.entries(t))r&&(n[e]=r);return n}function ke(t,n,r,i){let{adapter:a}=t,{model:o,relationInfo:s}=n,c=N(t,s),d=l(o),f=a.identifiers.escape(d),m=`_child`,h=u(o),g;if(typeof r==`object`&&r&&`select`in r){let e=r.select;g=h.filter(t=>e[t]===!0),g.length===0&&(g=h)}else g=h;let _=g.map(e=>{let t=p(o,e);return[e,a.identifiers.column(m,t)]}),v=a.json.object(_),y=c.fkFields[0],b=p(o,y),x=e`${a.identifiers.column(m,b)} = ${i}`;return s.isToMany?e`(SELECT COALESCE(${a.json.agg(v)}, ${a.json.emptyArray()}) FROM ${f} AS ${a.identifiers.escape(m)} WHERE ${x})`:e`(SELECT ${v} FROM ${f} AS ${a.identifiers.escape(m)} WHERE ${x} LIMIT 1)`}function R(e,t,n){let{adapter:r}=e;if(t===!0)return r.identifiers.aliased(r.aggregates.count(),`_count`);let i=Object.entries(t).filter(([,e])=>e);if(i.length===0)return;let a=i.map(([t])=>{if(t===`_all`)return[`_all`,r.aggregates.count()];let i=p(e.model,t);return[t,r.aggregates.count(r.identifiers.column(n,i))]});return r.identifiers.aliased(r.json.objectFromColumns(a),`_count`)}function z(e,t,n,r){let{adapter:i}=e;if(r===`count`)return R(e,t,n);if(t===!0)return;let a=Object.entries(t).filter(([,e])=>e);if(a.length===0)return;let o=Ae(i,r),s=`_${r}`,c=a.map(([t])=>{let r=p(e.model,t);return[t,o(i.identifiers.column(n,r))]});return i.identifiers.aliased(i.json.objectFromColumns(c),s)}function Ae(e,t){switch(t){case`avg`:return e.aggregates.avg;case`sum`:return e.aggregates.sum;case`min`:return e.aggregates.min;case`max`:return e.aggregates.max;default:return e.aggregates.count}}function je(t,n){let{adapter:r,rootAlias:i}=t,a=l(t.model),o=Me(t,n,i);if(o.length===0)throw new _(`Aggregate operation requires at least one aggregate field (_count, _avg, _sum, _min, _max)`);let s=r.identifiers.table(a,i),c=A(t,n.where,i),u=n.take===void 0?void 0:r.literals.value(n.take),d=n.skip===void 0?void 0:r.literals.value(n.skip),f={columns:e.join(o,`, `),from:s};return c&&(f.where=c),u&&(f.limit=u),d&&(f.offset=d),r.assemble.select(f)}function Me(e,t,n){let r=[];if(t._count){let i=R(e,t._count,n);i&&r.push(i)}if(t._avg){let i=z(e,t._avg,n,`avg`);i&&r.push(i)}if(t._sum){let i=z(e,t._sum,n,`sum`);i&&r.push(i)}if(t._min){let i=z(e,t._min,n,`min`);i&&r.push(i)}if(t._max){let i=z(e,t._max,n,`max`);i&&r.push(i)}return r}function Ne(e,t){let{adapter:n,rootAlias:r}=e,i=l(e.model),a=Pe(e,t.select),o=n.identifiers.table(i,r),s=A(e,t.where,r),c=t.take===void 0?void 0:n.literals.value(t.take),u=t.skip===void 0?void 0:n.literals.value(t.skip),d={columns:a,from:o};return s&&(d.where=s),c&&(d.limit=c),u&&(d.offset=u),n.assemble.select(d)}function Pe(t,n){let{adapter:r}=t;if(!n)return r.aggregates.count();let i=[];n._all&&i.push(r.identifiers.aliased(r.aggregates.count(),`_all`));for(let[e,a]of Object.entries(n)){if(e===`_all`||!a)continue;let n=p(t.model,e),o=r.identifiers.column(t.rootAlias,n),s=r.aggregates.count(o);i.push(r.identifiers.aliased(s,e))}return i.length===0?r.aggregates.count():e.join(i,`, `)}function B(t,n,r){if(!n)return;let i=Array.isArray(n)?n:[n],a=[];for(let e of i)for(let[n,i]of Object.entries(e)){if(i===void 0||!d(t.model,n))continue;let e=p(t.model,n),o=Fe(t,t.adapter.identifiers.column(r,e),i);o&&a.push(o)}if(a.length!==0)return e.join(a,`, `)}function Fe(e,t,n){let{adapter:r}=e;if(typeof n==`string`)return n===`desc`?r.orderBy.desc(t):r.orderBy.asc(t);if(typeof n==`object`&&n){let{sort:e,nulls:i}=n,a=e===`desc`?r.orderBy.desc(t):r.orderBy.asc(t);return i===`first`?a=r.orderBy.nullsFirst(a):i===`last`&&(a=r.orderBy.nullsLast(a)),a}}function Ie(e,t,n,r){if(t.type===`manyToMany`)return ze(e,t,n,r);let i=e.nextAlias(),a=s(e,t.targetModel,i),{select:o,include:c,where:u,orderBy:d,take:f,skip:p}=n,m=V(a,o,c,i,{asJson:!0}),h=y(e,t,r,i),g=A(a,u,i),_=g?e.adapter.operators.and(h,g):h,v=B(a,d,i),b=l(t.targetModel),x=e.adapter.identifiers.table(b,i);return t.isToMany?Le(e,m,x,_,v,f,p):Re(e,m,x,_)}function Le(t,n,r,i,a,o,s){let{adapter:c}=t,l=`_json`,u=[e`SELECT ${c.identifiers.aliased(n,l)}`,e`FROM ${r}`,e`WHERE ${i}`];a&&u.push(e`ORDER BY ${a}`),o!==void 0&&u.push(e`LIMIT ${c.literals.value(o)}`),s!==void 0&&u.push(e`OFFSET ${c.literals.value(s)}`);let d=e.join(u,` `),f=t.nextAlias(),p=c.identifiers.column(f,l);return c.subqueries.scalar(e`SELECT ${c.json.agg(p)} FROM (${d}) ${c.identifiers.escape(f)}`)}function Re(t,n,r,i){let{adapter:a}=t,o=e`SELECT ${n} FROM ${r} WHERE ${i} LIMIT 1`;return a.subqueries.scalar(o)}function ze(t,n,r,i){let{adapter:a}=t,o=t.nextAlias(),c=t.nextAlias(),{correlationCondition:l,joinCondition:u,fromClause:d}=O(t,D(t,n),i,o,c),f=s(t,n.targetModel,c),{select:p,include:m,where:h,orderBy:g,take:_,skip:v}=r,y=V(f,p,m,c,{asJson:!0}),b=A(f,h,c),x=[l,u];b&&x.push(b);let S=a.operators.and(...x),C=B(f,g,c),w=`_json`,T=[e`SELECT ${a.identifiers.aliased(y,w)}`,e`FROM ${d}`,e`WHERE ${S}`];C&&T.push(e`ORDER BY ${C}`),_!==void 0&&T.push(e`LIMIT ${a.literals.value(_)}`),v!==void 0&&T.push(e`OFFSET ${a.literals.value(v)}`);let ee=e.join(T,` `),E=t.nextAlias(),te=a.identifiers.column(E,w);return a.subqueries.scalar(e`SELECT ${a.json.agg(te)} FROM (${ee}) ${a.identifiers.escape(E)}`)}function V(t,n,r,i,a={}){let o=Be(t,n,r,i);if(a.asJson)return t.adapter.json.objectFromColumns(o);let s=o.map(([e,n])=>t.adapter.identifiers.aliased(n,e));return e.join(s,`, `)}function Be(e,t,n,r){let i=[],a=u(e.model);if(t){for(let n of a)if(t[n]===!0){let t=p(e.model,n);i.push([n,e.adapter.identifiers.column(r,t)])}for(let[n,a]of Object.entries(t))if(!(a===void 0||a===!1)&&f(e.model,n)){let t=c(e,n);if(t&&typeof a==`object`&&a){let o=Ie(e,t,a,r);i.push([n,o])}}}else for(let t of a){let n=p(e.model,t);i.push([t,e.adapter.identifiers.column(r,n)])}if(t&&`_count`in t&&t._count){let n=t._count;if(n.select){let t=He(e,n.select,r);i.push(...t)}}if(n){for(let[t,a]of Object.entries(n))if(!(a===void 0||a===!1)){if(t===`_count`){let t=a;if(t.select){let n=He(e,t.select,r);i.push(...n)}continue}if(f(e.model,t)){let n=c(e,t);if(n){let o=Ie(e,n,a===!0?{}:a,r);i.push([t,o])}}}}if(i.length===0)for(let t of a){let n=p(e.model,t);i.push([t,e.adapter.identifiers.column(r,n)])}return i}function Ve(t,n,r,i,a={}){let o=Be(t,n,r,i),s=o.map(([e])=>e),c;if(a.asJson)c=t.adapter.json.objectFromColumns(o);else{let n=o.map(([e,n])=>t.adapter.identifiers.aliased(n,e));c=e.join(n,`, `)}return{sql:c,aliases:s}}function He(e,t,n){let r=[];for(let[i,a]of Object.entries(t)){if(a===void 0||a===!1)continue;let t=c(e,i);if(!t)continue;let o=Ue(e,t,a,n);r.push([`_count_${i}`,o])}return r}function Ue(t,n,r,i){let{adapter:a}=t;if(n.type===`manyToMany`)return We(t,n,r,i);let o=t.nextAlias(),c=l(n.targetModel),u=a.identifiers.table(c,o),d=y(t,n,i,o),f=d;if(typeof r==`object`&&r&&`where`in r){let e=s(t,n.targetModel,o),i=r.where,c=A(e,i,o);c&&(f=a.operators.and(d,c))}return a.subqueries.scalar(e`SELECT COUNT(*) FROM ${u} WHERE ${f}`)}function We(n,r,i,a){let{adapter:o}=n,c=n.nextAlias(),l=n.nextAlias(),{correlationCondition:u,joinCondition:d,fromClause:f}=O(n,D(n,r),a,c,l),p=[u,d];if(typeof i==`object`&&i&&`where`in i){let e=s(n,r.targetModel,l),a=i.where,o=r.targetModel[`~`].schemas.where,c=A(e,o?t(o,a).value:a,l);c&&p.push(c)}let m=o.operators.and(...p);return o.subqueries.scalar(e`SELECT COUNT(*) FROM ${f} WHERE ${m}`)}function Ge(t,n){let{adapter:r}=t,i=l(t.model),{columns:a,values:o}=L(t,n.data);if(a.length===0)throw Error(`No data to insert`);let s=r.identifiers.escape(i),c=r.mutations.insert(s,a,o),u=V(t,n.select,n.include,``),d=r.mutations.returning(u);return d.strings.join(``).trim()===``?c:e`${c} ${d}`}function Ke(t,n,r=!1){let{adapter:i}=t,a=l(t.model),{columns:o,values:s}=L(t,n);if(o.length===0||s.length===0)throw Error(`No data to insert`);let c=i.identifiers.escape(a),u=i.mutations.insert(c,o,s);if(r){let t=i.mutations.onConflict(null,e.raw`NOTHING`);u=e`${u} ${t}`}return u}function qe(t,n){let{adapter:r}=t,i=l(t.model),a=j(t,n.where,``),o=r.identifiers.escape(i),s=r.mutations.delete(o,a),c=V(t,n.select,n.include,``),u=r.mutations.returning(c);return u.strings.join(``).trim()===``?s:e`${s} ${u}`}function Je(e,t){let{adapter:n}=e,r=l(e.model),i=A(e,t.where,``),a=n.identifiers.escape(r);return n.mutations.delete(a,i)}function Ye(e,t,n={}){let{adapter:r,rootAlias:i}=e,a=l(e.model),o,s;if(t.distinct&&t.distinct.length>0){let n=Ve(e,t.select,t.include,i);o=n.sql,s=n.aliases}else o=V(e,t.select,t.include,i);let c=r.identifiers.table(a,i),u=A(e,t.where,i);if(t.cursor){let n=Xe(e,t.cursor,t.orderBy,i);n&&(u=u?r.operators.and(u,n):n)}let d=B(e,t.orderBy,i),f=n.limit===void 0?void 0:r.literals.value(n.limit),p=t.skip===void 0?void 0:r.literals.value(t.skip),m=t.distinct?et(e,t.distinct,i):void 0,h={columns:o,from:c};return m&&s?(h.distinct=m,h.distinctColumnAliases=s):m&&(h.distinct=m),u&&(h.where=u),d&&(h.orderBy=d),f&&(h.limit=f),p&&(h.offset=p),r.assemble.select(h)}function Xe(e,t,n,r){let i=Object.entries(t);if(i.length!==0){for(let[e,t]of i)if(t==null)throw new _(`Cursor field '${e}' cannot be null or undefined. Cursor must point to a specific record.`);if(i.length===1){let[t,a]=i[0];return Ze(e,t,a,n,r)}return Qe(e,t,n,r)}}function Ze(e,t,n,r,i){let{adapter:a}=e,o=p(e.model,t),s=a.identifiers.column(i,o),c=a.literals.value(n);return $e(t,r)===`desc`?a.operators.lte(s,c):a.operators.gte(s,c)}function Qe(t,n,r,i){let{adapter:a}=t,o=Object.entries(n),s=o.map(([e])=>$e(e,r)),c=s[0];if(s.some(e=>e!==c))throw new _(`Compound cursor with mixed sort directions (asc/desc) is not supported. Either use a single-field cursor or ensure all orderBy fields use the same direction.`);let l=o.map(([e])=>{let n=p(t.model,e);return a.identifiers.column(i,n)}),u=o.map(([,e])=>a.literals.value(e)),d=e`(${e.join(l,`, `)})`,f=e`(${e.join(u,`, `)})`;return c===`desc`?e`${d} <= ${f}`:e`${d} >= ${f}`}function $e(e,t){if(!t)return`asc`;let n=Array.isArray(t)?t:[t];for(let t of n)if(e in t){let n=t[e];if(typeof n==`string`)return n===`desc`||n===`Desc`?`desc`:`asc`;if(typeof n==`object`&&n){let e=n.sort;return e===`desc`||e===`Desc`?`desc`:`asc`}return`asc`}return`asc`}function et(t,n,r){if(n.length===0)return;let{adapter:i}=t,a=u(t.model);for(let e of n)if(!a.includes(e))throw new _(`Distinct field '${e}' not found on model '${t.model[`~`].state.name}'`);let o=n.map(e=>{let n=p(t.model,e);return i.identifiers.column(r,n)});return e.join(o,`, `)}function tt(e,t){return Ye(e,t,{limit:1})}function nt(e,t){return Ye(e,t,{limit:t.take})}function H(t,n){let{adapter:r,rootAlias:i}=t,a=l(t.model),o=V(t,n.select,n.include,i),s=r.identifiers.table(a,i),c=j(t,n.where,i),u=e`1`,d={columns:o,from:s};return c&&(d.where=c),d.limit=u,r.assemble.select(d)}function rt(t,n){let{adapter:r,rootAlias:i}=t,a=l(t.model),o=u(t.model),s=Array.isArray(n.by)?n.by:[n.by];for(let e of s)if(!o.includes(e))throw new _(`GroupBy field '${e}' not found on model '${t.model[`~`].state.name}'`);if(s.length===0)throw new _(`GroupBy operation requires at least one field in 'by'`);let c=it(t,s,n,i),d=r.identifiers.table(a,i),f=A(t,n.where,i),m=s.map(e=>{let n=p(t.model,e);return r.identifiers.column(i,n)}),h=e.join(m,`, `),g=n.having?at(t,n.having,i):void 0,v=B(t,n.orderBy,i),y=n.take===void 0?void 0:r.literals.value(n.take),b=n.skip===void 0?void 0:r.literals.value(n.skip),x={columns:e.join(c,`, `),from:d};return f&&(x.where=f),x.groupBy=h,g&&(x.having=g),v&&(x.orderBy=v),y&&(x.limit=y),b&&(x.offset=b),r.assemble.select(x)}function it(e,t,n,r){let{adapter:i}=e,a=[];for(let n of t){let t=p(e.model,n);a.push(i.identifiers.column(r,t))}if(n._count){let t=R(e,n._count,r);t&&a.push(t)}if(n._avg){let t=z(e,n._avg,r,`avg`);t&&a.push(t)}if(n._sum){let t=z(e,n._sum,r,`sum`);t&&a.push(t)}if(n._min){let t=z(e,n._min,r,`min`);t&&a.push(t)}if(n._max){let t=z(e,n._max,r,`max`);t&&a.push(t)}return a}function at(e,t,n){let{adapter:r}=e,i=[];for(let[a,o]of Object.entries(t)){if(o===void 0)continue;if(a===`_count`||a===`_avg`||a===`_sum`||a===`_min`||a===`_max`){let t=ot(e,a,o,n);t&&i.push(t);continue}let t=p(e.model,a),s=st(e,r.identifiers.column(n,t),o);s&&i.push(s)}if(i.length!==0)return r.operators.and(...i)}function ot(e,t,n,r){let{adapter:i}=e,a=[];for(let[o,s]of Object.entries(n)){if(s===void 0)continue;let n,c=o===`_all`?void 0:p(e.model,o),l=c?i.identifiers.column(r,c):void 0;switch(t){case`_count`:n=l?i.aggregates.count(l):i.aggregates.count();break;case`_avg`:if(!l)continue;n=i.aggregates.avg(l);break;case`_sum`:if(!l)continue;n=i.aggregates.sum(l);break;case`_min`:if(!l)continue;n=i.aggregates.min(l);break;case`_max`:if(!l)continue;n=i.aggregates.max(l);break;default:continue}let u=st(e,n,s);u&&a.push(u)}if(a.length!==0)return i.operators.and(...a)}function st(e,t,n){let{adapter:r}=e;if(typeof n!=`object`||!n)return r.operators.eq(t,r.literals.value(n));let i=[],a=n;for(let[e,n]of Object.entries(a))if(n!==void 0)switch(e){case`equals`:i.push(r.operators.eq(t,r.literals.value(n)));break;case`not`:i.push(r.operators.neq(t,r.literals.value(n)));break;case`gt`:i.push(r.operators.gt(t,r.literals.value(n)));break;case`gte`:i.push(r.operators.gte(t,r.literals.value(n)));break;case`lt`:i.push(r.operators.lt(t,r.literals.value(n)));break;case`lte`:i.push(r.operators.lte(t,r.literals.value(n)));break;case`in`:if(Array.isArray(n)){let e=n.map(e=>r.literals.value(e));i.push(r.operators.in(t,r.literals.list(e)))}break;case`notIn`:if(Array.isArray(n)){let e=n.map(e=>r.literals.value(e));i.push(r.operators.notIn(t,r.literals.list(e)))}break;default:throw new _(`Invalid operator: ${e}`)}if(i.length!==0)return i.length===1?i[0]:r.operators.and(...i)}function U(e,t,n,r){let{adapter:i}=e,a=[];if(t.holdsFK)for(let e=0;e<t.pkFields.length;e++){let o=t.pkFields[e],s=t.fkFields[e],c=p(n,o),l=i.identifiers.escape(c),u=i.literals.value(r[s]);a.push(i.operators.eq(l,u))}else for(let e=0;e<t.fkFields.length;e++){let o=t.fkFields[e],s=t.pkFields[e],c=p(n,o),l=i.identifiers.escape(c),u=i.literals.value(r[s]);a.push(i.operators.eq(l,u))}return a.length===1?a[0]:i.operators.and(...a)}function ct(e,t,n){let{adapter:r}=e,i=[];for(let e of t.fkFields){let t=p(n,e),a=r.identifiers.escape(t);i.push(r.set.assign(a,r.literals.null()))}return i}function lt(e,t,n,r){let{adapter:i}=e,a=[];for(let e=0;e<t.fkFields.length;e++){let o=t.fkFields[e],s=t.pkFields[e],c=p(n,o),l=i.identifiers.escape(c),u=i.literals.value(r[s]);a.push(i.set.assign(l,u))}return a}async function W(e,t,n){let{scalar:r,relations:i}=M(t,n);return Object.keys(i).length===0?{record:await K(e,t,r),related:{}}:e.transaction(async e=>{let n={generatedIds:new Map,createdRecords:new Map},a=[],o=[];for(let[e,n]of Object.entries(i))N(t,n.relationInfo).holdsFK?a.push([e,n]):o.push([e,n]);for(let[i,o]of a)await G(e,t,i,o,`before`,r,n);let s=await K(e,t,r),c=s[S(t.model)];n.generatedIds.set(`__parent__`,c);for(let[r,i]of o)await G(e,t,r,i,`after`,s,n);let l={};for(let[e]of[...a,...o]){let t=n.createdRecords.get(e);t&&(l[e]=t)}return{record:s,related:l}})}async function ut(e,t,n,r){return Object.keys(r).length===0?{record:n,related:{}}:e.transaction(async e=>{let i={generatedIds:new Map,createdRecords:new Map},a=n[S(t.model)];i.generatedIds.set(`__parent__`,a);for(let[a,o]of Object.entries(r))await G(e,t,a,o,`after`,n,i);let o={};for(let[e]of Object.entries(r)){let t=i.createdRecords.get(e);t&&(o[e]=t)}return{record:n,related:o}})}async function G(e,t,n,r,i,a,o){let{relationInfo:s}=r;if(r.create){let c=Array.isArray(r.create)?r.create:[r.create],l=[];for(let n of c){let r=await dt(e,t,s,n,i,a,o);l.push(r)}s.isToMany?o.createdRecords.set(n,l):o.createdRecords.set(n,l[0])}if(r.connect&&i===`after`){let n=Array.isArray(r.connect)?r.connect:[r.connect];for(let r of n)await ft(e,t,s,r,a,o)}if(r.connectOrCreate){let c=Array.isArray(r.connectOrCreate)?r.connectOrCreate:[r.connectOrCreate],l=[];for(let n of c){let r=await pt(e,t,s,n,i,a,o);r&&l.push(r)}if(l.length>0)if(s.isToMany){let e=o.createdRecords.get(n);Array.isArray(e)?o.createdRecords.set(n,[...e,...l]):o.createdRecords.set(n,l)}else o.createdRecords.set(n,l[0])}r.disconnect&&i===`after`&&await mt(e,t,s,r.disconnect,a),r.delete&&i===`after`&&await ht(e,t,s,r.delete,a),r.set&&i===`after`&&await gt(e,t,s,r.set,a)}async function dt(e,t,n,r,i,a,o){let{targetModel:c}=n,l=N(t,n),u=s(t,c,t.nextAlias()),d={...r};if(i===`after`&&!l.holdsFK){let e=l.pkFields,t=l.fkFields;for(let n=0;n<t.length;n++){let r=t[n];d[r]=a[e[n]]}}let{scalar:f,relations:p}=M(u,d);return Object.keys(p).length>0?(await W(e,u,d)).record:K(e,u,f)}async function ft(t,n,r,i,a,o){let{adapter:c}=n,{targetModel:u,name:d}=r,f=N(n,r);if(f.holdsFK)return;let m=l(u),h=s(n,u,n.nextAlias()),g=j(h,i,h.rootAlias);if(!g)throw new v(`Invalid connect input for relation '${d}'`,d);let _=[],y=f.fkFields,b=f.pkFields;for(let e=0;e<y.length;e++){let t=y[e],n=b[e],r=p(u,t),i=c.identifiers.escape(r),o=c.literals.value(a[n]);_.push(c.set.assign(i,o))}let x=e.join(_,`, `),S=c.identifiers.escape(m),C=c.mutations.update(S,x,g);await t.execute(C)}async function pt(t,n,r,i,a,o,c){let{adapter:u}=n,{targetModel:d,name:f}=r,m=s(n,d,n.nextAlias()),h=l(d),g=m.rootAlias,_=j(m,i.where,g);if(!_)throw new v(`Invalid connectOrCreate where for relation '${f}'`,f);let y=p(d,S(d)),b=e`SELECT ${u.identifiers.column(g,y)} FROM ${u.identifiers.escape(h)} ${e.raw(g)} WHERE ${_} LIMIT 1`,x=await t.execute(b);if(x.rows.length>0){let e=x.rows[0];return!N(n,r).holdsFK&&a===`after`&&await ft(t,n,r,i.where,o,c),e}return dt(t,n,r,i.create,a,o,c)}async function mt(t,n,r,i,a){let{adapter:o}=n,{targetModel:c,name:u}=r,d=N(n,r);if(d.holdsFK)return;let f=l(c),p=s(n,c,n.nextAlias()),m;if(i===!0)m=U(n,d,c,a);else{let e=Array.isArray(i)?i:[i],t=[];for(let n of e){let e=j(p,n,p.rootAlias);e&&t.push(e)}if(t.length===0)throw new v(`Invalid disconnect input for relation '${u}'`,u);m=t.length===1?t[0]:o.operators.or(...t)}let h=ct(n,d,c),g=e.join(h,`, `),_=o.identifiers.escape(f),y=o.mutations.update(_,g,m);await t.execute(y)}async function ht(e,t,n,r,i){let{adapter:a}=t,{targetModel:o,name:c}=n,u=N(t,n),d=l(o),f=s(t,o,t.nextAlias()),p;if(r===!0)p=U(t,u,o,i);else{let e=Array.isArray(r)?r:[r],t=[];for(let n of e){let e=j(f,n,f.rootAlias);e&&t.push(e)}if(t.length===0)throw new v(`Invalid delete input for relation '${c}'`,c);p=t.length===1?t[0]:a.operators.or(...t)}let m=a.identifiers.escape(d),h=a.mutations.delete(m,p);await e.execute(h)}async function gt(t,n,r,i,a){let{adapter:o}=n,{targetModel:c,name:u}=r,d=N(n,r);if(d.holdsFK)throw new v(`'set' operation is not supported for relation '${u}' where current model holds FK. Use 'connect' instead for to-one relations.`,u);for(let e of d.pkFields)if(a[e]===void 0||a[e]===null)throw new v(`Cannot execute 'set' for relation '${u}': parent record is missing primary key field '${e}'. Ensure the parent record is saved before performing nested operations.`,u);let f=l(c),p=s(n,c,n.nextAlias()),m=o.identifiers.escape(f),h=U(n,d,c,a),g=ct(n,d,c),_=e.join(g,`, `),y=o.mutations.update(m,_,h);await t.execute(y);let b=lt(n,d,c,a),x=e.join(b,`, `);for(let e of i){let n=j(p,e,p.rootAlias);if(!n)throw new v(`Invalid set input for relation '${u}'`,u);let r=o.mutations.update(m,x,n);await t.execute(r)}}async function K(t,n,r){let{adapter:i}=n,a=l(n.model),o=n.model.name??a,{columns:s,values:c}=L(n,r);if(s.length===0)throw new v(`No data to insert for model '${o}'`,o);let u=i.identifiers.escape(a),d=i.mutations.insert(u,s,c),f=i.mutations.returning(e`*`);if(f.strings.join(``).trim()!==``){let n=e`${d} ${f}`,r=await t.execute(n);if(r.rows.length===0)throw new v(`Insert did not return a record for model '${o}'`,o);return r.rows[0]}await t.execute(d);let p=S(n.model),m=r[p];if(m!==void 0)return q(t,n,p,m,r,o);let h=await _t(t);return h===void 0?{...r}:q(t,n,p,h,r,o)}async function _t(e){let t=e.dialect;if(t===`postgresql`)return;let n;if(t===`mysql`)n=`SELECT LAST_INSERT_ID() as id`;else if(t===`sqlite`)n=`SELECT last_insert_rowid() as id`;else return;return(await e.executeRaw(n,[])).rows[0]?.id}async function q(t,n,r,i,a,o){let{adapter:s}=n,c=l(n.model),u=n.rootAlias,d=p(n.model,r),f=s.identifiers.table(c,u),m=e`*`,h=s.operators.eq(s.identifiers.column(u,d),s.literals.value(i)),g=s.assemble.select({columns:m,from:f,where:h}),_=await t.execute(g);return _.rows.length>0?_.rows[0]:(console.warn(`[nested-writes] Record not found after insert for ${o}.${r}=${i}. This may indicate a race condition or transaction isolation issue.`),{...a,[r]:i})}function J(t,n,r){let{adapter:i}=t,a=[],o=u(t.model);for(let[e,s]of Object.entries(n)){if(s===void 0||f(t.model,e)||!o.includes(e))continue;let n=p(t.model,e),c=yt(t,r?i.identifiers.column(r,n):i.identifiers.escape(n),s);c&&a.push(c)}if(a.length===0)throw Error(`No fields to update`);return e.join(a,`, `)}function vt(e){return typeof e==`object`&&!!e&&`strings`in e&&`values`in e&&Array.isArray(e.strings)&&Array.isArray(e.values)}function yt(e,t,n){let{adapter:r}=e;if(vt(n))return r.set.assign(t,n);if(n===null)return r.set.assign(t,r.literals.null());if(typeof n!=`object`)throw Error(`Update value must be an operation object (schema validation should have normalized this)`);let i=n;if(`set`in i){let e=i.set;return e===null?r.set.assign(t,r.literals.null()):r.set.assign(t,r.literals.value(e))}if(`increment`in i&&i.increment!==void 0)return r.set.increment(t,r.literals.value(i.increment));if(`decrement`in i&&i.decrement!==void 0)return r.set.decrement(t,r.literals.value(i.decrement));if(`multiply`in i&&i.multiply!==void 0)return r.set.multiply(t,r.literals.value(i.multiply));if(`divide`in i&&i.divide!==void 0)return r.set.divide(t,r.literals.value(i.divide));if(`push`in i&&i.push!==void 0)return r.set.push(t,r.literals.value(i.push));if(`unshift`in i&&i.unshift!==void 0)return r.set.unshift(t,r.literals.value(i.unshift));throw Error(`Unknown update operation: ${Object.keys(i).join(`, `)}`)}function bt(e,t){let n={};for(let[r,i]of Object.entries(t))if(i!==void 0)if(f(e.model,r)){let t=c(e,r);if(!t)continue;let a=t.relation[`~`].state;if((a.type===`manyToOne`||a.type===`oneToOne`)&&a.fields&&a.references){let e=i,t=Array.isArray(a.fields)?a.fields:[a.fields],r=Array.isArray(a.references)?a.references:[a.references];if(e.connect!==void 0){let i=e.connect;for(let e=0;e<t.length;e++){let a=t[e];n[a]={set:i[r[e]]}}}if(e.disconnect!==void 0)for(let e of t)n[e]={set:null}}}else n[r]=i;return n}function Y(t,n){let{adapter:r}=t,i=l(t.model),a=J(t,bt(t,n.data)),o=j(t,n.where,``),s=r.identifiers.escape(i),c=r.mutations.update(s,a,o),u=V(t,n.select,n.include,``),d=r.mutations.returning(u);return d.strings.join(``).trim()===``?c:e`${c} ${d}`}function xt(e,t){let{adapter:n}=e,r=l(e.model),i=J(e,t.data),a=A(e,t.where,``),o=n.identifiers.escape(r);return n.mutations.update(o,i,a)}function St(t,n){let{adapter:r,rootAlias:i}=t,a=l(t.model),{columns:o,values:s}=L(t,n.create);if(o.length===0)throw Error(`No data to insert`);let c=r.identifiers.escape(a),u=r.mutations.insert(c,o,s),d=Ct(t,n.where),f=J(t,n.update),p=e`${u} ${r.mutations.onConflict(d,e`UPDATE SET ${f}`)}`,m=V(t,n.select,n.include,``),h=r.mutations.returning(m);return h.strings.join(``).trim()!==``&&(p=e`${p} ${h}`),p}function Ct(t,n){let{adapter:r}=t,i=[];for(let[e,a]of Object.entries(n))if(a!==void 0)if(typeof a==`object`&&a&&!Array.isArray(a)){let e=a;for(let n of Object.keys(e)){let e=p(t.model,n);i.push(r.identifiers.escape(e))}}else{let n=p(t.model,e);i.push(r.identifiers.escape(n))}return e.join(i,`, `)}function X(e,t,n){if(n==null)return Tt(t);if(t===`exist`){let e=Et(n);return typeof e==`number`?e>0:Object.values(e).some(e=>e>0)}if(t===`count`)return Et(n);if(h(t))return Dt(n);if(Array.isArray(n)){if(wt(t)){let t=n[0];return t?Z(e,t):null}return n.map(t=>Z(e,t))}return typeof n==`object`?Z(e,n):n}function Z(e,t){let n={};for(let[e,r]of Object.entries(t))n[e]=Q(r);return n}function Q(e){if(e==null)return null;if(typeof e==`bigint`)return e;if(typeof e==`string`){let t=e.trim();if(t.startsWith(`{`)&&t.endsWith(`}`)||t.startsWith(`[`)&&t.endsWith(`]`))try{return JSON.parse(e)}catch{return e}return e}if(typeof e==`object`){if(Array.isArray(e))return e.map(Q);let t={};for(let[n,r]of Object.entries(e))t[n]=Q(r);return t}return e}function wt(e){return[`findFirst`,`findUnique`,`create`,`update`,`delete`,`upsert`,`aggregate`].includes(e)}function Tt(e){switch(e){case`findFirst`:case`findUnique`:case`create`:case`update`:case`delete`:case`upsert`:return null;case`findMany`:return[];case`createMany`:case`updateMany`:case`deleteMany`:return{count:0};case`count`:return 0;case`aggregate`:case`groupBy`:return{};case`exist`:return!1;default:return null}}function Et(e){if(e==null)return 0;if(typeof e==`number`)return e;if(typeof e==`bigint`)return Number(e);if(Array.isArray(e)&&e.length>0){let t=e[0];if(typeof t==`object`&&t){let e=Object.entries(t);if(e.length===1&&e[0][0]===`count`){let t=e[0][1];return Number(t)}let n={};for(let[t,r]of e)n[t]=Number(r);return n}}if(typeof e==`object`&&e){let t=Object.entries(e);if(t.length===1&&t[0][0]===`count`){let e=t[0][1];return Number(e)}let n={};for(let[e,r]of t)n[e]=Number(r);return n}return 0}function Dt(e){if(e==null)return{count:0};if(typeof e==`number`)return{count:e};if(typeof e==`object`&&e){let t=e;if(`count`in t)return{count:Number(t.count)};if(`rowCount`in t)return{count:Number(t.rowCount)};if(`affectedRows`in t)return{count:Number(t.affectedRows)}}return{count:0}}function Ot(e,t){let n=e[`~`].schemas;switch(t){case`findFirst`:return n.args?.findFirst;case`findMany`:return n.args?.findMany;case`findUnique`:return n.args?.findUnique;case`create`:return n.args?.create;case`createMany`:return n.args?.createMany;case`update`:return n.args?.update;case`updateMany`:return n.args?.updateMany;case`delete`:return n.args?.delete;case`deleteMany`:return n.args?.deleteMany;case`upsert`:return n.args?.upsert;case`count`:return n.args?.count;case`aggregate`:return n.args?.aggregate;case`groupBy`:return n.args?.groupBy;case`exist`:return n.args?.count;default:return}}function kt(e,n,r){let i=Ot(e,n);if(!i)throw new g(n,`Schema not found for operation: ${n}`);let a=t(i,r);if(a.issues)throw new g(n,a.issues.map(e=>`${e.path?.map(e=>e.key).join(`.`)||`root`}: ${e.message}`).join(`; `));return a.value}var At=class{constructor(e,t,n){this.adapter=e,this.registry=t,this.driver=n}build(e,t,n){let r=kt(e,t,n),i=o(this.adapter,e,this.registry);if(t===`create`&&r.data){let e=r.data,{relations:n}=M(i,e);if(Object.values(n).some(e=>e.create))return Se(i,e,r.select,r.include).sql;let a=this.processConnectOperations(i,t,r);return this.buildOperation(i,t,a)}if(t===`update`){let e=this.processConnectOperations(i,t,r);return this.buildOperation(i,t,e)}return this.buildOperation(i,t,r)}processConnectOperations(e,t,n){let r=t===`create`||t===`update`?n.data:void 0;if(!r)return n;let{scalar:i,relations:a}=M(e,r);if(Object.keys(a).length===0)return n;let o={...i};for(let[,t]of Object.entries(a)){if(t.connect&&t.relationInfo.fields?.length){let n=Array.isArray(t.connect)?t.connect[0]:t.connect;if(n){let r=P(e,t.relationInfo,n);Object.assign(o,r)}}if(t.disconnect&&t.relationInfo.fields?.length)for(let e of t.relationInfo.fields)o[e]=null}return{...n,data:o}}async execute(e,t,n){if(!this.driver)throw new _(`No driver provided. Use build() to get SQL without executing.`);let r=kt(e,t,n),i=o(this.adapter,e,this.registry);if(this.hasNestedWrites(t,r))return this.executeWithNestedWrites(i,t,r);let a=this.buildOperation(i,t,r),s=await this.driver.execute(a);return h(t)?X(i,t,{rowCount:s.rowCount}):X(i,t,s.rows)}hasNestedWrites(e,t){if(![`create`,`update`,`upsert`].includes(e))return!1;let n=e===`upsert`?t.create||t.update:t.data;if(!n)return!1;for(let e of Object.values(n))if(e&&typeof e==`object`&&!Array.isArray(e)){let t=e;if(`connect`in t||`create`in t||`connectOrCreate`in t||`disconnect`in t||`delete`in t||`set`in t)return!0}return!1}async executeWithNestedWrites(e,t,n){let r=this.driver;switch(t){case`create`:{let i=n.data,{scalar:a,relations:o}=M(e,i),s=Object.values(o).some(e=>e.connect&&Array.isArray(e.connect)&&e.connect.length>1);if(ye(o)&&!s){let i={...a};for(let[,t]of Object.entries(o))if(t.connect&&t.relationInfo.fields?.length){let n=Array.isArray(t.connect)?t.connect[0]:t.connect,r=P(e,t.relationInfo,n);Object.assign(i,r)}let s=Ge(e,{data:i,select:n.select,include:n.include});return X(e,t,(await r.execute(s)).rows)}let c=await W(r,e,i);if(n.include||n.select){let t=S(e.model),i=c.record[t];if(i!==void 0){let a=H(e,{where:{[t]:i},select:n.select,include:n.include}),o=await r.execute(a);if(o.rows.length>0)return X(e,`findUnique`,o.rows)}}return{...c.record,...c.related}}case`update`:{let i=n.data,a=n.where,{scalar:o,relations:s}=M(e,i);if(Object.keys(s).length>0&&I(s))return r.transaction(async t=>{if(Object.keys(o).length>0){let n=Y(e,{where:a,data:o});await t.execute(n)}let r=H(e,{where:a}),i=(await t.execute(r)).rows[0];if(!i)throw new _(`Record to update not found`);if(await ut(t,e,i,s),n.include||n.select){let r=H(e,{where:a,select:n.select,include:n.include});return X(e,`findUnique`,(await t.execute(r)).rows)}return i});let c=Y(e,n);return X(e,t,(await r.execute(c)).rows)}case`upsert`:return r.transaction(async t=>{let r=n.where,i=H(e,{where:r});if((await t.execute(i)).rows.length>0){let a=n.update,{scalar:o}=M(e,a);if(Object.keys(o).length>0){let n=Y(e,{where:r,data:o});await t.execute(n)}return X(e,`findUnique`,(await t.execute(i)).rows)}let a=n.create;return(await W(t,e,a)).record});default:throw new _(`Nested writes not supported for operation: ${t}`)}}getDriver(){return this.driver}buildOperation(e,t,n){switch(t){case`findFirst`:return tt(e,n);case`findMany`:return nt(e,n);case`findUnique`:return H(e,n);case`create`:return Ge(e,n);case`createMany`:return Ke(e,n.data,n.skipDuplicates);case`update`:return Y(e,n);case`updateMany`:return xt(e,n);case`delete`:return qe(e,n);case`deleteMany`:return Je(e,n);case`upsert`:return St(e,n);case`count`:return Ne(e,n);case`aggregate`:return je(e,n);case`groupBy`:return rt(e,n);case`exist`:{let t={};return n.where&&(t.where=n.where),Ne(e,t)}default:throw new _(`Unknown operation: ${t}`)}}};function jt(e){n(e);let t=new Map,r=new Map;for(let[n,i]of Object.entries(e)){t.set(n,i);let e=i[`~`].names.sql??n;r.set(e,i)}return{get(e){return t.get(e)},getByTableName(e){return r.get(e)}}}var Mt=class extends Error{constructor(e,t){super(`No ${e} record found for ${t}`),this.model=e,this.operation=t,this.name=`NotFoundError`}};function $(e,t,n=[]){return new Proxy(()=>{},{get(r,i){if(typeof i==`string`&&i!==`then`)return $(e,t,[...n,i])},apply(e,r,[i]){let a=n[0],o=n[1];return t({modelName:a,operation:o,args:i})}})}var Nt=class e{constructor(e){this.driver=e.driver,this.schema=e.schema,this.cache=e.cache}createClient(e=this.driver){let t=jt(this.schema),n=new At(e.adapter,t,e);return $(this.schema,async({modelName:e,operation:t,args:r})=>{let i=this.schema[e];if(!i)throw Error(`Model "${String(e)}" not found in schema`);let a=t.endsWith(`OrThrow`)?t.slice(0,-7):t,o=await n.execute(i,a,r??{});if(t.endsWith(`OrThrow`)){if(o===null)throw new Mt(String(e),t);return o}return t===`exist`?o>0:o})}withCache(e){return this.createClient()}static create(t){n(t.schema);let r=new e(t),i=r.createClient();return new Proxy(i,{get(e,t){return t===`$driver`?r.driver:t===`$executeRaw`?e=>r.driver.execute(e):t===`$queryRaw`?(e,t)=>r.driver.executeRaw(e,t):t===`$transaction`?(e,t)=>r.driver.transaction(t=>e(r.createClient(t)),t):t===`$connect`?()=>r.driver.connect?.()??Promise.resolve():t===`$disconnect`?()=>r.driver.disconnect?.()??Promise.resolve():t===`withCache`?e=>r.withCache(e):e[t]}})}};const Pt=e=>Nt.create(e);export{Pt as n,Mt as t};
//# sourceMappingURL=client-BGGl44wE.mjs.map