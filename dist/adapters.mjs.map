{"version":3,"file":"adapters.mjs","names":["notImplemented","sql","sql"],"sources":["../src/adapters/databases/mysql/migrations.ts","../src/adapters/databases/mysql/mysql-adapter.ts","../src/adapters/databases/sqlite/migrations.ts","../src/adapters/databases/sqlite/sqlite-adapter.ts"],"sourcesContent":["/**\n * MySQL Migration Adapter (Stub)\n *\n * Migration support for MySQL is not yet implemented.\n */\n\nimport type { DiffOperation, SchemaSnapshot } from \"../../../migrations/types\";\nimport type { MigrationAdapter } from \"../../database-adapter\";\n\nconst notImplemented = (): never => {\n  throw new Error(\n    \"MySQL migrations are not yet implemented. Please use PostgreSQL.\"\n  );\n};\n\nexport const mysqlMigrations: MigrationAdapter = {\n  introspect: async (): Promise<SchemaSnapshot> => notImplemented(),\n  generateDDL: (_operation: DiffOperation): string => notImplemented(),\n  mapFieldType: (_fieldType: string): string => notImplemented(),\n};\n","import { unsupportedGeospatial, unsupportedVector } from \"@drivers/errors\";\nimport { type Sql, sql } from \"@sql\";\nimport type { DatabaseAdapter, QueryParts } from \"../../database-adapter\";\nimport { mysqlMigrations } from \"./migrations\";\n\n/**\n * MySQL Database Adapter\n *\n * Implements the DatabaseAdapter interface for MySQL-specific SQL generation.\n *\n * Key MySQL features:\n * - Backtick identifier escaping: `table`.`column`\n * - No native ARRAY type - uses JSON for arrays\n * - LIKE is case-insensitive by default (with collation)\n * - JSON_OBJECT(), JSON_ARRAYAGG() for JSON operations\n * - No RETURNING clause (use LAST_INSERT_ID())\n * - No NULLS FIRST/LAST ordering\n * - ON DUPLICATE KEY UPDATE for upserts\n */\nexport class MySQLAdapter implements DatabaseAdapter {\n  // ============================================================\n  // RAW\n  // ============================================================\n\n  raw = (sqlString: string): Sql => sql.raw`${sqlString}`;\n\n  // ============================================================\n  // IDENTIFIERS\n  // ============================================================\n\n  identifiers = {\n    escape: (name: string): Sql => sql.raw`\\`${name}\\``,\n\n    column: (alias: string, field: string): Sql =>\n      alias ? sql.raw`\\`${alias}\\`.\\`${field}\\`` : sql.raw`\\`${field}\\``,\n\n    table: (tableName: string, alias: string): Sql =>\n      sql.raw`\\`${tableName}\\` AS \\`${alias}\\``,\n\n    aliased: (expression: Sql, alias: string): Sql =>\n      sql`${expression} AS ${sql.raw`\\`${alias}\\``}`,\n  };\n\n  // ============================================================\n  // LITERALS\n  // ============================================================\n\n  literals = {\n    value: (v: unknown): Sql => sql`${v}`,\n\n    null: (): Sql => sql.raw`NULL`,\n\n    true: (): Sql => sql.raw`TRUE`,\n\n    false: (): Sql => sql.raw`FALSE`,\n\n    list: (values: Sql[]): Sql => {\n      if (values.length === 0) return sql.raw`()`;\n      return sql`(${sql.join(values, \", \")})`;\n    },\n\n    // MySQL requires JSON values to be stringified\n    json: (v: unknown): Sql => sql`${JSON.stringify(v)}`,\n  };\n\n  // ============================================================\n  // OPERATORS\n  // ============================================================\n\n  operators = {\n    // Comparison\n    eq: (left: Sql, right: Sql): Sql => sql`${left} = ${right}`,\n    neq: (left: Sql, right: Sql): Sql => sql`${left} <> ${right}`,\n    lt: (left: Sql, right: Sql): Sql => sql`${left} < ${right}`,\n    lte: (left: Sql, right: Sql): Sql => sql`${left} <= ${right}`,\n    gt: (left: Sql, right: Sql): Sql => sql`${left} > ${right}`,\n    gte: (left: Sql, right: Sql): Sql => sql`${left} >= ${right}`,\n\n    // Pattern matching\n    like: (column: Sql, pattern: Sql): Sql => sql`${column} LIKE ${pattern}`,\n    notLike: (column: Sql, pattern: Sql): Sql =>\n      sql`${column} NOT LIKE ${pattern}`,\n    // MySQL LIKE is case-insensitive by default with most collations\n    // Use BINARY for case-sensitive, or COLLATE for explicit control\n    ilike: (column: Sql, pattern: Sql): Sql =>\n      sql`${column} LIKE ${pattern} COLLATE utf8mb4_unicode_ci`,\n    notIlike: (column: Sql, pattern: Sql): Sql =>\n      sql`${column} NOT LIKE ${pattern} COLLATE utf8mb4_unicode_ci`,\n\n    // Set membership\n    in: (column: Sql, values: Sql): Sql => sql`${column} IN ${values}`,\n    notIn: (column: Sql, values: Sql): Sql => sql`${column} NOT IN ${values}`,\n\n    // Null checks\n    isNull: (expr: Sql): Sql => sql`${expr} IS NULL`,\n    isNotNull: (expr: Sql): Sql => sql`${expr} IS NOT NULL`,\n\n    // Range\n    between: (column: Sql, min: Sql, max: Sql): Sql =>\n      sql`${column} BETWEEN ${min} AND ${max}`,\n    notBetween: (column: Sql, min: Sql, max: Sql): Sql =>\n      sql`${column} NOT BETWEEN ${min} AND ${max}`,\n\n    // Logical\n    and: (...conditions: Sql[]): Sql => {\n      if (conditions.length === 0) return sql.raw`TRUE`;\n      if (conditions.length === 1) return conditions[0]!;\n      return sql`(${sql.join(conditions, \" AND \")})`;\n    },\n\n    or: (...conditions: Sql[]): Sql => {\n      if (conditions.length === 0) return sql.raw`FALSE`;\n      if (conditions.length === 1) return conditions[0]!;\n      return sql`(${sql.join(conditions, \" OR \")})`;\n    },\n\n    not: (condition: Sql): Sql => sql`NOT (${condition})`,\n\n    // Subquery existence\n    exists: (subquery: Sql): Sql => sql`EXISTS (${subquery})`,\n    notExists: (subquery: Sql): Sql => sql`NOT EXISTS (${subquery})`,\n  };\n\n  // ============================================================\n  // EXPRESSIONS\n  // ============================================================\n\n  expressions = {\n    // Arithmetic\n    add: (left: Sql, right: Sql): Sql => sql`(${left} + ${right})`,\n    subtract: (left: Sql, right: Sql): Sql => sql`(${left} - ${right})`,\n    multiply: (left: Sql, right: Sql): Sql => sql`(${left} * ${right})`,\n    divide: (left: Sql, right: Sql): Sql => sql`(${left} / ${right})`,\n\n    // String operations - MySQL uses CONCAT() function\n    concat: (...parts: Sql[]): Sql => {\n      if (parts.length === 0) return sql.raw`''`;\n      if (parts.length === 1) return parts[0]!;\n      return sql`CONCAT(${sql.join(parts, \", \")})`;\n    },\n    upper: (expr: Sql): Sql => sql`UPPER(${expr})`,\n    lower: (expr: Sql): Sql => sql`LOWER(${expr})`,\n\n    // Utility\n    coalesce: (...exprs: Sql[]): Sql => sql`COALESCE(${sql.join(exprs, \", \")})`,\n    greatest: (...exprs: Sql[]): Sql => sql`GREATEST(${sql.join(exprs, \", \")})`,\n    least: (...exprs: Sql[]): Sql => sql`LEAST(${sql.join(exprs, \", \")})`,\n    cast: (expr: Sql, type: string): Sql =>\n      sql`CAST(${expr} AS ${sql.raw`${type}`})`,\n  };\n\n  // ============================================================\n  // AGGREGATES\n  // ============================================================\n\n  aggregates = {\n    count: (expr?: Sql): Sql =>\n      expr ? sql`COUNT(${expr})` : sql.raw`COUNT(*)`,\n    countDistinct: (expr: Sql): Sql => sql`COUNT(DISTINCT ${expr})`,\n    sum: (expr: Sql): Sql => sql`SUM(${expr})`,\n    avg: (expr: Sql): Sql => sql`AVG(${expr})`,\n    min: (expr: Sql): Sql => sql`MIN(${expr})`,\n    max: (expr: Sql): Sql => sql`MAX(${expr})`,\n  };\n\n  // ============================================================\n  // JSON\n  // ============================================================\n\n  json = {\n    object: (pairs: [string, Sql][]): Sql => {\n      if (pairs.length === 0) return sql.raw`JSON_OBJECT()`;\n      const args = pairs.flatMap(([key, value]) => [sql`${key}`, value]);\n      return sql`JSON_OBJECT(${sql.join(args, \", \")})`;\n    },\n\n    array: (items: Sql[]): Sql => {\n      if (items.length === 0) return sql.raw`JSON_ARRAY()`;\n      return sql`JSON_ARRAY(${sql.join(items, \", \")})`;\n    },\n\n    emptyArray: (): Sql => sql.raw`JSON_ARRAY()`,\n\n    agg: (expr: Sql): Sql =>\n      sql`COALESCE(JSON_ARRAYAGG(${expr}), JSON_ARRAY())`,\n\n    rowToJson: (alias: string): Sql => {\n      // MySQL 8.0+ doesn't have row_to_json, we need to explicitly build object\n      // This is a simplified version - real implementation would need column list\n      return sql`JSON_OBJECT(${sql.raw`'*', \\`${alias}\\`.*`})`;\n    },\n\n    objectFromColumns: (columns: [string, Sql][]): Sql => {\n      if (columns.length === 0) return sql.raw`JSON_OBJECT()`;\n      const args = columns.flatMap(([key, value]) => [sql`${key}`, value]);\n      return sql`JSON_OBJECT(${sql.join(args, \", \")})`;\n    },\n\n    extract: (column: Sql, path: string[]): Sql => {\n      if (path.length === 0) return column;\n      const jsonPath = \"$.\" + path.join(\".\");\n      return sql`JSON_EXTRACT(${column}, ${jsonPath})`;\n    },\n\n    extractText: (column: Sql, path: string[]): Sql => {\n      if (path.length === 0) return column;\n      const jsonPath = \"$.\" + path.join(\".\");\n      return sql`JSON_UNQUOTE(JSON_EXTRACT(${column}, ${jsonPath}))`;\n    },\n  };\n\n  // ============================================================\n  // ARRAYS (JSON-based for MySQL)\n  // ============================================================\n\n  arrays = {\n    // MySQL uses JSON arrays\n    literal: (items: Sql[]): Sql => {\n      if (items.length === 0) return sql.raw`JSON_ARRAY()`;\n      return sql`JSON_ARRAY(${sql.join(items, \", \")})`;\n    },\n\n    // Note: For proper type handling, the query engine should wrap string values\n    // with CAST(value AS JSON) or use JSON_QUOTE for strings\n    has: (column: Sql, value: Sql): Sql =>\n      sql`JSON_CONTAINS(${column}, ${value})`,\n\n    hasEvery: (column: Sql, values: Sql): Sql =>\n      sql`JSON_CONTAINS(${column}, ${values})`,\n\n    hasSome: (column: Sql, values: Sql): Sql =>\n      sql`JSON_OVERLAPS(${column}, ${values})`,\n\n    isEmpty: (column: Sql): Sql =>\n      sql`(JSON_LENGTH(${column}) = 0 OR ${column} IS NULL)`,\n\n    length: (column: Sql): Sql => sql`JSON_LENGTH(${column})`,\n\n    get: (column: Sql, index: Sql): Sql =>\n      sql`JSON_EXTRACT(${column}, CONCAT('$[', ${index}, ']'))`,\n\n    push: (column: Sql, value: Sql): Sql =>\n      sql`JSON_ARRAY_APPEND(${column}, '$', ${value})`,\n\n    set: (column: Sql, index: Sql, value: Sql): Sql =>\n      sql`JSON_SET(${column}, CONCAT('$[', ${index}, ']'), ${value})`,\n  };\n\n  // ============================================================\n  // ORDER BY\n  // ============================================================\n\n  orderBy = {\n    asc: (column: Sql): Sql => sql`${column} ASC`,\n    desc: (column: Sql): Sql => sql`${column} DESC`,\n    // MySQL doesn't support NULLS FIRST/LAST natively\n    // Workaround: ORDER BY ISNULL(col), col\n    nullsFirst: (expr: Sql): Sql => expr, // No-op, would need complex workaround\n    nullsLast: (expr: Sql): Sql => expr, // No-op, would need complex workaround\n  };\n\n  // ============================================================\n  // CLAUSES\n  // ============================================================\n\n  clauses = {\n    select: (columns: Sql): Sql => sql`SELECT ${columns}`,\n    selectDistinct: (columns: Sql): Sql => sql`SELECT DISTINCT ${columns}`,\n    from: (table: Sql): Sql => sql`FROM ${table}`,\n    where: (condition: Sql): Sql => sql`WHERE ${condition}`,\n    orderBy: (orders: Sql): Sql => sql`ORDER BY ${orders}`,\n    limit: (count: Sql): Sql => sql`LIMIT ${count}`,\n    offset: (count: Sql): Sql => sql`OFFSET ${count}`,\n    groupBy: (columns: Sql): Sql => sql`GROUP BY ${columns}`,\n    having: (condition: Sql): Sql => sql`HAVING ${condition}`,\n  };\n\n  // ============================================================\n  // SET (UPDATE operations)\n  // ============================================================\n\n  set = {\n    assign: (column: Sql, value: Sql): Sql => sql`${column} = ${value}`,\n\n    increment: (column: Sql, by: Sql): Sql =>\n      sql`${column} = ${column} + ${by}`,\n\n    decrement: (column: Sql, by: Sql): Sql =>\n      sql`${column} = ${column} - ${by}`,\n\n    multiply: (column: Sql, by: Sql): Sql => sql`${column} = ${column} * ${by}`,\n\n    divide: (column: Sql, by: Sql): Sql => sql`${column} = ${column} / ${by}`,\n\n    push: (column: Sql, value: Sql): Sql =>\n      sql`${column} = JSON_ARRAY_APPEND(${column}, '$', ${value})`,\n\n    unshift: (column: Sql, value: Sql): Sql =>\n      sql`${column} = JSON_ARRAY_INSERT(${column}, '$[0]', ${value})`,\n  };\n\n  // ============================================================\n  // FILTERS (Relation subquery wrappers)\n  // ============================================================\n\n  filters = {\n    some: (subquery: Sql): Sql => sql`EXISTS (${subquery})`,\n    every: (subquery: Sql): Sql => sql`NOT EXISTS (${subquery})`,\n    none: (subquery: Sql): Sql => sql`NOT EXISTS (${subquery})`,\n    is: (subquery: Sql): Sql => sql`EXISTS (${subquery})`,\n    isNot: (subquery: Sql): Sql => sql`NOT EXISTS (${subquery})`,\n  };\n\n  // ============================================================\n  // SUBQUERIES\n  // ============================================================\n\n  subqueries = {\n    scalar: (query: Sql): Sql => sql`(${query})`,\n\n    correlate: (query: Sql, alias: string): Sql =>\n      sql`(${query}) AS ${sql.raw`\\`${alias}\\``}`,\n\n    existsCheck: (from: Sql, where: Sql): Sql =>\n      sql`SELECT 1 FROM ${from} WHERE ${where}`,\n  };\n\n  // ============================================================\n  // ASSEMBLE (Build complete SQL statements)\n  // ============================================================\n\n  assemble = {\n    select: (parts: QueryParts): Sql => {\n      // MySQL doesn't support DISTINCT ON natively\n      // Simulate using ROW_NUMBER() OVER (PARTITION BY ... ORDER BY ...)\n      if (parts.distinct) {\n        return this.assembleDistinctOn(parts);\n      }\n\n      const fragments: Sql[] = [\n        sql`SELECT ${parts.columns}`,\n        sql`FROM ${parts.from}`,\n      ];\n\n      if (parts.joins && parts.joins.length > 0) {\n        fragments.push(...parts.joins);\n      }\n\n      if (parts.where) {\n        fragments.push(sql`WHERE ${parts.where}`);\n      }\n\n      if (parts.groupBy) {\n        fragments.push(sql`GROUP BY ${parts.groupBy}`);\n      }\n\n      if (parts.having) {\n        fragments.push(sql`HAVING ${parts.having}`);\n      }\n\n      if (parts.orderBy) {\n        fragments.push(sql`ORDER BY ${parts.orderBy}`);\n      }\n\n      if (parts.limit) {\n        fragments.push(sql`LIMIT ${parts.limit}`);\n      }\n\n      if (parts.offset) {\n        fragments.push(sql`OFFSET ${parts.offset}`);\n      }\n\n      return sql.join(fragments, \" \");\n    },\n  };\n\n  /**\n   * Simulate DISTINCT ON using ROW_NUMBER() window function.\n   *\n   * Generates:\n   * SELECT col1, col2, ... FROM (\n   *   SELECT columns, ROW_NUMBER() OVER (PARTITION BY distinct_cols ORDER BY order_cols) AS _rn\n   *   FROM table\n   *   WHERE ...\n   * ) AS _distinct_subquery\n   * WHERE _rn = 1\n   * ORDER BY ...\n   * LIMIT ... OFFSET ...\n   */\n  private assembleDistinctOn(parts: QueryParts): Sql {\n    // Build the ORDER BY for ROW_NUMBER() - use provided orderBy or default to distinct columns\n    const rowNumberOrder = parts.orderBy || parts.distinct!;\n\n    // Inner query with ROW_NUMBER()\n    const innerFragments: Sql[] = [\n      sql`SELECT ${parts.columns}, ROW_NUMBER() OVER (PARTITION BY ${parts.distinct} ORDER BY ${rowNumberOrder}) AS \\`_rn\\``,\n      sql`FROM ${parts.from}`,\n    ];\n\n    if (parts.joins && parts.joins.length > 0) {\n      innerFragments.push(...parts.joins);\n    }\n\n    if (parts.where) {\n      innerFragments.push(sql`WHERE ${parts.where}`);\n    }\n\n    if (parts.groupBy) {\n      innerFragments.push(sql`GROUP BY ${parts.groupBy}`);\n    }\n\n    if (parts.having) {\n      innerFragments.push(sql`HAVING ${parts.having}`);\n    }\n\n    const innerQuery = sql.join(innerFragments, \" \");\n\n    // Build outer SELECT - use explicit column aliases to exclude _rn\n    let outerSelect: Sql;\n    if (parts.distinctColumnAliases && parts.distinctColumnAliases.length > 0) {\n      // Select only the original columns, excluding _rn\n      const aliasColumns = parts.distinctColumnAliases.map(\n        (alias) => sql.raw`\\`${alias}\\``\n      );\n      outerSelect = sql`SELECT ${sql.join(aliasColumns, \", \")} FROM (${innerQuery}) AS \\`_distinct_subquery\\``;\n    } else {\n      // Fallback to SELECT * (includes _rn)\n      outerSelect = sql`SELECT * FROM (${innerQuery}) AS \\`_distinct_subquery\\``;\n    }\n\n    // Outer query that filters for first row of each partition\n    const outerFragments: Sql[] = [outerSelect, sql.raw`WHERE \\`_rn\\` = 1`];\n\n    if (parts.orderBy) {\n      outerFragments.push(sql`ORDER BY ${parts.orderBy}`);\n    }\n\n    if (parts.limit) {\n      outerFragments.push(sql`LIMIT ${parts.limit}`);\n    }\n\n    if (parts.offset) {\n      outerFragments.push(sql`OFFSET ${parts.offset}`);\n    }\n\n    return sql.join(outerFragments, \" \");\n  }\n\n  // ============================================================\n  // CTE (Common Table Expressions - MySQL 8.0+)\n  // ============================================================\n\n  cte = {\n    with: (definitions: { name: string; query: Sql }[]): Sql => {\n      const defs = definitions.map(\n        ({ name, query }) => sql`${sql.raw`\\`${name}\\``} AS (${query})`\n      );\n      return sql`WITH ${sql.join(defs, \", \")}`;\n    },\n\n    recursive: (\n      name: string,\n      anchor: Sql,\n      recursive: Sql,\n      union: \"all\" | \"distinct\" = \"all\"\n    ): Sql => {\n      const unionKeyword =\n        union === \"all\" ? sql.raw`UNION ALL` : sql.raw`UNION`;\n      return sql`WITH RECURSIVE ${sql.raw`\\`${name}\\``} AS (\n        ${anchor}\n        ${unionKeyword}\n        ${recursive}\n      )`;\n    },\n  };\n\n  // ============================================================\n  // MUTATIONS\n  // ============================================================\n\n  mutations = {\n    insert: (table: Sql, columns: string[], values: Sql[][]): Sql => {\n      const cols = columns.map((c) => sql.raw`\\`${c}\\``);\n      const rows = values.map((row) => sql`(${sql.join(row, \", \")})`);\n      return sql`INSERT INTO ${table} (${sql.join(\n        cols,\n        \", \"\n      )}) VALUES ${sql.join(rows, \", \")}`;\n    },\n\n    update: (table: Sql, sets: Sql, where?: Sql): Sql => {\n      if (where) {\n        return sql`UPDATE ${table} SET ${sets} WHERE ${where}`;\n      }\n      return sql`UPDATE ${table} SET ${sets}`;\n    },\n\n    delete: (table: Sql, where?: Sql): Sql => {\n      if (where) {\n        return sql`DELETE FROM ${table} WHERE ${where}`;\n      }\n      return sql`DELETE FROM ${table}`;\n    },\n\n    // MySQL doesn't support RETURNING - returns empty\n    // Use LAST_INSERT_ID() or SELECT after mutation\n    returning: (_columns: Sql): Sql => sql.empty,\n\n    // MySQL uses ON DUPLICATE KEY UPDATE syntax\n    onConflict: (_target: Sql | null, action: Sql): Sql => {\n      return sql`ON DUPLICATE KEY UPDATE ${action}`;\n    },\n  };\n\n  // ============================================================\n  // JOINS\n  // ============================================================\n\n  joins = {\n    inner: (table: Sql, condition: Sql): Sql =>\n      sql`INNER JOIN ${table} ON ${condition}`,\n\n    left: (table: Sql, condition: Sql): Sql =>\n      sql`LEFT JOIN ${table} ON ${condition}`,\n\n    right: (table: Sql, condition: Sql): Sql =>\n      sql`RIGHT JOIN ${table} ON ${condition}`,\n\n    // MySQL doesn't support FULL OUTER JOIN directly\n    // Would need UNION of LEFT and RIGHT joins\n    full: (table: Sql, condition: Sql): Sql =>\n      sql`LEFT JOIN ${table} ON ${condition}`,\n\n    cross: (table: Sql): Sql => sql`CROSS JOIN ${table}`,\n  };\n\n  // ============================================================\n  // SET OPERATIONS\n  // ============================================================\n\n  setOperations = {\n    union: (...queries: Sql[]): Sql => sql.join(queries, \" UNION \"),\n\n    unionAll: (...queries: Sql[]): Sql => sql.join(queries, \" UNION ALL \"),\n\n    intersect: (...queries: Sql[]): Sql => sql.join(queries, \" INTERSECT \"),\n\n    // MySQL uses EXCEPT in 8.0.31+, older versions need workaround\n    except: (left: Sql, right: Sql): Sql => sql`${left} EXCEPT ${right}`,\n  };\n\n  // ============================================================\n  // CAPABILITIES\n  // ============================================================\n\n  capabilities = {\n    supportsReturning: false,\n    supportsCteWithMutations: false, // MySQL CTEs are read-only\n    supportsFullOuterJoin: false,\n  };\n\n  lastInsertId = (): Sql => sql.raw`LAST_INSERT_ID()`;\n\n  // ============================================================\n  // MIGRATIONS\n  // ============================================================\n\n  migrations = mysqlMigrations;\n\n  // ============================================================\n  // VECTOR (not natively supported in MySQL)\n  // ============================================================\n\n  vector = unsupportedVector;\n\n  // ============================================================\n  // GEOSPATIAL (not natively supported in MySQL adapter)\n  // ============================================================\n\n  geospatial = unsupportedGeospatial;\n}\n\n// Export singleton instance\nexport const mysqlAdapter = new MySQLAdapter();\n","/**\n * SQLite Migration Adapter (Stub)\n *\n * Migration support for SQLite is not yet implemented.\n */\n\nimport type { DiffOperation, SchemaSnapshot } from \"../../../migrations/types\";\nimport type { MigrationAdapter } from \"../../database-adapter\";\n\nconst notImplemented = (): never => {\n  throw new Error(\n    \"SQLite migrations are not yet implemented. Please use PostgreSQL.\"\n  );\n};\n\nexport const sqliteMigrations: MigrationAdapter = {\n  introspect: async (): Promise<SchemaSnapshot> => notImplemented(),\n  generateDDL: (_operation: DiffOperation): string => notImplemented(),\n  mapFieldType: (_fieldType: string): string => notImplemented(),\n};\n","import { unsupportedGeospatial, unsupportedVector } from \"@drivers/errors\";\nimport { type Sql, sql } from \"@sql\";\nimport type { DatabaseAdapter, QueryParts } from \"../../database-adapter\";\nimport { sqliteMigrations } from \"./migrations\";\n\n/**\n * SQLite Database Adapter\n *\n * Implements the DatabaseAdapter interface for SQLite-specific SQL generation.\n *\n * Key SQLite features:\n * - Double-quote identifier escaping: \"table\".\"column\"\n * - No native ARRAY type - uses JSON for arrays\n * - LIKE is case-insensitive for ASCII by default\n * - json_object(), json_group_array() for JSON operations (SQLite 3.38+)\n * - RETURNING clause supported (SQLite 3.35+)\n * - No NULLS FIRST/LAST ordering\n * - ON CONFLICT DO UPDATE/NOTHING (same as PostgreSQL)\n * - || for string concatenation\n * - Boolean stored as 0/1 integers\n */\nexport class SQLiteAdapter implements DatabaseAdapter {\n  // ============================================================\n  // RAW\n  // ============================================================\n\n  raw = (sqlString: string): Sql => sql.raw`${sqlString}`;\n\n  // ============================================================\n  // IDENTIFIERS\n  // ============================================================\n\n  identifiers = {\n    escape: (name: string): Sql => sql.raw`\"${name}\"`,\n\n    column: (alias: string, field: string): Sql =>\n      alias ? sql.raw`\"${alias}\".\"${field}\"` : sql.raw`\"${field}\"`,\n\n    table: (tableName: string, alias: string): Sql =>\n      sql.raw`\"${tableName}\" AS \"${alias}\"`,\n\n    aliased: (expression: Sql, alias: string): Sql =>\n      sql`${expression} AS ${sql.raw`\"${alias}\"`}`,\n  };\n\n  // ============================================================\n  // LITERALS\n  // ============================================================\n\n  literals = {\n    value: (v: unknown): Sql => sql`${v}`,\n\n    null: (): Sql => sql.raw`NULL`,\n\n    // SQLite uses 1/0 for booleans\n    true: (): Sql => sql.raw`1`,\n\n    false: (): Sql => sql.raw`0`,\n\n    list: (values: Sql[]): Sql => {\n      if (values.length === 0) return sql.raw`()`;\n      return sql`(${sql.join(values, \", \")})`;\n    },\n\n    // SQLite requires JSON values to be stringified\n    json: (v: unknown): Sql => sql`${JSON.stringify(v)}`,\n  };\n\n  // ============================================================\n  // OPERATORS\n  // ============================================================\n\n  operators = {\n    // Comparison\n    eq: (left: Sql, right: Sql): Sql => sql`${left} = ${right}`,\n    neq: (left: Sql, right: Sql): Sql => sql`${left} <> ${right}`,\n    lt: (left: Sql, right: Sql): Sql => sql`${left} < ${right}`,\n    lte: (left: Sql, right: Sql): Sql => sql`${left} <= ${right}`,\n    gt: (left: Sql, right: Sql): Sql => sql`${left} > ${right}`,\n    gte: (left: Sql, right: Sql): Sql => sql`${left} >= ${right}`,\n\n    // Pattern matching\n    like: (column: Sql, pattern: Sql): Sql => sql`${column} LIKE ${pattern}`,\n    notLike: (column: Sql, pattern: Sql): Sql =>\n      sql`${column} NOT LIKE ${pattern}`,\n    // SQLite LIKE is case-insensitive for ASCII by default\n    // Use COLLATE NOCASE for explicit case-insensitivity\n    ilike: (column: Sql, pattern: Sql): Sql =>\n      sql`${column} LIKE ${pattern} COLLATE NOCASE`,\n    notIlike: (column: Sql, pattern: Sql): Sql =>\n      sql`${column} NOT LIKE ${pattern} COLLATE NOCASE`,\n\n    // Set membership\n    in: (column: Sql, values: Sql): Sql => sql`${column} IN ${values}`,\n    notIn: (column: Sql, values: Sql): Sql => sql`${column} NOT IN ${values}`,\n\n    // Null checks\n    isNull: (expr: Sql): Sql => sql`${expr} IS NULL`,\n    isNotNull: (expr: Sql): Sql => sql`${expr} IS NOT NULL`,\n\n    // Range\n    between: (column: Sql, min: Sql, max: Sql): Sql =>\n      sql`${column} BETWEEN ${min} AND ${max}`,\n    notBetween: (column: Sql, min: Sql, max: Sql): Sql =>\n      sql`${column} NOT BETWEEN ${min} AND ${max}`,\n\n    // Logical\n    and: (...conditions: Sql[]): Sql => {\n      if (conditions.length === 0) return sql.raw`1`;\n      if (conditions.length === 1) return conditions[0]!;\n      return sql`(${sql.join(conditions, \" AND \")})`;\n    },\n\n    or: (...conditions: Sql[]): Sql => {\n      if (conditions.length === 0) return sql.raw`0`;\n      if (conditions.length === 1) return conditions[0]!;\n      return sql`(${sql.join(conditions, \" OR \")})`;\n    },\n\n    not: (condition: Sql): Sql => sql`NOT (${condition})`,\n\n    // Subquery existence\n    exists: (subquery: Sql): Sql => sql`EXISTS (${subquery})`,\n    notExists: (subquery: Sql): Sql => sql`NOT EXISTS (${subquery})`,\n  };\n\n  // ============================================================\n  // EXPRESSIONS\n  // ============================================================\n\n  expressions = {\n    // Arithmetic\n    add: (left: Sql, right: Sql): Sql => sql`(${left} + ${right})`,\n    subtract: (left: Sql, right: Sql): Sql => sql`(${left} - ${right})`,\n    multiply: (left: Sql, right: Sql): Sql => sql`(${left} * ${right})`,\n    divide: (left: Sql, right: Sql): Sql => sql`(${left} / ${right})`,\n\n    // String operations - SQLite uses || for concatenation\n    concat: (...parts: Sql[]): Sql => {\n      if (parts.length === 0) return sql.raw`''`;\n      if (parts.length === 1) return parts[0]!;\n      return sql`(${sql.join(parts, \" || \")})`;\n    },\n    upper: (expr: Sql): Sql => sql`UPPER(${expr})`,\n    lower: (expr: Sql): Sql => sql`LOWER(${expr})`,\n\n    // Utility\n    coalesce: (...exprs: Sql[]): Sql => sql`COALESCE(${sql.join(exprs, \", \")})`,\n    greatest: (...exprs: Sql[]): Sql => sql`MAX(${sql.join(exprs, \", \")})`,\n    least: (...exprs: Sql[]): Sql => sql`MIN(${sql.join(exprs, \", \")})`,\n    cast: (expr: Sql, type: string): Sql =>\n      sql`CAST(${expr} AS ${sql.raw`${type}`})`,\n  };\n\n  // ============================================================\n  // AGGREGATES\n  // ============================================================\n\n  aggregates = {\n    count: (expr?: Sql): Sql =>\n      expr ? sql`COUNT(${expr})` : sql.raw`COUNT(*)`,\n    countDistinct: (expr: Sql): Sql => sql`COUNT(DISTINCT ${expr})`,\n    sum: (expr: Sql): Sql => sql`SUM(${expr})`,\n    avg: (expr: Sql): Sql => sql`AVG(${expr})`,\n    min: (expr: Sql): Sql => sql`MIN(${expr})`,\n    max: (expr: Sql): Sql => sql`MAX(${expr})`,\n  };\n\n  // ============================================================\n  // JSON (SQLite 3.38+ JSON functions)\n  // ============================================================\n\n  json = {\n    object: (pairs: [string, Sql][]): Sql => {\n      if (pairs.length === 0) return sql.raw`json_object()`;\n      const args = pairs.flatMap(([key, value]) => [sql`${key}`, value]);\n      return sql`json_object(${sql.join(args, \", \")})`;\n    },\n\n    array: (items: Sql[]): Sql => {\n      if (items.length === 0) return sql.raw`json_array()`;\n      return sql`json_array(${sql.join(items, \", \")})`;\n    },\n\n    emptyArray: (): Sql => sql.raw`json_array()`,\n\n    agg: (expr: Sql): Sql =>\n      sql`COALESCE(json_group_array(${expr}), json_array())`,\n\n    rowToJson: (alias: string): Sql => {\n      // SQLite doesn't have row_to_json - would need to build manually\n      // This is a placeholder that returns the alias as a reference\n      return sql`json_object(${sql.raw`'row', \"${alias}\".*`})`;\n    },\n\n    objectFromColumns: (columns: [string, Sql][]): Sql => {\n      if (columns.length === 0) return sql.raw`json_object()`;\n      const args = columns.flatMap(([key, value]) => [sql`${key}`, value]);\n      return sql`json_object(${sql.join(args, \", \")})`;\n    },\n\n    extract: (column: Sql, path: string[]): Sql => {\n      if (path.length === 0) return column;\n      const jsonPath = `$.${path.join(\".\")}`;\n      return sql`json_extract(${column}, ${jsonPath})`;\n    },\n\n    extractText: (column: Sql, path: string[]): Sql => {\n      // SQLite json_extract returns the value in native form\n      // For text, we can cast or use as-is\n      if (path.length === 0) return column;\n      const jsonPath = `$.${path.join(\".\")}`;\n      return sql`json_extract(${column}, ${jsonPath})`;\n    },\n  };\n\n  // ============================================================\n  // ARRAYS (JSON-based for SQLite)\n  // ============================================================\n\n  arrays = {\n    // SQLite uses JSON arrays\n    literal: (items: Sql[]): Sql => {\n      if (items.length === 0) return sql.raw`json_array()`;\n      return sql`json_array(${sql.join(items, \", \")})`;\n    },\n\n    // Check if value exists in JSON array using json_each\n    has: (column: Sql, value: Sql): Sql =>\n      sql`EXISTS (SELECT 1 FROM json_each(${column}) WHERE value = ${value})`,\n\n    hasEvery: (column: Sql, values: Sql): Sql =>\n      sql`(SELECT COUNT(*) FROM json_each(${values}) WHERE value IN (SELECT value FROM json_each(${column}))) = json_array_length(${values})`,\n\n    hasSome: (column: Sql, values: Sql): Sql =>\n      sql`EXISTS (SELECT 1 FROM json_each(${column}) AS a, json_each(${values}) AS b WHERE a.value = b.value)`,\n\n    isEmpty: (column: Sql): Sql =>\n      sql`(json_array_length(${column}) = 0 OR ${column} IS NULL)`,\n\n    length: (column: Sql): Sql => sql`json_array_length(${column})`,\n\n    get: (column: Sql, index: Sql): Sql =>\n      sql`json_extract(${column}, '$[' || ${index} || ']')`,\n\n    push: (column: Sql, value: Sql): Sql =>\n      sql`json_insert(${column}, '$[#]', ${value})`,\n\n    set: (column: Sql, index: Sql, value: Sql): Sql =>\n      sql`json_set(${column}, '$[' || ${index} || ']', ${value})`,\n  };\n\n  // ============================================================\n  // ORDER BY\n  // ============================================================\n\n  orderBy = {\n    asc: (column: Sql): Sql => sql`${column} ASC`,\n    desc: (column: Sql): Sql => sql`${column} DESC`,\n    // SQLite doesn't support NULLS FIRST/LAST natively\n    nullsFirst: (expr: Sql): Sql => expr, // No-op\n    nullsLast: (expr: Sql): Sql => expr, // No-op\n  };\n\n  // ============================================================\n  // CLAUSES\n  // ============================================================\n\n  clauses = {\n    select: (columns: Sql): Sql => sql`SELECT ${columns}`,\n    selectDistinct: (columns: Sql): Sql => sql`SELECT DISTINCT ${columns}`,\n    from: (table: Sql): Sql => sql`FROM ${table}`,\n    where: (condition: Sql): Sql => sql`WHERE ${condition}`,\n    orderBy: (orders: Sql): Sql => sql`ORDER BY ${orders}`,\n    limit: (count: Sql): Sql => sql`LIMIT ${count}`,\n    offset: (count: Sql): Sql => sql`OFFSET ${count}`,\n    groupBy: (columns: Sql): Sql => sql`GROUP BY ${columns}`,\n    having: (condition: Sql): Sql => sql`HAVING ${condition}`,\n  };\n\n  // ============================================================\n  // SET (UPDATE operations)\n  // ============================================================\n\n  set = {\n    assign: (column: Sql, value: Sql): Sql => sql`${column} = ${value}`,\n\n    increment: (column: Sql, by: Sql): Sql =>\n      sql`${column} = ${column} + ${by}`,\n\n    decrement: (column: Sql, by: Sql): Sql =>\n      sql`${column} = ${column} - ${by}`,\n\n    multiply: (column: Sql, by: Sql): Sql => sql`${column} = ${column} * ${by}`,\n\n    divide: (column: Sql, by: Sql): Sql => sql`${column} = ${column} / ${by}`,\n\n    push: (column: Sql, value: Sql): Sql =>\n      sql`${column} = json_insert(${column}, '$[#]', ${value})`,\n\n    unshift: (column: Sql, value: Sql): Sql =>\n      sql`${column} = json('[' || json(${value}) || CASE WHEN COALESCE(${column}, '[]') = '[]' THEN ']' ELSE ',' || substr(${column}, 2) END)`,\n  };\n\n  // ============================================================\n  // FILTERS (Relation subquery wrappers)\n  // ============================================================\n\n  filters = {\n    some: (subquery: Sql): Sql => sql`EXISTS (${subquery})`,\n    every: (subquery: Sql): Sql => sql`NOT EXISTS (${subquery})`,\n    none: (subquery: Sql): Sql => sql`NOT EXISTS (${subquery})`,\n    is: (subquery: Sql): Sql => sql`EXISTS (${subquery})`,\n    isNot: (subquery: Sql): Sql => sql`NOT EXISTS (${subquery})`,\n  };\n\n  // ============================================================\n  // SUBQUERIES\n  // ============================================================\n\n  subqueries = {\n    scalar: (query: Sql): Sql => sql`(${query})`,\n\n    correlate: (query: Sql, alias: string): Sql =>\n      sql`(${query}) AS ${sql.raw`\"${alias}\"`}`,\n\n    existsCheck: (from: Sql, where: Sql): Sql =>\n      sql`SELECT 1 FROM ${from} WHERE ${where}`,\n  };\n\n  // ============================================================\n  // ASSEMBLE (Build complete SQL statements)\n  // ============================================================\n\n  assemble = {\n    select: (parts: QueryParts): Sql => {\n      // SQLite doesn't support DISTINCT ON natively\n      // Simulate using ROW_NUMBER() OVER (PARTITION BY ... ORDER BY ...)\n      if (parts.distinct) {\n        return this.assembleDistinctOn(parts);\n      }\n\n      const fragments: Sql[] = [\n        sql`SELECT ${parts.columns}`,\n        sql`FROM ${parts.from}`,\n      ];\n\n      if (parts.joins && parts.joins.length > 0) {\n        fragments.push(...parts.joins);\n      }\n\n      if (parts.where) {\n        fragments.push(sql`WHERE ${parts.where}`);\n      }\n\n      if (parts.groupBy) {\n        fragments.push(sql`GROUP BY ${parts.groupBy}`);\n      }\n\n      if (parts.having) {\n        fragments.push(sql`HAVING ${parts.having}`);\n      }\n\n      if (parts.orderBy) {\n        fragments.push(sql`ORDER BY ${parts.orderBy}`);\n      }\n\n      if (parts.limit) {\n        fragments.push(sql`LIMIT ${parts.limit}`);\n      }\n\n      if (parts.offset) {\n        fragments.push(sql`OFFSET ${parts.offset}`);\n      }\n\n      return sql.join(fragments, \" \");\n    },\n  };\n\n  /**\n   * Simulate DISTINCT ON using ROW_NUMBER() window function.\n   *\n   * Generates:\n   * SELECT col1, col2, ... FROM (\n   *   SELECT columns, ROW_NUMBER() OVER (PARTITION BY distinct_cols ORDER BY order_cols) AS _rn\n   *   FROM table\n   *   WHERE ...\n   * ) AS _distinct_subquery\n   * WHERE _rn = 1\n   * ORDER BY ...\n   * LIMIT ... OFFSET ...\n   */\n  private assembleDistinctOn(parts: QueryParts): Sql {\n    // Build the ORDER BY for ROW_NUMBER() - use provided orderBy or default to distinct columns\n    const rowNumberOrder = parts.orderBy || parts.distinct!;\n\n    // Inner query with ROW_NUMBER()\n    const innerFragments: Sql[] = [\n      sql`SELECT ${parts.columns}, ROW_NUMBER() OVER (PARTITION BY ${parts.distinct} ORDER BY ${rowNumberOrder}) AS \"_rn\"`,\n      sql`FROM ${parts.from}`,\n    ];\n\n    if (parts.joins && parts.joins.length > 0) {\n      innerFragments.push(...parts.joins);\n    }\n\n    if (parts.where) {\n      innerFragments.push(sql`WHERE ${parts.where}`);\n    }\n\n    if (parts.groupBy) {\n      innerFragments.push(sql`GROUP BY ${parts.groupBy}`);\n    }\n\n    if (parts.having) {\n      innerFragments.push(sql`HAVING ${parts.having}`);\n    }\n\n    const innerQuery = sql.join(innerFragments, \" \");\n\n    // Build outer SELECT - use explicit column aliases to exclude _rn\n    let outerSelect: Sql;\n    if (parts.distinctColumnAliases && parts.distinctColumnAliases.length > 0) {\n      // Select only the original columns, excluding _rn\n      const aliasColumns = parts.distinctColumnAliases.map(\n        (alias) => sql.raw`\"${alias}\"`\n      );\n      outerSelect = sql`SELECT ${sql.join(\n        aliasColumns,\n        \", \"\n      )} FROM (${innerQuery}) AS \"_distinct_subquery\"`;\n    } else {\n      // Fallback to SELECT * (includes _rn)\n      outerSelect = sql`SELECT * FROM (${innerQuery}) AS \"_distinct_subquery\"`;\n    }\n\n    // Outer query that filters for first row of each partition\n    const outerFragments: Sql[] = [outerSelect, sql.raw`WHERE \"_rn\" = 1`];\n\n    if (parts.orderBy) {\n      outerFragments.push(sql`ORDER BY ${parts.orderBy}`);\n    }\n\n    if (parts.limit) {\n      outerFragments.push(sql`LIMIT ${parts.limit}`);\n    }\n\n    if (parts.offset) {\n      outerFragments.push(sql`OFFSET ${parts.offset}`);\n    }\n\n    return sql.join(outerFragments, \" \");\n  }\n\n  // ============================================================\n  // CTE (Common Table Expressions)\n  // ============================================================\n\n  cte = {\n    with: (definitions: { name: string; query: Sql }[]): Sql => {\n      const defs = definitions.map(\n        ({ name, query }) => sql`${sql.raw`\"${name}\"`} AS (${query})`\n      );\n      return sql`WITH ${sql.join(defs, \", \")}`;\n    },\n\n    recursive: (\n      name: string,\n      anchor: Sql,\n      recursive: Sql,\n      union: \"all\" | \"distinct\" = \"all\"\n    ): Sql => {\n      const unionKeyword =\n        union === \"all\" ? sql.raw`UNION ALL` : sql.raw`UNION`;\n      return sql`WITH RECURSIVE ${sql.raw`\"${name}\"`} AS (\n        ${anchor}\n        ${unionKeyword}\n        ${recursive}\n      )`;\n    },\n  };\n\n  // ============================================================\n  // MUTATIONS\n  // ============================================================\n\n  mutations = {\n    insert: (table: Sql, columns: string[], values: Sql[][]): Sql => {\n      const cols = columns.map((c) => sql.raw`\"${c}\"`);\n      const rows = values.map((row) => sql`(${sql.join(row, \", \")})`);\n      return sql`INSERT INTO ${table} (${sql.join(\n        cols,\n        \", \"\n      )}) VALUES ${sql.join(rows, \", \")}`;\n    },\n\n    update: (table: Sql, sets: Sql, where?: Sql): Sql => {\n      if (where) {\n        return sql`UPDATE ${table} SET ${sets} WHERE ${where}`;\n      }\n      return sql`UPDATE ${table} SET ${sets}`;\n    },\n\n    delete: (table: Sql, where?: Sql): Sql => {\n      if (where) {\n        return sql`DELETE FROM ${table} WHERE ${where}`;\n      }\n      return sql`DELETE FROM ${table}`;\n    },\n\n    // SQLite 3.35+ supports RETURNING\n    returning: (columns: Sql): Sql => sql`RETURNING ${columns}`,\n\n    // SQLite uses same syntax as PostgreSQL for ON CONFLICT\n    onConflict: (target: Sql | null, action: Sql): Sql => {\n      if (target) {\n        return sql`ON CONFLICT (${target}) DO ${action}`;\n      }\n      return sql`ON CONFLICT DO ${action}`;\n    },\n  };\n\n  // ============================================================\n  // JOINS\n  // ============================================================\n\n  joins = {\n    inner: (table: Sql, condition: Sql): Sql =>\n      sql`INNER JOIN ${table} ON ${condition}`,\n\n    left: (table: Sql, condition: Sql): Sql =>\n      sql`LEFT JOIN ${table} ON ${condition}`,\n\n    // SQLite doesn't support RIGHT JOIN - use LEFT JOIN with tables swapped\n    right: (table: Sql, condition: Sql): Sql =>\n      sql`LEFT JOIN ${table} ON ${condition}`,\n\n    // SQLite doesn't support FULL OUTER JOIN\n    full: (table: Sql, condition: Sql): Sql =>\n      sql`LEFT JOIN ${table} ON ${condition}`,\n\n    cross: (table: Sql): Sql => sql`CROSS JOIN ${table}`,\n  };\n\n  // ============================================================\n  // SET OPERATIONS\n  // ============================================================\n\n  setOperations = {\n    union: (...queries: Sql[]): Sql => sql.join(queries, \" UNION \"),\n\n    unionAll: (...queries: Sql[]): Sql => sql.join(queries, \" UNION ALL \"),\n\n    intersect: (...queries: Sql[]): Sql => sql.join(queries, \" INTERSECT \"),\n\n    except: (left: Sql, right: Sql): Sql => sql`${left} EXCEPT ${right}`,\n  };\n\n  // ============================================================\n  // CAPABILITIES\n  // ============================================================\n\n  capabilities = {\n    supportsReturning: true, // SQLite 3.35+\n    supportsCteWithMutations: true,\n    supportsFullOuterJoin: false,\n  };\n\n  lastInsertId = (): Sql => sql.raw`last_insert_rowid()`;\n\n  // ============================================================\n  // MIGRATIONS\n  // ============================================================\n\n  migrations = sqliteMigrations;\n\n  // ============================================================\n  // VECTOR (not natively supported in SQLite)\n  // ============================================================\n\n  vector = unsupportedVector;\n\n  // ============================================================\n  // GEOSPATIAL (not natively supported in SQLite)\n  // ============================================================\n\n  geospatial = unsupportedGeospatial;\n}\n\n// Export singleton instance\nexport const sqliteAdapter = new SQLiteAdapter();\n"],"mappings":"mJASA,MAAMA,MAA8B,CAClC,MAAU,MACR,mEACD,EAGU,EAAoC,CAC/C,WAAY,SAAqCA,GAAgB,CACjE,YAAc,GAAsCA,GAAgB,CACpE,aAAe,GAA+BA,GAAgB,CAC/D,CCAD,IAAa,EAAb,KAAqD,wBAK5C,GAA2B,EAAI,GAAG,GAAG,qBAM9B,CACZ,OAAS,GAAsB,EAAI,GAAG,KAAK,EAAK,IAEhD,QAAS,EAAe,IACtB,EAAQ,EAAI,GAAG,KAAK,EAAM,OAAO,EAAM,IAAM,EAAI,GAAG,KAAK,EAAM,IAEjE,OAAQ,EAAmB,IACzB,EAAI,GAAG,KAAK,EAAU,UAAU,EAAM,IAExC,SAAU,EAAiB,IACzB,CAAG,GAAG,EAAW,MAAM,EAAI,GAAG,KAAK,EAAM,MAC5C,eAMU,CACT,MAAQ,GAAoB,CAAG,GAAG,IAElC,SAAiB,EAAI,GAAG,OAExB,SAAiB,EAAI,GAAG,OAExB,UAAkB,EAAI,GAAG,QAEzB,KAAO,GACD,EAAO,SAAW,EAAU,EAAI,GAAG,KAChC,CAAG,IAAIC,EAAI,KAAK,EAAQ,KAAK,CAAC,GAIvC,KAAO,GAAoB,CAAG,GAAG,KAAK,UAAU,EAAE,GACnD,gBAMW,CAEV,IAAK,EAAW,IAAoB,CAAG,GAAG,EAAK,KAAK,IACpD,KAAM,EAAW,IAAoB,CAAG,GAAG,EAAK,MAAM,IACtD,IAAK,EAAW,IAAoB,CAAG,GAAG,EAAK,KAAK,IACpD,KAAM,EAAW,IAAoB,CAAG,GAAG,EAAK,MAAM,IACtD,IAAK,EAAW,IAAoB,CAAG,GAAG,EAAK,KAAK,IACpD,KAAM,EAAW,IAAoB,CAAG,GAAG,EAAK,MAAM,IAGtD,MAAO,EAAa,IAAsB,CAAG,GAAG,EAAO,QAAQ,IAC/D,SAAU,EAAa,IACrB,CAAG,GAAG,EAAO,YAAY,IAG3B,OAAQ,EAAa,IACnB,CAAG,GAAG,EAAO,QAAQ,EAAQ,6BAC/B,UAAW,EAAa,IACtB,CAAG,GAAG,EAAO,YAAY,EAAQ,6BAGnC,IAAK,EAAa,IAAqB,CAAG,GAAG,EAAO,MAAM,IAC1D,OAAQ,EAAa,IAAqB,CAAG,GAAG,EAAO,UAAU,IAGjE,OAAS,GAAmB,CAAG,GAAG,EAAK,UACvC,UAAY,GAAmB,CAAG,GAAG,EAAK,cAG1C,SAAU,EAAa,EAAU,IAC/B,CAAG,GAAG,EAAO,WAAW,EAAI,OAAO,IACrC,YAAa,EAAa,EAAU,IAClC,CAAG,GAAG,EAAO,eAAe,EAAI,OAAO,IAGzC,KAAM,GAAG,IACH,EAAW,SAAW,EAAU,EAAI,GAAG,OACvC,EAAW,SAAW,EAAU,EAAW,GACxC,CAAG,IAAIA,EAAI,KAAK,EAAY,QAAQ,CAAC,GAG9C,IAAK,GAAG,IACF,EAAW,SAAW,EAAU,EAAI,GAAG,QACvC,EAAW,SAAW,EAAU,EAAW,GACxC,CAAG,IAAIA,EAAI,KAAK,EAAY,OAAO,CAAC,GAG7C,IAAM,GAAwB,CAAG,QAAQ,EAAU,GAGnD,OAAS,GAAuB,CAAG,WAAW,EAAS,GACvD,UAAY,GAAuB,CAAG,eAAe,EAAS,GAC/D,kBAMa,CAEZ,KAAM,EAAW,IAAoB,CAAG,IAAI,EAAK,KAAK,EAAM,GAC5D,UAAW,EAAW,IAAoB,CAAG,IAAI,EAAK,KAAK,EAAM,GACjE,UAAW,EAAW,IAAoB,CAAG,IAAI,EAAK,KAAK,EAAM,GACjE,QAAS,EAAW,IAAoB,CAAG,IAAI,EAAK,KAAK,EAAM,GAG/D,QAAS,GAAG,IACN,EAAM,SAAW,EAAU,EAAI,GAAG,KAClC,EAAM,SAAW,EAAU,EAAM,GAC9B,CAAG,UAAUA,EAAI,KAAK,EAAO,KAAK,CAAC,GAE5C,MAAQ,GAAmB,CAAG,SAAS,EAAK,GAC5C,MAAQ,GAAmB,CAAG,SAAS,EAAK,GAG5C,UAAW,GAAG,IAAsB,CAAG,YAAYA,EAAI,KAAK,EAAO,KAAK,CAAC,GACzE,UAAW,GAAG,IAAsB,CAAG,YAAYA,EAAI,KAAK,EAAO,KAAK,CAAC,GACzE,OAAQ,GAAG,IAAsB,CAAG,SAASA,EAAI,KAAK,EAAO,KAAK,CAAC,GACnE,MAAO,EAAW,IAChB,CAAG,QAAQ,EAAK,MAAM,EAAI,GAAG,GAAG,IAAO,GAC1C,iBAMY,CACX,MAAQ,GACN,EAAO,CAAG,SAAS,EAAK,GAAK,EAAI,GAAG,WACtC,cAAgB,GAAmB,CAAG,kBAAkB,EAAK,GAC7D,IAAM,GAAmB,CAAG,OAAO,EAAK,GACxC,IAAM,GAAmB,CAAG,OAAO,EAAK,GACxC,IAAM,GAAmB,CAAG,OAAO,EAAK,GACxC,IAAM,GAAmB,CAAG,OAAO,EAAK,GACzC,WAMM,CACL,OAAS,GAAgC,CACvC,GAAI,EAAM,SAAW,EAAG,MAAO,GAAI,GAAG,gBACtC,IAAM,EAAO,EAAM,SAAS,CAAC,EAAK,KAAW,CAAC,CAAG,GAAG,IAAO,EAAM,CAAC,CAClE,MAAO,EAAG,eAAeA,EAAI,KAAK,EAAM,KAAK,CAAC,IAGhD,MAAQ,GACF,EAAM,SAAW,EAAU,EAAI,GAAG,eAC/B,CAAG,cAAcA,EAAI,KAAK,EAAO,KAAK,CAAC,GAGhD,eAAuB,EAAI,GAAG,eAE9B,IAAM,GACJ,CAAG,0BAA0B,EAAK,kBAEpC,UAAY,GAGH,CAAG,eAAe,EAAI,GAAG,UAAU,EAAM,MAAM,GAGxD,kBAAoB,GAAkC,CACpD,GAAI,EAAQ,SAAW,EAAG,MAAO,GAAI,GAAG,gBACxC,IAAM,EAAO,EAAQ,SAAS,CAAC,EAAK,KAAW,CAAC,CAAG,GAAG,IAAO,EAAM,CAAC,CACpE,MAAO,EAAG,eAAeA,EAAI,KAAK,EAAM,KAAK,CAAC,IAGhD,SAAU,EAAa,IACjB,EAAK,SAAW,EAAU,EAEvB,CAAG,gBAAgB,EAAO,IADhB,KAAO,EAAK,KAAK,IAAI,CACQ,GAGhD,aAAc,EAAa,IACrB,EAAK,SAAW,EAAU,EAEvB,CAAG,6BAA6B,EAAO,IAD7B,KAAO,EAAK,KAAK,IAAI,CACqB,IAE9D,aAMQ,CAEP,QAAU,GACJ,EAAM,SAAW,EAAU,EAAI,GAAG,eAC/B,CAAG,cAAcA,EAAI,KAAK,EAAO,KAAK,CAAC,GAKhD,KAAM,EAAa,IACjB,CAAG,iBAAiB,EAAO,IAAI,EAAM,GAEvC,UAAW,EAAa,IACtB,CAAG,iBAAiB,EAAO,IAAI,EAAO,GAExC,SAAU,EAAa,IACrB,CAAG,iBAAiB,EAAO,IAAI,EAAO,GAExC,QAAU,GACR,CAAG,gBAAgB,EAAO,WAAW,EAAO,WAE9C,OAAS,GAAqB,CAAG,eAAe,EAAO,GAEvD,KAAM,EAAa,IACjB,CAAG,gBAAgB,EAAO,iBAAiB,EAAM,SAEnD,MAAO,EAAa,IAClB,CAAG,qBAAqB,EAAO,SAAS,EAAM,GAEhD,KAAM,EAAa,EAAY,IAC7B,CAAG,YAAY,EAAO,iBAAiB,EAAM,UAAU,EAAM,GAChE,cAMS,CACR,IAAM,GAAqB,CAAG,GAAG,EAAO,MACxC,KAAO,GAAqB,CAAG,GAAG,EAAO,OAGzC,WAAa,GAAmB,EAChC,UAAY,GAAmB,EAChC,cAMS,CACR,OAAS,GAAsB,CAAG,UAAU,IAC5C,eAAiB,GAAsB,CAAG,mBAAmB,IAC7D,KAAO,GAAoB,CAAG,QAAQ,IACtC,MAAQ,GAAwB,CAAG,SAAS,IAC5C,QAAU,GAAqB,CAAG,YAAY,IAC9C,MAAQ,GAAoB,CAAG,SAAS,IACxC,OAAS,GAAoB,CAAG,UAAU,IAC1C,QAAU,GAAsB,CAAG,YAAY,IAC/C,OAAS,GAAwB,CAAG,UAAU,IAC/C,UAMK,CACJ,QAAS,EAAa,IAAoB,CAAG,GAAG,EAAO,KAAK,IAE5D,WAAY,EAAa,IACvB,CAAG,GAAG,EAAO,KAAK,EAAO,KAAK,IAEhC,WAAY,EAAa,IACvB,CAAG,GAAG,EAAO,KAAK,EAAO,KAAK,IAEhC,UAAW,EAAa,IAAiB,CAAG,GAAG,EAAO,KAAK,EAAO,KAAK,IAEvE,QAAS,EAAa,IAAiB,CAAG,GAAG,EAAO,KAAK,EAAO,KAAK,IAErE,MAAO,EAAa,IAClB,CAAG,GAAG,EAAO,uBAAuB,EAAO,SAAS,EAAM,GAE5D,SAAU,EAAa,IACrB,CAAG,GAAG,EAAO,uBAAuB,EAAO,YAAY,EAAM,GAChE,cAMS,CACR,KAAO,GAAuB,CAAG,WAAW,EAAS,GACrD,MAAQ,GAAuB,CAAG,eAAe,EAAS,GAC1D,KAAO,GAAuB,CAAG,eAAe,EAAS,GACzD,GAAK,GAAuB,CAAG,WAAW,EAAS,GACnD,MAAQ,GAAuB,CAAG,eAAe,EAAS,GAC3D,iBAMY,CACX,OAAS,GAAoB,CAAG,IAAI,EAAM,GAE1C,WAAY,EAAY,IACtB,CAAG,IAAI,EAAM,OAAO,EAAI,GAAG,KAAK,EAAM,MAExC,aAAc,EAAW,IACvB,CAAG,iBAAiB,EAAK,SAAS,IACrC,eAMU,CACT,OAAS,GAA2B,CAGlC,GAAI,EAAM,SACR,OAAO,KAAK,mBAAmB,EAAM,CAGvC,IAAM,EAAmB,CACvB,CAAG,UAAU,EAAM,UACnB,CAAG,QAAQ,EAAM,OAClB,CA8BD,OA5BI,EAAM,OAAS,EAAM,MAAM,OAAS,GACtC,EAAU,KAAK,GAAG,EAAM,MAAM,CAG5B,EAAM,OACR,EAAU,KAAK,CAAG,SAAS,EAAM,QAAQ,CAGvC,EAAM,SACR,EAAU,KAAK,CAAG,YAAY,EAAM,UAAU,CAG5C,EAAM,QACR,EAAU,KAAK,CAAG,UAAU,EAAM,SAAS,CAGzC,EAAM,SACR,EAAU,KAAK,CAAG,YAAY,EAAM,UAAU,CAG5C,EAAM,OACR,EAAU,KAAK,CAAG,SAAS,EAAM,QAAQ,CAGvC,EAAM,QACR,EAAU,KAAK,CAAG,UAAU,EAAM,SAAS,CAGtCA,EAAI,KAAK,EAAW,IAAI,EAElC,UA8EK,CACJ,KAAO,GAAqD,CAC1D,IAAM,EAAO,EAAY,KACtB,CAAE,OAAM,WAAY,CAAG,GAAG,EAAI,GAAG,KAAK,EAAK,IAAI,OAAO,EAAM,GAC9D,CACD,MAAO,EAAG,QAAQA,EAAI,KAAK,EAAM,KAAK,IAGxC,WACE,EACA,EACA,EACA,EAA4B,QACpB,CACR,IAAM,EACJ,IAAU,MAAQ,EAAI,GAAG,YAAc,EAAI,GAAG,QAChD,MAAO,EAAG,kBAAkB,EAAI,GAAG,KAAK,EAAK,IAAI;UAC7C,EAAO;UACP,EAAa;UACb,EAAU;UAGjB,gBAMW,CACV,QAAS,EAAY,EAAmB,IAAyB,CAC/D,IAAM,EAAO,EAAQ,IAAK,GAAM,EAAI,GAAG,KAAK,EAAE,IAAI,CAC5C,EAAO,EAAO,IAAK,GAAQ,CAAG,IAAIA,EAAI,KAAK,EAAK,KAAK,CAAC,GAAG,CAC/D,MAAO,EAAG,eAAe,EAAM,IAAIA,EAAI,KACrC,EACA,KACD,CAAC,WAAWA,EAAI,KAAK,EAAM,KAAK,IAGnC,QAAS,EAAY,EAAW,IAC1B,EACK,CAAG,UAAU,EAAM,OAAO,EAAK,SAAS,IAE1C,CAAG,UAAU,EAAM,OAAO,IAGnC,QAAS,EAAY,IACf,EACK,CAAG,eAAe,EAAM,SAAS,IAEnC,CAAG,eAAe,IAK3B,UAAY,GAAuBA,EAAI,MAGvC,YAAa,EAAqB,IACzB,CAAG,2BAA2B,IAExC,YAMO,CACN,OAAQ,EAAY,IAClB,CAAG,cAAc,EAAM,MAAM,IAE/B,MAAO,EAAY,IACjB,CAAG,aAAa,EAAM,MAAM,IAE9B,OAAQ,EAAY,IAClB,CAAG,cAAc,EAAM,MAAM,IAI/B,MAAO,EAAY,IACjB,CAAG,aAAa,EAAM,MAAM,IAE9B,MAAQ,GAAoB,CAAG,cAAc,IAC9C,oBAMe,CACd,OAAQ,GAAG,IAAwBA,EAAI,KAAK,EAAS,UAAU,CAE/D,UAAW,GAAG,IAAwBA,EAAI,KAAK,EAAS,cAAc,CAEtE,WAAY,GAAG,IAAwBA,EAAI,KAAK,EAAS,cAAc,CAGvE,QAAS,EAAW,IAAoB,CAAG,GAAG,EAAK,UAAU,IAC9D,mBAMc,CACb,kBAAmB,GACnB,yBAA0B,GAC1B,sBAAuB,GACxB,uBAEyB,EAAI,GAAG,mCAMpB,cAMJ,kBAMI,EA9Lb,mBAA2B,EAAwB,CAEjD,IAAM,EAAiB,EAAM,SAAW,EAAM,SAGxC,EAAwB,CAC5B,CAAG,UAAU,EAAM,QAAQ,oCAAoC,EAAM,SAAS,YAAY,EAAe,cACzG,CAAG,QAAQ,EAAM,OAClB,CAEG,EAAM,OAAS,EAAM,MAAM,OAAS,GACtC,EAAe,KAAK,GAAG,EAAM,MAAM,CAGjC,EAAM,OACR,EAAe,KAAK,CAAG,SAAS,EAAM,QAAQ,CAG5C,EAAM,SACR,EAAe,KAAK,CAAG,YAAY,EAAM,UAAU,CAGjD,EAAM,QACR,EAAe,KAAK,CAAG,UAAU,EAAM,SAAS,CAGlD,IAAM,EAAaA,EAAI,KAAK,EAAgB,IAAI,CAG5C,EACJ,GAAI,EAAM,uBAAyB,EAAM,sBAAsB,OAAS,EAAG,CAEzE,IAAM,EAAe,EAAM,sBAAsB,IAC9C,GAAU,EAAI,GAAG,KAAK,EAAM,IAC9B,CACD,EAAc,CAAG,UAAUA,EAAI,KAAK,EAAc,KAAK,CAAC,SAAS,EAAW,kCAG5E,EAAc,CAAG,kBAAkB,EAAW,6BAIhD,IAAM,EAAwB,CAAC,EAAa,EAAI,GAAG,oBAAoB,CAcvE,OAZI,EAAM,SACR,EAAe,KAAK,CAAG,YAAY,EAAM,UAAU,CAGjD,EAAM,OACR,EAAe,KAAK,CAAG,SAAS,EAAM,QAAQ,CAG5C,EAAM,QACR,EAAe,KAAK,CAAG,UAAU,EAAM,SAAS,CAG3CA,EAAI,KAAK,EAAgB,IAAI,GA0IxC,MAAa,EAAe,IAAI,EC9jB1B,MAA8B,CAClC,MAAU,MACR,oEACD,EAGU,EAAqC,CAChD,WAAY,SAAqC,GAAgB,CACjE,YAAc,GAAsC,GAAgB,CACpE,aAAe,GAA+B,GAAgB,CAC/D,CCED,IAAa,EAAb,KAAsD,wBAK7C,GAA2B,EAAI,GAAG,GAAG,qBAM9B,CACZ,OAAS,GAAsB,EAAI,GAAG,IAAI,EAAK,GAE/C,QAAS,EAAe,IACtB,EAAQ,EAAI,GAAG,IAAI,EAAM,KAAK,EAAM,GAAK,EAAI,GAAG,IAAI,EAAM,GAE5D,OAAQ,EAAmB,IACzB,EAAI,GAAG,IAAI,EAAU,QAAQ,EAAM,GAErC,SAAU,EAAiB,IACzB,CAAG,GAAG,EAAW,MAAM,EAAI,GAAG,IAAI,EAAM,KAC3C,eAMU,CACT,MAAQ,GAAoB,CAAG,GAAG,IAElC,SAAiB,EAAI,GAAG,OAGxB,SAAiB,EAAI,GAAG,IAExB,UAAkB,EAAI,GAAG,IAEzB,KAAO,GACD,EAAO,SAAW,EAAU,EAAI,GAAG,KAChC,CAAG,IAAIC,EAAI,KAAK,EAAQ,KAAK,CAAC,GAIvC,KAAO,GAAoB,CAAG,GAAG,KAAK,UAAU,EAAE,GACnD,gBAMW,CAEV,IAAK,EAAW,IAAoB,CAAG,GAAG,EAAK,KAAK,IACpD,KAAM,EAAW,IAAoB,CAAG,GAAG,EAAK,MAAM,IACtD,IAAK,EAAW,IAAoB,CAAG,GAAG,EAAK,KAAK,IACpD,KAAM,EAAW,IAAoB,CAAG,GAAG,EAAK,MAAM,IACtD,IAAK,EAAW,IAAoB,CAAG,GAAG,EAAK,KAAK,IACpD,KAAM,EAAW,IAAoB,CAAG,GAAG,EAAK,MAAM,IAGtD,MAAO,EAAa,IAAsB,CAAG,GAAG,EAAO,QAAQ,IAC/D,SAAU,EAAa,IACrB,CAAG,GAAG,EAAO,YAAY,IAG3B,OAAQ,EAAa,IACnB,CAAG,GAAG,EAAO,QAAQ,EAAQ,iBAC/B,UAAW,EAAa,IACtB,CAAG,GAAG,EAAO,YAAY,EAAQ,iBAGnC,IAAK,EAAa,IAAqB,CAAG,GAAG,EAAO,MAAM,IAC1D,OAAQ,EAAa,IAAqB,CAAG,GAAG,EAAO,UAAU,IAGjE,OAAS,GAAmB,CAAG,GAAG,EAAK,UACvC,UAAY,GAAmB,CAAG,GAAG,EAAK,cAG1C,SAAU,EAAa,EAAU,IAC/B,CAAG,GAAG,EAAO,WAAW,EAAI,OAAO,IACrC,YAAa,EAAa,EAAU,IAClC,CAAG,GAAG,EAAO,eAAe,EAAI,OAAO,IAGzC,KAAM,GAAG,IACH,EAAW,SAAW,EAAU,EAAI,GAAG,IACvC,EAAW,SAAW,EAAU,EAAW,GACxC,CAAG,IAAIA,EAAI,KAAK,EAAY,QAAQ,CAAC,GAG9C,IAAK,GAAG,IACF,EAAW,SAAW,EAAU,EAAI,GAAG,IACvC,EAAW,SAAW,EAAU,EAAW,GACxC,CAAG,IAAIA,EAAI,KAAK,EAAY,OAAO,CAAC,GAG7C,IAAM,GAAwB,CAAG,QAAQ,EAAU,GAGnD,OAAS,GAAuB,CAAG,WAAW,EAAS,GACvD,UAAY,GAAuB,CAAG,eAAe,EAAS,GAC/D,kBAMa,CAEZ,KAAM,EAAW,IAAoB,CAAG,IAAI,EAAK,KAAK,EAAM,GAC5D,UAAW,EAAW,IAAoB,CAAG,IAAI,EAAK,KAAK,EAAM,GACjE,UAAW,EAAW,IAAoB,CAAG,IAAI,EAAK,KAAK,EAAM,GACjE,QAAS,EAAW,IAAoB,CAAG,IAAI,EAAK,KAAK,EAAM,GAG/D,QAAS,GAAG,IACN,EAAM,SAAW,EAAU,EAAI,GAAG,KAClC,EAAM,SAAW,EAAU,EAAM,GAC9B,CAAG,IAAIA,EAAI,KAAK,EAAO,OAAO,CAAC,GAExC,MAAQ,GAAmB,CAAG,SAAS,EAAK,GAC5C,MAAQ,GAAmB,CAAG,SAAS,EAAK,GAG5C,UAAW,GAAG,IAAsB,CAAG,YAAYA,EAAI,KAAK,EAAO,KAAK,CAAC,GACzE,UAAW,GAAG,IAAsB,CAAG,OAAOA,EAAI,KAAK,EAAO,KAAK,CAAC,GACpE,OAAQ,GAAG,IAAsB,CAAG,OAAOA,EAAI,KAAK,EAAO,KAAK,CAAC,GACjE,MAAO,EAAW,IAChB,CAAG,QAAQ,EAAK,MAAM,EAAI,GAAG,GAAG,IAAO,GAC1C,iBAMY,CACX,MAAQ,GACN,EAAO,CAAG,SAAS,EAAK,GAAK,EAAI,GAAG,WACtC,cAAgB,GAAmB,CAAG,kBAAkB,EAAK,GAC7D,IAAM,GAAmB,CAAG,OAAO,EAAK,GACxC,IAAM,GAAmB,CAAG,OAAO,EAAK,GACxC,IAAM,GAAmB,CAAG,OAAO,EAAK,GACxC,IAAM,GAAmB,CAAG,OAAO,EAAK,GACzC,WAMM,CACL,OAAS,GAAgC,CACvC,GAAI,EAAM,SAAW,EAAG,MAAO,GAAI,GAAG,gBACtC,IAAM,EAAO,EAAM,SAAS,CAAC,EAAK,KAAW,CAAC,CAAG,GAAG,IAAO,EAAM,CAAC,CAClE,MAAO,EAAG,eAAeA,EAAI,KAAK,EAAM,KAAK,CAAC,IAGhD,MAAQ,GACF,EAAM,SAAW,EAAU,EAAI,GAAG,eAC/B,CAAG,cAAcA,EAAI,KAAK,EAAO,KAAK,CAAC,GAGhD,eAAuB,EAAI,GAAG,eAE9B,IAAM,GACJ,CAAG,6BAA6B,EAAK,kBAEvC,UAAY,GAGH,CAAG,eAAe,EAAI,GAAG,WAAW,EAAM,KAAK,GAGxD,kBAAoB,GAAkC,CACpD,GAAI,EAAQ,SAAW,EAAG,MAAO,GAAI,GAAG,gBACxC,IAAM,EAAO,EAAQ,SAAS,CAAC,EAAK,KAAW,CAAC,CAAG,GAAG,IAAO,EAAM,CAAC,CACpE,MAAO,EAAG,eAAeA,EAAI,KAAK,EAAM,KAAK,CAAC,IAGhD,SAAU,EAAa,IACjB,EAAK,SAAW,EAAU,EAEvB,CAAG,gBAAgB,EAAO,IADhB,KAAK,EAAK,KAAK,IAAI,GACU,GAGhD,aAAc,EAAa,IAGrB,EAAK,SAAW,EAAU,EAEvB,CAAG,gBAAgB,EAAO,IADhB,KAAK,EAAK,KAAK,IAAI,GACU,GAEjD,aAMQ,CAEP,QAAU,GACJ,EAAM,SAAW,EAAU,EAAI,GAAG,eAC/B,CAAG,cAAcA,EAAI,KAAK,EAAO,KAAK,CAAC,GAIhD,KAAM,EAAa,IACjB,CAAG,mCAAmC,EAAO,kBAAkB,EAAM,GAEvE,UAAW,EAAa,IACtB,CAAG,mCAAmC,EAAO,gDAAgD,EAAO,0BAA0B,EAAO,GAEvI,SAAU,EAAa,IACrB,CAAG,mCAAmC,EAAO,oBAAoB,EAAO,iCAE1E,QAAU,GACR,CAAG,sBAAsB,EAAO,WAAW,EAAO,WAEpD,OAAS,GAAqB,CAAG,qBAAqB,EAAO,GAE7D,KAAM,EAAa,IACjB,CAAG,gBAAgB,EAAO,YAAY,EAAM,UAE9C,MAAO,EAAa,IAClB,CAAG,eAAe,EAAO,YAAY,EAAM,GAE7C,KAAM,EAAa,EAAY,IAC7B,CAAG,YAAY,EAAO,YAAY,EAAM,WAAW,EAAM,GAC5D,cAMS,CACR,IAAM,GAAqB,CAAG,GAAG,EAAO,MACxC,KAAO,GAAqB,CAAG,GAAG,EAAO,OAEzC,WAAa,GAAmB,EAChC,UAAY,GAAmB,EAChC,cAMS,CACR,OAAS,GAAsB,CAAG,UAAU,IAC5C,eAAiB,GAAsB,CAAG,mBAAmB,IAC7D,KAAO,GAAoB,CAAG,QAAQ,IACtC,MAAQ,GAAwB,CAAG,SAAS,IAC5C,QAAU,GAAqB,CAAG,YAAY,IAC9C,MAAQ,GAAoB,CAAG,SAAS,IACxC,OAAS,GAAoB,CAAG,UAAU,IAC1C,QAAU,GAAsB,CAAG,YAAY,IAC/C,OAAS,GAAwB,CAAG,UAAU,IAC/C,UAMK,CACJ,QAAS,EAAa,IAAoB,CAAG,GAAG,EAAO,KAAK,IAE5D,WAAY,EAAa,IACvB,CAAG,GAAG,EAAO,KAAK,EAAO,KAAK,IAEhC,WAAY,EAAa,IACvB,CAAG,GAAG,EAAO,KAAK,EAAO,KAAK,IAEhC,UAAW,EAAa,IAAiB,CAAG,GAAG,EAAO,KAAK,EAAO,KAAK,IAEvE,QAAS,EAAa,IAAiB,CAAG,GAAG,EAAO,KAAK,EAAO,KAAK,IAErE,MAAO,EAAa,IAClB,CAAG,GAAG,EAAO,iBAAiB,EAAO,YAAY,EAAM,GAEzD,SAAU,EAAa,IACrB,CAAG,GAAG,EAAO,sBAAsB,EAAM,0BAA0B,EAAO,6CAA6C,EAAO,WACjI,cAMS,CACR,KAAO,GAAuB,CAAG,WAAW,EAAS,GACrD,MAAQ,GAAuB,CAAG,eAAe,EAAS,GAC1D,KAAO,GAAuB,CAAG,eAAe,EAAS,GACzD,GAAK,GAAuB,CAAG,WAAW,EAAS,GACnD,MAAQ,GAAuB,CAAG,eAAe,EAAS,GAC3D,iBAMY,CACX,OAAS,GAAoB,CAAG,IAAI,EAAM,GAE1C,WAAY,EAAY,IACtB,CAAG,IAAI,EAAM,OAAO,EAAI,GAAG,IAAI,EAAM,KAEvC,aAAc,EAAW,IACvB,CAAG,iBAAiB,EAAK,SAAS,IACrC,eAMU,CACT,OAAS,GAA2B,CAGlC,GAAI,EAAM,SACR,OAAO,KAAK,mBAAmB,EAAM,CAGvC,IAAM,EAAmB,CACvB,CAAG,UAAU,EAAM,UACnB,CAAG,QAAQ,EAAM,OAClB,CA8BD,OA5BI,EAAM,OAAS,EAAM,MAAM,OAAS,GACtC,EAAU,KAAK,GAAG,EAAM,MAAM,CAG5B,EAAM,OACR,EAAU,KAAK,CAAG,SAAS,EAAM,QAAQ,CAGvC,EAAM,SACR,EAAU,KAAK,CAAG,YAAY,EAAM,UAAU,CAG5C,EAAM,QACR,EAAU,KAAK,CAAG,UAAU,EAAM,SAAS,CAGzC,EAAM,SACR,EAAU,KAAK,CAAG,YAAY,EAAM,UAAU,CAG5C,EAAM,OACR,EAAU,KAAK,CAAG,SAAS,EAAM,QAAQ,CAGvC,EAAM,QACR,EAAU,KAAK,CAAG,UAAU,EAAM,SAAS,CAGtCA,EAAI,KAAK,EAAW,IAAI,EAElC,UAiFK,CACJ,KAAO,GAAqD,CAC1D,IAAM,EAAO,EAAY,KACtB,CAAE,OAAM,WAAY,CAAG,GAAG,EAAI,GAAG,IAAI,EAAK,GAAG,OAAO,EAAM,GAC5D,CACD,MAAO,EAAG,QAAQA,EAAI,KAAK,EAAM,KAAK,IAGxC,WACE,EACA,EACA,EACA,EAA4B,QACpB,CACR,IAAM,EACJ,IAAU,MAAQ,EAAI,GAAG,YAAc,EAAI,GAAG,QAChD,MAAO,EAAG,kBAAkB,EAAI,GAAG,IAAI,EAAK,GAAG;UAC3C,EAAO;UACP,EAAa;UACb,EAAU;UAGjB,gBAMW,CACV,QAAS,EAAY,EAAmB,IAAyB,CAC/D,IAAM,EAAO,EAAQ,IAAK,GAAM,EAAI,GAAG,IAAI,EAAE,GAAG,CAC1C,EAAO,EAAO,IAAK,GAAQ,CAAG,IAAIA,EAAI,KAAK,EAAK,KAAK,CAAC,GAAG,CAC/D,MAAO,EAAG,eAAe,EAAM,IAAIA,EAAI,KACrC,EACA,KACD,CAAC,WAAWA,EAAI,KAAK,EAAM,KAAK,IAGnC,QAAS,EAAY,EAAW,IAC1B,EACK,CAAG,UAAU,EAAM,OAAO,EAAK,SAAS,IAE1C,CAAG,UAAU,EAAM,OAAO,IAGnC,QAAS,EAAY,IACf,EACK,CAAG,eAAe,EAAM,SAAS,IAEnC,CAAG,eAAe,IAI3B,UAAY,GAAsB,CAAG,aAAa,IAGlD,YAAa,EAAoB,IAC3B,EACK,CAAG,gBAAgB,EAAO,OAAO,IAEnC,CAAG,kBAAkB,IAE/B,YAMO,CACN,OAAQ,EAAY,IAClB,CAAG,cAAc,EAAM,MAAM,IAE/B,MAAO,EAAY,IACjB,CAAG,aAAa,EAAM,MAAM,IAG9B,OAAQ,EAAY,IAClB,CAAG,aAAa,EAAM,MAAM,IAG9B,MAAO,EAAY,IACjB,CAAG,aAAa,EAAM,MAAM,IAE9B,MAAQ,GAAoB,CAAG,cAAc,IAC9C,oBAMe,CACd,OAAQ,GAAG,IAAwBA,EAAI,KAAK,EAAS,UAAU,CAE/D,UAAW,GAAG,IAAwBA,EAAI,KAAK,EAAS,cAAc,CAEtE,WAAY,GAAG,IAAwBA,EAAI,KAAK,EAAS,cAAc,CAEvE,QAAS,EAAW,IAAoB,CAAG,GAAG,EAAK,UAAU,IAC9D,mBAMc,CACb,kBAAmB,GACnB,yBAA0B,GAC1B,sBAAuB,GACxB,uBAEyB,EAAI,GAAG,sCAMpB,cAMJ,kBAMI,EAlMb,mBAA2B,EAAwB,CAEjD,IAAM,EAAiB,EAAM,SAAW,EAAM,SAGxC,EAAwB,CAC5B,CAAG,UAAU,EAAM,QAAQ,oCAAoC,EAAM,SAAS,YAAY,EAAe,YACzG,CAAG,QAAQ,EAAM,OAClB,CAEG,EAAM,OAAS,EAAM,MAAM,OAAS,GACtC,EAAe,KAAK,GAAG,EAAM,MAAM,CAGjC,EAAM,OACR,EAAe,KAAK,CAAG,SAAS,EAAM,QAAQ,CAG5C,EAAM,SACR,EAAe,KAAK,CAAG,YAAY,EAAM,UAAU,CAGjD,EAAM,QACR,EAAe,KAAK,CAAG,UAAU,EAAM,SAAS,CAGlD,IAAM,EAAaA,EAAI,KAAK,EAAgB,IAAI,CAG5C,EACJ,GAAI,EAAM,uBAAyB,EAAM,sBAAsB,OAAS,EAAG,CAEzE,IAAM,EAAe,EAAM,sBAAsB,IAC9C,GAAU,EAAI,GAAG,IAAI,EAAM,GAC7B,CACD,EAAc,CAAG,UAAUA,EAAI,KAC7B,EACA,KACD,CAAC,SAAS,EAAW,gCAGtB,EAAc,CAAG,kBAAkB,EAAW,2BAIhD,IAAM,EAAwB,CAAC,EAAa,EAAI,GAAG,kBAAkB,CAcrE,OAZI,EAAM,SACR,EAAe,KAAK,CAAG,YAAY,EAAM,UAAU,CAGjD,EAAM,OACR,EAAe,KAAK,CAAG,SAAS,EAAM,QAAQ,CAG5C,EAAM,QACR,EAAe,KAAK,CAAG,UAAU,EAAM,SAAS,CAG3CA,EAAI,KAAK,EAAgB,IAAI,GA2IxC,MAAa,EAAgB,IAAI"}