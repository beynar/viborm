# 3. Relation Class â€” Developer Specification

## Introduction

The Relation Class is responsible for defining relationships between models, including one-to-one, one-to-many, many-to-one, and many-to-many. It supports many-to-many relations with customizable junction table and field names, as well as referential actions for delete/update. The Relation Class is type-safe, chainable, and supports circular/self-references via thunks.

---

## Goals

- **Type Safety:** All relation definitions must be fully type-safe and infer their types for use in models and queries.
- **Chainable API:** Relation configuration must use a chainable, functional API.
- **Many-to-Many:** Support many-to-many relations with customizable junction table/field names via `.through()`, `.A()`, `.B()`.
- **Referential Actions:** Support referential actions on delete/update with `.onDelete()` and `.onUpdate()`.
- **Extensibility:** The Relation Class must be easily extensible for future features.

---

## Implementation Rules

### 1. Directory & File Structure

- All Relation Class code resides in `/src/schema/relation/`.
- Relation types are in `types.ts`, classes in `to-one.ts`, `to-many.ts`, `many-to-many.ts`.
- Helper utilities for junction tables are in `helpers.ts`.

### 2. Relation Class API

Four factory functions create relations:

| Factory | Class | Use Case | Chainable Methods |
|---------|-------|----------|-------------------|
| `s.oneToOne(() => Model)` | `ToOneRelation` | 1:1 relationship | `.fields()`, `.references()`, `.optional()`, `.onDelete()`, `.onUpdate()`, `.name()` |
| `s.manyToOne(() => Model)` | `ToOneRelation` | Many-to-one (FK on this side) | `.fields()`, `.references()`, `.optional()`, `.onDelete()`, `.onUpdate()`, `.name()` |
| `s.oneToMany(() => Model)` | `ToManyRelation` | One-to-many (FK on other side) | `.name()` |
| `s.manyToMany(() => Model)` | `ManyToManyRelation` | Many-to-many (junction table) | `.through()`, `.A()`, `.B()`, `.onDelete()`, `.onUpdate()`, `.name()` |

All methods are chainable and return a new Relation instance with updated configuration.

### 3. Many-to-Many Configuration

Many-to-many relations use a junction table configured via:
- `.through("table_name")` - Junction table name
- `.A("fieldName")` - Source field in junction table
- `.B("fieldName")` - Target field in junction table

### 4. Type Inference

- The Relation Class uses TypeScript generics to infer the relation's type at compile time.
- Thunks `() => Model` defer evaluation for circular references.
- The resulting model type reflects all relation types and constraints.

### 5. Referential Actions

Available actions: `"cascade"`, `"setNull"`, `"restrict"`, `"noAction"`

Configured via `.onDelete(action)` and `.onUpdate(action)` on ToOne and ManyToMany relations.

### 6. Extensibility

- Each relation type is a standalone class with explicit method signatures.
- All internal state is accessible via `relation["~"].state` for introspection.

---

## Example Usage

```ts
import { s } from "viborm";

const user = s.model({
  id: s.string().id().ulid(),
  name: s.string(),
  // Self-referential many-to-many
  friends: s.manyToMany(() => user)
    .through("user_friends")
    .A("userId")
    .B("friendId")
    .onDelete("cascade"),
  // Self-referential one-to-one
  partner: s.oneToOne(() => user)
    .fields("partnerId")
    .references("id")
    .optional()
    .onDelete("setNull"),
  partnerId: s.string().nullable(),
  // One-to-many (FK is on post side)
  posts: s.oneToMany(() => post),
});

const post = s.model({
  id: s.string().id().ulid(),
  title: s.string(),
  authorId: s.string(),
  // Many-to-one with FK configuration
  author: s.manyToOne(() => user)
    .fields("authorId")
    .references("id")
    .onDelete("cascade"),
});
```

---

## Deliverables

- Relation classes in `/src/schema/relation/`
- Full TypeScript support and type inference
- Unit tests for all relation features

---

## Prohibited

- No decorators
- No runtime type generation (all types must be inferred at compile time)

---

## Review Checklist

- [ ] All relation definitions are type-safe and chainable
- [ ] Referential actions are configurable via `.onDelete()` and `.onUpdate()`
- [ ] Many-to-many uses `.through()`, `.A()`, `.B()` for junction table config
- [ ] No decorators are used
- [ ] Example usage compiles and infers correct types
