// Foundation Types: Field Mapping
// Bridge between Field instances and TypeScript types

import type {
  Field,
  Model,
  InferType,
  InferInputType,
  InferStorageType,
  AutoGenerateType,
  FieldStateType,
} from "@schema";

import type { ModelFields, FieldNames } from "./model-extraction.js";

// =============================================================================
// FIELD STATE EXTRACTION
// =============================================================================

/**
 * Extract the state from a FieldLike/Field
 */
type ExtractFieldState<TField> = TField extends { "~": { state: infer S } }
  ? S extends FieldStateType
    ? S
    : never
  : never;

// =============================================================================
// CORE TYPE MAPPING
// =============================================================================

export type MapFieldType<TField extends Field> =
  ExtractFieldState<TField> extends FieldStateType
    ? InferType<ExtractFieldState<TField>>
    : never;

export type MapFieldInputType<TField extends Field> =
  ExtractFieldState<TField> extends FieldStateType
    ? InferInputType<ExtractFieldState<TField>>
    : never;

export type MapFieldStorageType<TField extends Field> =
  ExtractFieldState<TField> extends FieldStateType
    ? InferStorageType<ExtractFieldState<TField>>
    : never;

// =============================================================================
// FIELD PROPERTY ANALYSIS
// =============================================================================

export type IsFieldNullable<TField extends Field> =
  ExtractFieldState<TField> extends FieldStateType
    ? ExtractFieldState<TField>["nullable"]
    : never;

export type IsFieldArray<TField extends Field> =
  ExtractFieldState<TField> extends FieldStateType
    ? ExtractFieldState<TField>["array"]
    : never;

export type IsFieldId<TField extends Field> =
  ExtractFieldState<TField> extends FieldStateType
    ? ExtractFieldState<TField>["isId"]
    : never;

export type IsFieldOptional<TField extends Field> =
  ExtractFieldState<TField> extends FieldStateType
    ? ExtractFieldState<TField>["nullable"] extends true
      ? true
      : ExtractFieldState<TField>["hasDefault"] extends true
        ? true
        : false
    : never;

export type IsFieldUnique<TField extends Field> =
  ExtractFieldState<TField> extends FieldStateType
    ? ExtractFieldState<TField>["isUnique"]
    : never;

export type HasFieldDefault<TField extends Field> =
  ExtractFieldState<TField> extends FieldStateType
    ? ExtractFieldState<TField>["hasDefault"]
    : never;

export type IsFieldAutoGenerated<TField extends Field> =
  ExtractFieldState<TField> extends FieldStateType
    ? ExtractFieldState<TField>["autoGenerate"] extends AutoGenerateType
      ? true
      : false
    : never;

// Model-level field analysis - using conditional types to handle empty models
export type GetUniqueFields<TModel extends Model<any>> =
  FieldNames<TModel> extends never
    ? never
    : {
        [K in FieldNames<TModel>]: K extends keyof ModelFields<TModel>
          ? ModelFields<TModel>[K] extends Field
            ? IsFieldUnique<ModelFields<TModel>[K]> extends true
              ? K
              : IsFieldId<ModelFields<TModel>[K]> extends true
              ? K
              : never
            : never
          : never;
      }[FieldNames<TModel>];

export type GetIdFields<TModel extends Model<any>> =
  FieldNames<TModel> extends never
    ? never
    : {
        [K in FieldNames<TModel>]: K extends keyof ModelFields<TModel>
          ? ModelFields<TModel>[K] extends Field
            ? IsFieldId<ModelFields<TModel>[K]> extends true
              ? K
              : never
            : never
          : never;
      }[FieldNames<TModel>];

export type GetNullableFields<TModel extends Model<any>> =
  FieldNames<TModel> extends never
    ? never
    : {
        [K in FieldNames<TModel>]: K extends keyof ModelFields<TModel>
          ? ModelFields<TModel>[K] extends Field
            ? IsFieldNullable<ModelFields<TModel>[K]> extends true
              ? K
              : never
            : never
          : never;
      }[FieldNames<TModel>];

export type GetArrayFields<TModel extends Model<any>> =
  FieldNames<TModel> extends never
    ? never
    : {
        [K in FieldNames<TModel>]: K extends keyof ModelFields<TModel>
          ? ModelFields<TModel>[K] extends Field
            ? IsFieldArray<ModelFields<TModel>[K]> extends true
              ? K
              : never
            : never
          : never;
      }[FieldNames<TModel>];

// Required vs optional field logic for create operations
export type GetRequiredCreateFields<TModel extends Model<any>> =
  FieldNames<TModel> extends never
    ? never
    : {
        [K in FieldNames<TModel>]: K extends keyof ModelFields<TModel>
          ? ModelFields<TModel>[K] extends Field
            ? IsFieldId<ModelFields<TModel>[K]> extends true
              ? never // ID fields are always optional for create operations
              : IsFieldUnique<ModelFields<TModel>[K]> extends true
              ? never // Unique fields are optional for create operations
              : IsFieldArray<ModelFields<TModel>[K]> extends true
              ? never // Array fields are optional for create operations
              : IsFieldNullable<ModelFields<TModel>[K]> extends true
              ? never
              : HasFieldDefault<ModelFields<TModel>[K]> extends true
              ? never
              : IsFieldAutoGenerated<ModelFields<TModel>[K]> extends true
              ? never
              : K
            : never
          : never;
      }[FieldNames<TModel>];

export type GetOptionalCreateFields<TModel extends Model<any>> =
  FieldNames<TModel> extends never
    ? never
    : {
        [K in FieldNames<TModel>]: K extends keyof ModelFields<TModel>
          ? ModelFields<TModel>[K] extends Field
            ? IsFieldId<ModelFields<TModel>[K]> extends true
              ? K // ID fields are always optional for create operations
              : IsFieldUnique<ModelFields<TModel>[K]> extends true
              ? K // Unique fields are optional for create operations
              : IsFieldArray<ModelFields<TModel>[K]> extends true
              ? K // Array fields are optional for create operations
              : IsFieldNullable<ModelFields<TModel>[K]> extends true
              ? K
              : HasFieldDefault<ModelFields<TModel>[K]> extends true
              ? K
              : IsFieldAutoGenerated<ModelFields<TModel>[K]> extends true
              ? K
              : never
            : never
          : never;
      }[FieldNames<TModel>];

// Create mapped object types for field values
export type MapModelFields<TModel extends Model<any>> =
  FieldNames<TModel> extends never
    ? {}
    : {
        [K in FieldNames<TModel>]: K extends keyof ModelFields<TModel>
          ? ModelFields<TModel>[K] extends Field
            ? MapFieldType<ModelFields<TModel>[K]>
            : never
          : never;
      };

export type MapModelInputFields<TModel extends Model<any>> =
  FieldNames<TModel> extends never
    ? {}
    : {
        [K in FieldNames<TModel>]: K extends keyof ModelFields<TModel>
          ? ModelFields<TModel>[K] extends Field
            ? MapFieldInputType<ModelFields<TModel>[K]>
            : never
          : never;
      };

export type MapModelStorageFields<TModel extends Model<any>> =
  FieldNames<TModel> extends never
    ? {}
    : {
        [K in FieldNames<TModel>]: K extends keyof ModelFields<TModel>
          ? ModelFields<TModel>[K] extends Field
            ? MapFieldStorageType<ModelFields<TModel>[K]>
            : never
          : never;
      };

// Create input type based on required/optional field logic
export type MapModelCreateFields<TModel extends Model<any>> =
  FieldNames<TModel> extends never
    ? {}
    : {
        [K in FieldNames<TModel> as K extends GetRequiredCreateFields<TModel>
          ? K
          : never]: K extends keyof ModelFields<TModel>
          ? ModelFields<TModel>[K] extends Field
            ? MapFieldInputType<ModelFields<TModel>[K]>
            : never
          : never;
      } & {
        [K in FieldNames<TModel> as K extends GetOptionalCreateFields<TModel>
          ? K
          : never]?: K extends keyof ModelFields<TModel>
          ? ModelFields<TModel>[K] extends Field
            ? MapFieldInputType<ModelFields<TModel>[K]>
            : never
          : never;
      };

// Create update type (all fields optional)
export type MapModelUpdateFields<TModel extends Model<any>> =
  FieldNames<TModel> extends never
    ? {}
    : {
        [K in FieldNames<TModel>]?: K extends keyof ModelFields<TModel>
          ? ModelFields<TModel>[K] extends Field
            ? MapFieldInputType<ModelFields<TModel>[K]>
            : never
          : never;
      };

// Utility to check if a field name exists in model
export type IsValidFieldName<
  TModel extends Model<any>,
  TFieldName extends string
> = TFieldName extends FieldNames<TModel> ? true : false;

// Extract field type by name
export type GetFieldByName<
  TModel extends Model<any>,
  TFieldName extends FieldNames<TModel>
> = TFieldName extends keyof ModelFields<TModel>
  ? ModelFields<TModel>[TFieldName] extends Field
    ? ModelFields<TModel>[TFieldName]
    : never
  : never;

// Extract field type by name
export type GetFieldTypeByName<
  TModel extends Model<any>,
  TFieldName extends FieldNames<TModel>
> = TFieldName extends keyof ModelFields<TModel>
  ? ModelFields<TModel>[TFieldName] extends Field
    ? MapFieldType<ModelFields<TModel>[TFieldName]>
    : never
  : never;

// Utility to check if model has specific field types
export type HasIdField<TModel extends Model<any>> =
  GetIdFields<TModel> extends never ? false : true;
export type HasUniqueFields<TModel extends Model<any>> =
  GetUniqueFields<TModel> extends never ? false : true;
export type HasNullableFields<TModel extends Model<any>> =
  GetNullableFields<TModel> extends never ? false : true;
export type HasArrayFields<TModel extends Model<any>> =
  GetArrayFields<TModel> extends never ? false : true;
