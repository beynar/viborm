---
title: Quick Start
description: Build your first VibORM schema in 5 minutes with a simple blog example featuring users and posts
icon: Zap
---

## 1. Define Your Schema

Create a `schema.ts` file with your model definitions:

```ts title="src/db/schema.ts"
import { s } from "viborm";

// User model
export const user = s.model({
  id: s.string().id().ulid(),
  email: s.string().unique(),
  name: s.string(),
  createdAt: s.dateTime().default(() => new Date()),
  posts: s.oneToMany(() => post),
}).map("users");

// Post model
export const post = s.model({
  id: s.string().id().ulid(),
  title: s.string(),
  content: s.string().nullable(),
  published: s.boolean().default(false),
  authorId: s.string(),
  author: s.manyToOne(() => user)
    .fields("authorId")
    .references("id"),
  createdAt: s.dateTime().default(() => new Date()),
}).map("posts");
```

## 2. Create the Client

Initialize your database client with your preferred database:

<Tabs items={["postgres.js", "node-postgres", "SQLite", "PGlite"]}>
  <Tab value="postgres.js">
```ts title="src/db/client.ts"
import { createClient } from "viborm/drivers/postgres";
import * as schema from "./schema";

export const db = createClient({
  schema,
  databaseUrl: process.env.DATABASE_URL,
});
```
  </Tab>
  <Tab value="node-postgres">
```ts title="src/db/client.ts"
import { createClient } from "viborm/drivers/pg";
import * as schema from "./schema";

export const db = createClient({
  schema,
  databaseUrl: process.env.DATABASE_URL,
});
```
  </Tab>
  <Tab value="SQLite">
```ts title="src/db/client.ts"
import { createClient } from "viborm/drivers/sqlite3";
import * as schema from "./schema";

export const db = createClient({
  schema,
  options: { filename: "./data.db" },
});
```
  </Tab>
  <Tab value="PGlite">
```ts title="src/db/client.ts"
import { createClient } from "viborm/drivers/pglite";
import * as schema from "./schema";

export const db = createClient({
  schema,
  dataDir: "./data",
});
```
  </Tab>
</Tabs>

## 3. Query Your Data

Now you can use the fully typed client:

```ts title="src/index.ts"
import { db } from "./db/client";

// Create a user
const newUser = await db.user.create({
  data: {
    email: "alice@example.com",
    name: "Alice",
  },
});

// Create a post for the user
const newPost = await db.post.create({
  data: {
    title: "My First Post",
    content: "Hello, VibORM!",
    authorId: newUser.id,
  },
});

// Find users with their posts
const users = await db.user.findMany({
  where: {
    email: { contains: "@example.com" },
  },
  include: {
    posts: {
      where: { published: true },
      orderBy: { createdAt: "desc" },
    },
  },
});

// Update a post
await db.post.update({
  where: { id: newPost.id },
  data: { published: true },
});

// Delete unpublished posts
await db.post.deleteMany({
  where: { published: false },
});
```

## 4. Type Safety in Action

VibORM provides full type inference:

```ts
// ✅ TypeScript knows the exact shape
const user = await db.user.findUnique({
  where: { email: "alice@example.com" },
  select: { id: true, name: true },
});
// Type: { id: string; name: string } | null

// ❌ TypeScript catches errors at compile time
await db.user.create({
  data: {
    email: "bob@example.com",
    // Error: 'name' is required
  },
});

// ❌ Invalid field names are rejected
await db.user.findMany({
  where: { invalidField: "value" }, // Error: 'invalidField' does not exist
});
```

## Next Steps

<Cards>
  <Card
    title="Schema Definition"
    description="Learn about models, fields, and relations"
    href="/docs/schema"
  />
  <Card
    title="Client API"
    description="Explore all query and mutation operations"
    href="/docs/client"
  />
  <Card
    title="Filtering"
    description="Master the filter operators"
    href="/docs/client/filtering"
  />
</Cards>
