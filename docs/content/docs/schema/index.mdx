---
title: Schema Definition
description: Define type-safe database schemas with a fluent, chainable API for models, fields, and relations
icon: FileCode
---

## Overview

```ts
import { s } from "viborm";

const user = s.model({
  id: s.string().id().ulid(),
  email: s.string().unique(),
  name: s.string().nullable(),
  posts: s.oneToMany(() => post),
});
```

## Key Concepts

### The `s` Builder

All schema definitions use the `s` builder object:

```ts
import { s } from "viborm";

s.model({ ... })              // Create a model
s.string()                    // String field
s.int()                       // Integer field
s.oneToMany(() => post)       // One-to-many relation
s.manyToOne(() => user)       // Many-to-one relation
// ... and more
```

### Chainable API

Every method returns a new instance, enabling fluent definitions:

```ts
s.string()           // Basic string
  .nullable()        // Can be null
  .unique()          // Unique constraint
  .default("value")  // Default value
  .map("column_name") // Custom column name
```

### Type Inference

Types are inferred automatically from your schema:

```ts
const user = s.model({
  id: s.string().id(),
  email: s.string(),
  age: s.int().nullable(),
});

// Inferred type:
// { id: string; email: string; age: number | null }
```

## Components

<Cards>
  <Card
    title="Models"
    description="Define database tables with fields and relations"
    href="/docs/schema/model"
  />
  <Card
    title="Fields"
    description="Scalar field types: string, int, boolean, etc."
    href="/docs/schema/fields"
  />
  <Card
    title="Relations"
    description="Define relationships between models"
    href="/docs/schema/relations"
  />
  <Card
    title="Native Types"
    description="Database-specific type overrides"
    href="/docs/schema/native-types"
  />
  <Card
    title="Validation"
    description="Schema validation rules and error handling"
    href="/docs/schema/validation"
  />
</Cards>
