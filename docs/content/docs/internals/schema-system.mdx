---
title: Schema System
description: How VibORM's schema definition system works
icon: Database
---

# Schema System

The schema system is the foundation of VibORM. It provides a chainable, type-safe API for defining database models.

## Core Components

```mermaid
classDiagram
    class Model~State~ {
        -_fields: Map
        -_relations: Map
        -_tableName: string
        -_compoundId: CompoundConstraint
        -_compoundUniques: CompoundConstraint[]
        -_indexes: IndexDefinition[]
        -_schemas: TypedModelSchemas
        +map(name): Model
        +id(fields, options): Model
        +unique(fields, options): Model
        +index(fields, options): Model
        +extends(fields): Model
        +get ~(): ModelInternals
    }

    class ModelState {
        +fields: FieldRecord
        +compoundId: CompoundConstraint
        +compoundUniques: CompoundConstraint[]
    }

    class Field~State~ {
        -state: FieldState
        -nativeType: NativeType
        +nullable(): Field
        +default(value): Field
        +id(): Field
        +unique(): Field
        +array(): Field
        +map(columnName): Field
        +schema(schema): Field
        +get ~(): FieldInternals
    }

    class FieldState {
        +type: FieldType
        +nullable: boolean
        +hasDefault: boolean
        +defaultValue: unknown
        +isId: boolean
        +isUnique: boolean
        +isArray: boolean
        +autoGenerate: AutoGenerate
        +base: BaseSchema
        +schema: StandardSchemaV1
        +columnName: string
    }

    Model --> ModelState : generic param
    Field --> FieldState : generic param
    Model "1" *-- "*" Field
```

## Model Definition

### Basic Model

```typescript
const user = s.model({
  id: s.string().id().ulid(),
  name: s.string(),
  email: s.string().unique(),
  age: s.int().nullable(),
});
```

### What Happens Internally

```mermaid
sequenceDiagram
    participant U as User Code
    participant S as s.model()
    participant M as Model
    participant F as Fields

    U->>S: s.model({ id: ..., name: ... })
    S->>M: new Model(fields)
    M->>M: Parse field record
    loop For each field
        M->>F: Extract field instance
        M->>M: Add to fieldMap
    end
    loop For each relation
        M->>M: Add to relations map
    end
    M-->>U: Model instance
```

### Model State Generic

The `Model` class uses a single `State` generic that encapsulates all model metadata:

```typescript
interface ModelState<
  TFields extends FieldRecord = FieldRecord,
  TCompoundId extends CompoundConstraint | undefined = undefined,
  TCompoundUniques extends readonly CompoundConstraint[] = []
> {
  fields: TFields;
  compoundId: TCompoundId;
  compoundUniques: TCompoundUniques;
}

class Model<State extends ModelState = ModelState> {
  // State is used for type inference
}
```

This allows chainable methods to update the state:

```typescript
const user = s.model({ ... })        // Model<{ fields: {...}, compoundId: undefined, compoundUniques: [] }>
  .id(["email", "orgId"])            // Model<{ fields: {...}, compoundId: { fields: [...], name: undefined }, ... }>
  .unique(["name"], { name: "uq" })  // Model<{ fields: {...}, ..., compoundUniques: [{ fields: [...], name: "uq" }] }>
```

## Field System

### Field State Machine

Each field has a state that tracks its configuration:

```mermaid
stateDiagram-v2
    [*] --> Base: s.string()
    Base --> Nullable: .nullable()
    Base --> WithDefault: .default(value)
    Base --> AsId: .id()
    Base --> AsUnique: .unique()
    Base --> AsArray: .array()

    Nullable --> NullableWithDefault: .default(value)
    WithDefault --> OptionalNullable: .nullable()

    AsId --> IdWithAuto: .ulid() / .uuid() / .cuid()

    state AsId {
        [*] --> Manual
        Manual --> ULID: .ulid()
        Manual --> UUID: .uuid()
        Manual --> CUID: .cuid()
        Manual --> AutoIncrement: .autoIncrement()
    }
```

### Field Types

```mermaid
graph TB
    subgraph Scalar["Scalar Fields"]
        S[StringField]
        I[IntField]
        F[FloatField]
        D[DecimalField]
        B[BooleanField]
        DT[DateTimeField]
        BI[BigIntField]
        BL[BlobField]
        E[EnumField]
        J[JsonField]
    end

    subgraph Special["Special Fields"]
        V[VectorField]
    end

    subgraph Base["Base Behavior"]
        ST[State Management]
        SC[Schema Generation]
        TI[Type Inference]
    end

    S --> ST
    I --> ST
    F --> ST
    D --> ST
    B --> ST
    DT --> ST
    BI --> ST
    BL --> ST
    E --> ST
    J --> ST
    V --> ST

    ST --> SC
    ST --> TI
```

### Field Schema Generation

Each field generates multiple schemas based on its state. The `base` schema comes directly from `field.state.base`:

```typescript
// StringField with state { nullable: false, hasDefault: false, base: string() }
get schemas() {
  return {
    base: this.state.base,           // Valibot schema: string()
    filter: stringFilter(this.state.base),       // { equals?, contains?, ... } | string
    create: createWithDefault(this.state, this.state.base),       // string (required)
    update: stringUpdate(this.state.base),       // { set?: string } | string
  };
}

// StringField with state { nullable: true, hasDefault: true, base: string() }
get schemas() {
  const nullableBase = nullable(this.state.base);  // Wrap base with nullable()
  return {
    base: nullableBase,              // string | null
    filter: stringNullableFilter(this.state.base),      // { equals?, ... } | string | null
    create: createWithDefault(this.state, nullableBase),  // string | null | undefined
    update: stringNullableUpdate(this.state.base),      // { set?: string | null } | string | null
  };
}
```

The `base` property in `FieldState` stores the core Valibot schema for the field type, which can be modified by `.schema()` to add custom validation or branded types.

## Relation System

### Relation Types

```mermaid
graph TB
    subgraph Relations
        OO[OneToOne]
        OM[OneToMany]
        MO[ManyToOne]
        MM[ManyToMany]
    end

    subgraph Properties
        G["getter: fn â†’ Model"]
        T[relationType]
        O[isOptional]
        F[fields]
        R[references]
        OD[onDelete]
        OU[onUpdate]
    end

    subgraph MMOnly["ManyToMany Only"]
        TH[through]
        A[A]
        B[B]
    end

    OO --> G
    OO --> T
    OO --> O
    OM --> G
    OM --> T
    MO --> G
    MO --> T
    MO --> F
    MO --> R
    MO --> OD
    MO --> OU
    MM --> G
    MM --> T
    MM --> TH
    MM --> A
    MM --> B
```

### Relation Class Hierarchy

```typescript
// Base relation with common functionality
abstract class Relation<M, RT, Optional> {
  protected _getter: () => Model<any>;
  protected _relationType: RT;
  protected _isOptional: Optional;
  // ...
}

// To-one relations (oneToOne, manyToOne)
class ToOneRelation<M, RT, Optional> extends Relation<M, RT, Optional> {
  optional(): ToOneRelation<M, RT, true>;
  fields(...fields: string[]): this;
  references(...refs: string[]): this;
  onDelete(action: ReferentialAction): this;
  onUpdate(action: ReferentialAction): this;
}

// OneToMany relation
class OneToManyRelation<M> extends Relation<M, "oneToMany", false> {
  // No optional() - always returns array
}

// ManyToMany relation
class ManyToManyRelation<M> extends Relation<M, "manyToMany", false> {
  through(tableName: string): this;
  A(columnName: string): this;
  B(columnName: string): this;
}
```

## The `~` Property

Every model, field, and relation exposes internal state via the `~` property:

```typescript
// Access model internals
model["~"].fields; // Map<string, Field>
model["~"].relations; // Map<string, Relation>
model["~"].fieldMap; // Same as fields
model["~"].compoundId; // CompoundConstraint | undefined
model["~"].schemas; // TypedModelSchemas (lazy built)

// Access field internals
field["~"].state; // FieldState
field["~"].schemas; // { base, filter, create, update }
field["~"].nativeType; // NativeType | undefined

// Access relation internals
relation["~"].getter; // () => Model
relation["~"].relationType; // "oneToOne" | "oneToMany" | ...
relation["~"].isOptional; // boolean
```

This convention:

1. Keeps public API clean
2. Provides access for internal tools
3. Uses `~` to indicate "internal" (like Rust's `unsafe`)

## Lazy Schema Building

Model schemas are built lazily on first access:

```mermaid
sequenceDiagram
    participant C as Client
    participant M as Model
    participant B as buildModelSchemas
    participant S as Schemas

    C->>M: model["~"].schemas
    alt First access
        M->>B: buildModelSchemas(model)
        B->>B: Build core schemas
        B->>B: Build args schemas
        B->>S: Cache schemas
        S-->>M: Return schemas
    else Cached
        M->>S: Return cached
    end
    M-->>C: TypedModelSchemas
```

This enables:

1. Circular reference handling (relations between models)
2. Performance (schemas built once per model)
3. Memory efficiency (unused models don't build schemas)
