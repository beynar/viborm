# Nested Writes & SQL Generation Roadmap

This document tracks the progress and remaining work for nested writes and SQL generation features in baseorm.

---

## âœ… Completed Work

### 1. Core SQL Generation Fixes

| Issue | Solution | Files Modified |
|-------|----------|----------------|
| **UPDATE/DELETE alias problem** | Pass empty string `""` for alias in WHERE/RETURNING clauses | `update.ts`, `delete.ts`, `create.ts`, all adapters |
| **`_count` filter not applied** | Created dedicated `countFilter` schema, fixed `buildRelationCount` | `select-builder.ts`, `count-filter.ts`, `select.ts` |

### 2. Nested Writes - Connect/Disconnect

| Feature | Implementation | Notes |
|---------|----------------|-------|
| **`connect` in `create`** | `processConnectOperations()` inlines FK values | FK can be literal or subquery |
| **`connect` in `update`** | Same as above, modifies SET clause | `set-builder.ts` handles Sql objects |
| **`disconnect` in `update`** | Sets FK to NULL | Simple case |

### 3. Nested Creates

| Feature | Implementation | Notes |
|---------|----------------|-------|
| **Single nested create** | Multi-statement INSERT | Works for all databases |
| **Multiple nested creates** | Multiple child INSERTs | All reference same parent ID |
| **Return nested records** | Final SELECT with JSON aggregation | `select: { posts: { select: {...} } }` |
| **App-generated PK (UUID/ULID)** | Uses provided value directly | Known before INSERT |
| **Auto-increment PK** | Uses `adapter.lastInsertId()` | `lastval()` / `last_insert_rowid()` / `LAST_INSERT_ID()` |

### 4. Adapter Enhancements

| Addition | Purpose |
|----------|---------|
| `capabilities.supportsReturning` | PG/SQLite: true, MySQL: false |
| `capabilities.supportsFullOuterJoin` | PG: true, MySQL/SQLite: false |
| `setOperations.union/unionAll/intersect/except` | For combining queries |
| `json.emptyArray()` | Database-specific empty array literal |
| `lastInsertId()` | **NEW** - Returns last auto-generated ID |

---

## ğŸ”² Remaining Work

### ~~Priority 1: Refactor to Unified Multi-Statement Approach~~ âœ… COMPLETED

**Status**: Implemented on 2024-12-31

**What was done**:
- [x] Added `lastInsertId()` to `DatabaseAdapter` interface
- [x] Implemented in all adapters (`lastval()`, `last_insert_rowid()`, `LAST_INSERT_ID()`)
- [x] Rewrote `buildNestedCreate` to use multi-statement with `lastInsertId()`
- [x] Removed CTE-specific code
- [x] Simplified return type (no more batch strategy)
- [x] Updated tests

**Remaining optimization** (not blocking):
```sql
-- Group children of same relation into single multi-row INSERT
INSERT INTO posts (id, title, authorId) VALUES 
  ('p1', 'Title 1', lastval()),
  ('p2', 'Title 2', lastval()),
  ('p3', 'Title 3', lastval());
```

---

### FINAL: Unified Multi-Statement Approach

**Key Insight**: There are only two cases for primary key handling:

| ID Type | Source | Reference in SQL |
|---------|--------|------------------|
| **App-generated** (UUID, ULID) | Known before INSERT | Literal value `'abc-123'` |
| **Auto-increment** (SERIAL, AUTO_INCREMENT) | Generated by DB | `lastval()` / `last_insert_rowid()` / `LAST_INSERT_ID()` |

All databases have a "last insert ID" function that works with their auto-increment mechanism:

| Database | Auto-increment type | Function |
|----------|---------------------|----------|
| PostgreSQL | SERIAL (uses sequence) | `lastval()` âœ“ |
| SQLite | INTEGER PRIMARY KEY | `last_insert_rowid()` âœ“ |
| MySQL | AUTO_INCREMENT | `LAST_INSERT_ID()` âœ“ |

**Adapter Addition**:
```typescript
interface DatabaseAdapter {
  /** Returns SQL for getting the last auto-generated ID */
  lastInsertId: () => Sql;
}

// PostgreSQL: sql.raw`lastval()`
// SQLite: sql.raw`last_insert_rowid()`
// MySQL: sql.raw`LAST_INSERT_ID()`
```

**Unified Builder** (trivially simple):
```typescript
function buildNestedCreate(ctx, parentData, children): Sql {
  const providedPk = parentData[pkField];
  
  // Literal if app-generated, function if auto-increment
  const parentIdRef = providedPk !== undefined
    ? adapter.literals.value(providedPk)
    : adapter.lastInsertId();
  
  return sql.join([
    buildInsert(parentData),
    ...children.map(c => buildInsert({ ...c, [fkField]: parentIdRef })),
    buildSelect(parentIdRef)
  ], "; ");
}
```

**Generated SQL**:
```sql
-- App-generated ID (all databases identical except escaping)
INSERT INTO "Author" ("id", "name") VALUES ('ulid-123', 'Alice');
INSERT INTO "posts" ("id", "authorId") VALUES ('ulid-456', 'ulid-123');
SELECT ... FROM "Author" WHERE "id" = 'ulid-123';

-- Auto-increment ID (PostgreSQL)
INSERT INTO "Author" ("name") VALUES ('Alice');
INSERT INTO "posts" ("authorId") VALUES (lastval());
SELECT ... FROM "Author" WHERE "id" = lastval();

-- Auto-increment ID (MySQL)
INSERT INTO `Author` (`name`) VALUES ('Alice');
INSERT INTO `posts` (`authorId`) VALUES (LAST_INSERT_ID());
SELECT ... FROM `Author` WHERE `id` = LAST_INSERT_ID();
```

**Benefits**:
- âœ… **No CTEs** - simple multi-statement
- âœ… **No branching** - same logic for all databases
- âœ… **Minimal adapter surface** - just add `lastInsertId()`
- âœ… **Trivial builder** - ~10 lines of code

---

### Priority 2: Nested Update Operations

**Use Case**:
```typescript
Author.update({
  where: { id: "author-1" },
  data: {
    name: "Updated Name",
    posts: {
      update: {
        where: { id: "post-1" },
        data: { title: "Updated Title" }
      }
    }
  }
})
```

**Complexity**: Medium

**Key Insight**: Unlike nested creates, we **already know all IDs** from the WHERE clauses before execution. This means:
- No need for `RETURNING` to get generated IDs
- All databases can use similar strategies
- Final SELECT is just a `findUnique` with the known parent ID

**Approach (Works for ALL databases)**:

1. **Execute Updates** (parent + children):
   ```sql
   -- Parent update
   UPDATE "Author" SET "name" = $1 WHERE "id" = $2;
   
   -- Child update (we know both IDs!)
   UPDATE "posts" SET "title" = $3 WHERE "id" = $4 AND "authorId" = $2;
   ```

2. **Fetch Result** (reuse existing findUnique logic):
   ```sql
   SELECT "id", "name", (
     SELECT json_agg(...) FROM "posts" WHERE "authorId" = $2
   ) AS "posts"
   FROM "Author" WHERE "id" = $2
   ```

**For PostgreSQL/SQLite with RETURNING**:
```sql
WITH "update_parent" AS (
  UPDATE "Author" SET "name" = $1 WHERE "id" = $2 RETURNING *
),
"update_posts" AS (
  UPDATE "posts" SET "title" = $3 WHERE "id" = $4 AND "authorId" = $2 RETURNING *
)
SELECT ... FROM "update_parent" ...
```

**Tasks**:
- [ ] Add `update` to relation mutation schema
- [ ] Implement `buildNestedUpdate` builder
- [ ] Reuse `findUnique` + `include` for final SELECT
- [ ] Handle `updateMany` within nested update
- [ ] Wrap in transaction for atomicity

---

### Priority 3: Nested Delete Operations

**Use Case**:
```typescript
Author.update({
  where: { id: "author-1" },
  data: {
    posts: {
      delete: { id: "post-1" }
    }
  }
})
```

**Also**:
```typescript
Author.delete({
  where: { id: "author-1" },
  // Cascade delete related posts?
})
```

**Tasks**:
- [ ] Add `delete` and `deleteMany` to relation mutation schema
- [ ] Handle ON DELETE CASCADE vs manual deletion
- [ ] Implement CTE-based nested delete
- [ ] Add batch strategy for MySQL

---

### ~~Priority 4: CreateMany with Nested Creates~~ (DEFERRED)

**Status**: Deferred - Too complex for initial implementation

**Schema Enforcement**: âœ… **IMPLEMENTED** - The schema now correctly restricts nested `createMany`:

- **Model-level `createMany`**: Uses `core.scalarCreate` (scalars only) - âœ… Already correct
- **Nested `createMany` in relations**: Now uses `getTargetScalarCreateSchema()` - âœ… Fixed

```typescript
// âœ… Allowed
Author.createMany({
  data: [
    { name: "Alice", email: "alice@example.com" },
    { name: "Bob", email: "bob@example.com" }
  ]
})

// âŒ Schema will reject - no nested creates in createMany
Author.create({
  data: {
    name: "Alice",
    posts: {
      createMany: {
        data: [
          { title: "Post 1", nested: { ... } }  // Validation error!
        ]
      }
    }
  }
})
```

**Files Changed**:
- `src/schema/relation/schemas/helpers.ts` - Added `getTargetScalarCreateSchema()`
- `src/schema/relation/schemas/create.ts` - Updated `createMany.data` to use scalar-only schema

**Future Consideration**: If multi-level nested creates in createMany are ever needed:
- Multiple parent CTEs per item
- Each parent's children reference their specific parent
- Significant complexity for result aggregation

---

### Priority 5: Upsert with Nested Operations

**Use Case**:
```typescript
Author.upsert({
  where: { email: "alice@example.com" },
  create: { name: "Alice", posts: { create: [...] } },
  update: { name: "Alice Updated" }
})
```

**Tasks**:
- [ ] `ON CONFLICT` handling with nested creates
- [ ] Different paths for create vs update branches

---

### Priority 6: Comprehensive Test Coverage

**Test Files Needed**:
- [ ] `tests/query-engine/mysql-nested-writes.test.ts`
- [ ] `tests/query-engine/sqlite-nested-writes.test.ts`
- [ ] `tests/execution/nested-writes-execution.test.ts` (integration tests)

**Test Cases**:
- [ ] All PK strategies (auto-increment, UUID, ULID)
- [ ] All FK directions (parent holds FK, child holds FK)
- [ ] Deep nesting (3+ levels)
- [ ] Many-to-many relations
- [ ] Error handling and rollback
- [ ] Transaction isolation

---

## Architecture Notes

### Key Insight: Known IDs vs Generated IDs

The MySQL batch strategy complexity only applies when we need **generated IDs** (from INSERT).

| Operation | IDs Known? | MySQL Strategy |
|-----------|------------|----------------|
| **Nested CREATE** | Parent ID may be auto-generated | Batch with `LAST_INSERT_ID()` |
| **Nested UPDATE** | All IDs known from WHERE clauses | Standard queries, no special handling |
| **Nested DELETE** | All IDs known from WHERE clauses | Standard queries, no special handling |
| **Connect/Disconnect** | Target ID known from input | Standard queries, no special handling |

**Implication**: Only nested CREATE with auto-increment PKs needs the batch strategy. Everything else can use a unified approach across all databases.

### Query Engine vs Executor Separation

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      Query Engine                           â”‚
â”‚  - Validates input                                          â”‚
â”‚  - Builds SQL (Sql objects)                                 â”‚
â”‚  - Returns NestedCreateResult { strategy, sql, batch }      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        Executor                             â”‚
â”‚  - Receives NestedCreateResult                              â”‚
â”‚  - Handles strategy-specific execution                      â”‚
â”‚  - Manages transactions                                     â”‚
â”‚  - Returns parsed results                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         Driver                              â”‚
â”‚  - Raw database connection                                  â”‚
â”‚  - query(), beginTransaction(), commit(), rollback()        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Adapter Capabilities Check

When building queries, always check adapter capabilities:

```typescript
if (adapter.capabilities.supportsCteWithMutations) {
  // PostgreSQL/SQLite path
  return buildCteNestedCreate(...);
} else {
  // MySQL path
  return buildBatchNestedCreate(...);
}
```

---

## Files Reference

| File | Purpose |
|------|---------|
| `src/query-engine/builders/nested-create-builder.ts` | CTE and batch nested create builders |
| `src/query-engine/builders/relation-data-builder.ts` | FK direction, connect/disconnect processing |
| `src/query-engine/query-engine.ts` | Main build() orchestration |
| `src/adapters/database-adapter.ts` | Adapter interface with capabilities |
| `src/schema/relation/schemas/count-filter.ts` | `_count` filter schema |

---

## Timeline Suggestion

1. **Phase 1** (Current): SQL generation for nested creates âœ…
2. **Phase 2**: MySQL executor implementation
3. **Phase 3**: Nested updates and deletes
4. **Phase 4**: CreateMany with nesting
5. **Phase 5**: Upsert with nesting
6. **Phase 6**: Comprehensive testing

---

*Last updated: December 31, 2024*

